<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/Benjamin.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/Benjamin.github.io/" rel="alternate" type="text/html" /><updated>2022-06-06T00:07:50+08:00</updated><id>http://localhost:4000/Benjamin.github.io/feed.xml</id><title type="html">Benjamin Post</title><subtitle></subtitle><entry><title type="html"></title><link href="http://localhost:4000/Benjamin.github.io/2022/06/06/2022-05-28-1.html" rel="alternate" type="text/html" title="" /><published>2022-06-06T00:07:50+08:00</published><updated>2022-06-06T00:07:50+08:00</updated><id>http://localhost:4000/Benjamin.github.io/2022/06/06/2022-05-28-1</id><content type="html" xml:base="http://localhost:4000/Benjamin.github.io/2022/06/06/2022-05-28-1.html"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">fsdaf</title><link href="http://localhost:4000/Benjamin.github.io/2022/06/05/fsdaf.html" rel="alternate" type="text/html" title="fsdaf" /><published>2022-06-05T23:56:37+08:00</published><updated>2022-06-05T23:56:37+08:00</updated><id>http://localhost:4000/Benjamin.github.io/2022/06/05/fsdaf</id><content type="html" xml:base="http://localhost:4000/Benjamin.github.io/2022/06/05/fsdaf.html"><![CDATA[]]></content><author><name></name></author><category term="ll" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">dev_queue_xmit</title><link href="http://localhost:4000/Benjamin.github.io/ebpf,linux,%E5%86%85%E6%A0%B8,%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%A0%81/2022/01/11/dev_queue_xmit.html" rel="alternate" type="text/html" title="dev_queue_xmit" /><published>2022-01-11T08:05:51+08:00</published><updated>2022-01-11T08:05:51+08:00</updated><id>http://localhost:4000/Benjamin.github.io/ebpf,linux,%E5%86%85%E6%A0%B8,%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%A0%81/2022/01/11/dev_queue_xmit</id><content type="html" xml:base="http://localhost:4000/Benjamin.github.io/ebpf,linux,%E5%86%85%E6%A0%B8,%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%A0%81/2022/01/11/dev_queue_xmit.html"><![CDATA[<h1 id="net_rx_action">net_rx_action</h1>

<p>softnet_data.<code class="language-plaintext highlighter-rouge">poll_list</code> 作为接收队列的设备列表。
softnet_data.<code class="language-plaintext highlighter-rouge">output_queue</code> 作出传输队列的设备列表</p>

<p>入口处理函数为:<code class="language-plaintext highlighter-rouge">netif_rx</code>
出口处理函数为:<code class="language-plaintext highlighter-rouge">dev_queue_xmit</code>、<code class="language-plaintext highlighter-rouge">net_tx_action</code></p>

<p><code class="language-plaintext highlighter-rouge">dev_queue_xmit</code> 面向队列处理函数，出口队列是层次化的树形队列。</p>

<p><code class="language-plaintext highlighter-rouge">netif_start_queue</code>:开启设备传输
<code class="language-plaintext highlighter-rouge">netif_stop_queue</code>:关闭设备的传输
<code class="language-plaintext highlighter-rouge">netif_queue_stopped</code>:返回出口队列的状态
如果队列因为某些原因(内存不足)停止传输队列后重启队列传输使用 <code class="language-plaintext highlighter-rouge">netif_wake_queue</code> 而不是用 <code class="language-plaintext highlighter-rouge">netif_start_queue</code>
因为 <code class="language-plaintext highlighter-rouge">netif_wake_queue</code> 不仅会开启传输队列，也会检查该队列中是否有任何信息等待传输。</p>

<p>入口路径获取到一个帧的时候将该帧设备加入设备轮询列表，然后调用 <code class="language-plaintext highlighter-rouge">NET_RX_SOFTIRQ</code> 以准备执行
出口路径要传输帧时，内核会提供 <code class="language-plaintext highlighter-rouge">dev_queue_xmit</code> 从设备的出口队列中获取到一个 帧 ，然后将该帧传递给该设备的 
<code class="language-plaintext highlighter-rouge">hard_start_xmit</code> 方法。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ip_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ip_queue_xmit</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Note: skb-&gt;sk can be different from sk, in case of tunnels */</span>
<span class="kt">int</span> <span class="nf">__ip_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
		    <span class="n">__u8</span> <span class="n">tos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// socket</span>
	<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="c1">// IP 报头选项</span>
	<span class="k">struct</span> <span class="n">ip_options_rcu</span> <span class="o">*</span><span class="n">inet_opt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flowi4</span> <span class="o">*</span><span class="n">fl4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="cm">/* Skip all of this if the packet is already routed,
	 * f.e. by something like SCTP.
	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="c1">// IP 报头选项为了使得 IP 层的函数方便存储，所以就放在了 socket 中</span>
	<span class="n">inet_opt</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_opt</span><span class="p">);</span>
	<span class="n">fl4</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">;</span>
	<span class="c1">// 检查缓冲区是否有路由设置</span>
	<span class="n">rt</span> <span class="o">=</span> <span class="n">skb_rtable</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="p">)</span> <span class="c1">// 有就路由包出去</span>
		<span class="k">goto</span> <span class="n">packet_routed</span><span class="p">;</span>
	<span class="cm">/* Make sure we can route this packet. */</span>
	<span class="c1">// 没有就需要重新路由</span>
	<span class="c1">// 再次检查套接字结构中是否缓存了一条有效路径</span>
	<span class="n">rt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="p">)</span><span class="n">__sk_dst_check</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 没有就需要寻找新的路径</span>
		<span class="n">__be32</span> <span class="n">daddr</span><span class="p">;</span>
		<span class="cm">/* Use correct destination address if we have options. */</span>
		<span class="n">daddr</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_daddr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inet_opt</span> <span class="o">&amp;&amp;</span> <span class="n">inet_opt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">.</span><span class="n">srr</span><span class="p">)</span>
			<span class="n">daddr</span> <span class="o">=</span> <span class="n">inet_opt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">.</span><span class="n">faddr</span><span class="p">;</span>
		<span class="cm">/* If this fails, retransmit mechanism of transport layer will
		 * keep trying until route appears or the connection times
		 * itself out.
		 */</span>
		<span class="c1">// 寻找新的路径</span>
		<span class="n">rt</span> <span class="o">=</span> <span class="n">ip_route_output_ports</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">fl4</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span>
					   <span class="n">daddr</span><span class="p">,</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_saddr</span><span class="p">,</span>
					   <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_dport</span><span class="p">,</span>
					   <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_sport</span><span class="p">,</span>
					   <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">,</span>
					   <span class="n">RT_CONN_FLAGS_TOS</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tos</span><span class="p">),</span>
					   <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_bound_dev_if</span><span class="p">);</span>
		<span class="c1">// 如果路由下一个跳点与 ssr 不吻合就删除包，并返回 ICMP 消息</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">no_route</span><span class="p">;</span>
		<span class="n">sk_setup_caps</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">skb_dst_set_noref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
<span class="nl">packet_routed:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inet_opt</span> <span class="o">&amp;&amp;</span> <span class="n">inet_opt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">.</span><span class="n">is_strictroute</span> <span class="o">&amp;&amp;</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">rt_uses_gateway</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_route</span><span class="p">;</span>
	<span class="cm">/* OK, we know where to send it, allocate and build IP header. */</span>
	<span class="c1">// 构建 IP 报头时需要指针上移</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">inet_opt</span> <span class="o">?</span> <span class="n">inet_opt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">.</span><span class="n">optlen</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="c1">// 重置 skb 包头</span>
	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span><span class="n">iph</span><span class="p">)</span> <span class="o">=</span> <span class="n">htons</span><span class="p">((</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">5</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">tos</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip_dont_fragment</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ignore_df</span><span class="p">)</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">frag_off</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">IP_DF</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">frag_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iph</span><span class="o">-&gt;</span><span class="n">ttl</span>      <span class="o">=</span> <span class="n">ip_select_ttl</span><span class="p">(</span><span class="n">inet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
	<span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">;</span>
	<span class="n">ip_copy_addrs</span><span class="p">(</span><span class="n">iph</span><span class="p">,</span> <span class="n">fl4</span><span class="p">);</span>
	<span class="cm">/* Transport layer set skb-&gt;h.foo itself. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inet_opt</span> <span class="o">&amp;&amp;</span> <span class="n">inet_opt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">.</span><span class="n">optlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">+=</span> <span class="n">inet_opt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">.</span><span class="n">optlen</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="c1">// ip_options_build 会使用 opt 变量，把所需要的选项字段添加至IP 报头</span>
		<span class="c1">// 最后一个参数 为0  代表该报头不属于片段，不能分割</span>
		<span class="n">ip_options_build</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inet_opt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">,</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_daddr</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="c1">// 检查当前封包是否可以被分段，如果可以就设置 IP ID 选项</span>
	<span class="n">ip_select_ident_segs</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span>
			     <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">?:</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* TODO : should we use skb-&gt;sk here instead of sk ? */</span>
	<span class="c1">// 设置把封包排入哪一个发送队列</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_priority</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mark</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_mark</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">ip_local_out</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="nl">no_route:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">IP_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">IPSTATS_MIB_OUTNOROUTES</span><span class="p">);</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ip_local_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">__ip_local_out</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dst_output</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__ip_local_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">iph</span><span class="o">-&gt;</span><span class="n">tot_len</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="c1">// 对 IP 报头计算校验和</span>
	<span class="n">ip_send_check</span><span class="p">(</span><span class="n">iph</span><span class="p">);</span>
	<span class="cm">/* if egress device is enslaved to an L3 master device pass the
	 * skb to its handler for processing
	 */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">l3mdev_ip_out</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nf_hook</span><span class="p">(</span><span class="n">NFPROTO_IPV4</span><span class="p">,</span> <span class="n">NF_INET_LOCAL_OUT</span><span class="p">,</span>
		       <span class="n">net</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		       <span class="n">dst_output</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dst_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// @skb 要传输的封包缓冲区描述符</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">sb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">again</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_SCHED_TSTAMP</span><span class="p">))</span>
		<span class="n">__skb_tstamp_tx</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SCM_TSTAMP_SCHED</span><span class="p">);</span>
	<span class="cm">/* Disable soft irqs for various locks below. Also
	 * stops preemption for RCU.
	 */</span>
	<span class="n">rcu_read_lock_bh</span><span class="p">();</span>
	<span class="n">skb_update_prio</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">qdisc_pkt_len_init</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NET_CLS_ACT
</span>	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_at_ingress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp"># ifdef CONFIG_NET_EGRESS
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">static_branch_unlikely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">egress_needed_key</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">sch_handle_egress</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp"># endif
#endif
</span>	<span class="cm">/* If device/qdisc don't need skb-&gt;dst, release it right now while
	 * its hot in this cpu cache.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_XMIT_DST_RELEASE</span><span class="p">)</span>
		<span class="n">skb_dst_drop</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">skb_dst_force</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_pick_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sb_dev</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">qdisc</span><span class="p">);</span>
	<span class="n">trace_net_dev_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">__dev_xmit_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* The device has no queue. Common case for software devices:
	 * loopback, all the sorts of tunnels...
	 * Really, it is unlikely that netif_tx_lock protection is necessary
	 * here.  (f.e. loopback and IP tunnels are clean ignoring statistics
	 * counters.)
	 * However, it is possible, that they rely on protection
	 * made by us here.
	 * Check this and shot the lock. It is not prone from deadlocks.
	 *Either shot noqueue qdisc, it is even simpler 8)
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span> <span class="cm">/* ok because BHs are off */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">xmit_lock_owner</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">xmit_recursion</span><span class="p">)</span> <span class="o">&gt;</span>
				     <span class="n">XMIT_RECURSION_LIMIT</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">recursion_alert</span><span class="p">;</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">validate_xmit_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">again</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">HARD_TX_LOCK</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_xmit_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">xmit_recursion</span><span class="p">);</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_hard_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="p">);</span>
				<span class="n">__this_cpu_dec</span><span class="p">(</span><span class="n">xmit_recursion</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dev_xmit_complete</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">HARD_TX_UNLOCK</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">HARD_TX_UNLOCK</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
			<span class="n">net_crit_ratelimited</span><span class="p">(</span><span class="s">"Virtual device %s asks to queue packet!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
					     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Recursion is detected! It is possible,
			 * unfortunately
			 */</span>
<span class="nl">recursion_alert:</span>
			<span class="n">net_crit_ratelimited</span><span class="p">(</span><span class="s">"Dead loop on virtual device %s, fix it urgently!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
					     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENETDOWN</span><span class="p">;</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>
	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_dropped</span><span class="p">);</span>
	<span class="n">kfree_skb_list</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__dev_xmit_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">root_lock</span> <span class="o">=</span> <span class="n">qdisc_lock</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">to_free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">contended</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">qdisc_calculate_pkt_len</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TCQ_F_NOLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_DEACTIVATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">__qdisc_drop</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to_free</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">NET_XMIT_DROP</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to_free</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NET_XMIT_MASK</span><span class="p">;</span>
			<span class="n">qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">to_free</span><span class="p">))</span>
			<span class="n">kfree_skb_list</span><span class="p">(</span><span class="n">to_free</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*
	 * Heuristic to force contended enqueues to serialize on a
	 * separate lock before trying to get qdisc main lock.
	 * This permits qdisc-&gt;running owner to get the lock more
	 * often and dequeue packets faster.
	 */</span>
	<span class="n">contended</span> <span class="o">=</span> <span class="n">qdisc_is_running</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">contended</span><span class="p">))</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">busylock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_DEACTIVATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">__qdisc_drop</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to_free</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">NET_XMIT_DROP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TCQ_F_CAN_BYPASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">qdisc_qlen</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="n">qdisc_run_begin</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*
		 * This is a work-conserving queue; there are no old skbs
		 * waiting to be sent out; and the qdisc is not running -
		 * xmit the skb directly.
		 */</span>
		<span class="n">qdisc_bstats_update</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sch_direct_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">root_lock</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">contended</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">busylock</span><span class="p">);</span>
				<span class="n">contended</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">__qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">qdisc_run_end</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">NET_XMIT_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to_free</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NET_XMIT_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qdisc_run_begin</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">contended</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">busylock</span><span class="p">);</span>
				<span class="n">contended</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">__qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
			<span class="n">qdisc_run_end</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">to_free</span><span class="p">))</span>
		<span class="n">kfree_skb_list</span><span class="p">(</span><span class="n">to_free</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">contended</span><span class="p">))</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">busylock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">qdisc_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qdisc_run_begin</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="n">qdisc_run_end</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">__qdisc_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">quota</span> <span class="o">=</span> <span class="n">dev_tx_weight</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">packets</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">qdisc_restart</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">packets</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*
		 * Ordered by possible occurrence: Postpone processing if
		 * 1. we've exceeded packet quota
		 * 2. another process needs the CPU;
		 */</span>
		<span class="n">quota</span> <span class="o">-=</span> <span class="n">packets</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">quota</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">__netif_schedule</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">__netif_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">__netif_reschedule</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">__netif_reschedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">sd</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">softnet_data</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">next_sched</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next_sched</span><span class="p">;</span>
	<span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="n">NET_TX_SOFTIRQ</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">dev_hard_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">skb_mark_not_on_list</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">xmit_one</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dev_xmit_complete</span><span class="p">(</span><span class="n">rc</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_tx_queue_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xmit_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span> <span class="n">bool</span> <span class="n">more</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_nit_active</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">dev_queue_xmit_nit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">trace_net_dev_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">netdev_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">more</span><span class="p">);</span>
	<span class="n">trace_net_dev_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">netdev_tx_t</span> <span class="nf">netdev_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span> <span class="n">bool</span> <span class="n">more</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
	<span class="n">netdev_tx_t</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">__netdev_start_xmit</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">more</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">NETDEV_TX_OK</span><span class="p">)</span>
		<span class="n">txq_trans_update</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">netdev_tx_t</span> <span class="nf">__netdev_start_xmit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					      <span class="n">bool</span> <span class="n">more</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">xmit_more</span> <span class="o">=</span> <span class="n">more</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">skb_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">))</span>
		<span class="n">skb_under_panic</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*
 *	ip_append_data() and ip_append_page() can make one large IP datagram
 *	from many pieces of data. Each pieces will be holded on the socket
 *	until ip_push_pending_frames() is called. Each piece can be a page
 *	or non-page data.
 *
 *	Not only UDP, other transport protocols - e.g. raw sockets - can use
 *	this interface potentially.
 *
 *	LATER: length must be adjusted by pad at tail, when it is required.
 * 主要用于缓存 L4 将要传输的数据
 * @sk: 此封包传输背后的 socket
 * @fl4:
 * @getfrag: 用于把接收自 L4 的有效载荷复制到即将建立的一些数据片段中
 * 
 * @from: 指向 L4 层正试着传输的数据的指针。这不是内核指针，是指向用户空间的指针
 * @length: 要传输的数据量
 * @transhdrlen: L4 报头的指针
 * @ipc: 正确转发封包所必要的信息
 * @rtp: 与此封包相关的路由表项目
 * @flags: 
 */</span>
<span class="kt">int</span> <span class="nf">ip_append_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi4</span> <span class="o">*</span><span class="n">fl4</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">getfrag</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">odd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">),</span>
		   <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">transhdrlen</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">ipcm_cookie</span> <span class="o">*</span><span class="n">ipc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rtable</span> <span class="o">**</span><span class="n">rtp</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="o">&amp;</span><span class="n">MSG_PROBE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ip_setup_cork</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">cork</span><span class="p">.</span><span class="n">base</span><span class="p">,</span> <span class="n">ipc</span><span class="p">,</span> <span class="n">rtp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">transhdrlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">__ip_append_data</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">fl4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">cork</span><span class="p">.</span><span class="n">base</span><span class="p">,</span>
				<span class="n">sk_page_frag</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">getfrag</span><span class="p">,</span>
				<span class="n">from</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">transhdrlen</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ip_append_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">flowi4</span> <span class="o">*</span><span class="n">fl4</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inet_cork</span> <span class="o">*</span><span class="n">cork</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">page_frag</span> <span class="o">*</span><span class="n">pfrag</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">getfrag</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">odd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">),</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">transhdrlen</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubuf_info</span> <span class="o">*</span><span class="n">uarg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_options</span> <span class="o">*</span><span class="n">opt</span> <span class="o">=</span> <span class="n">cork</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hh_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exthdrlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mtu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxfraglen</span><span class="p">,</span> <span class="n">fragheaderlen</span><span class="p">,</span> <span class="n">maxnonfragsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">csummode</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="p">)</span><span class="n">cork</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wmem_alloc_delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">paged</span><span class="p">,</span> <span class="n">extra_uref</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tskey</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek_tail</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">exthdrlen</span> <span class="o">=</span> <span class="o">!</span><span class="n">skb</span> <span class="o">?</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">header_len</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mtu</span> <span class="o">=</span> <span class="n">cork</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">?</span> <span class="n">IP_MAX_MTU</span> <span class="o">:</span> <span class="n">cork</span><span class="o">-&gt;</span><span class="n">fragsize</span><span class="p">;</span>
	<span class="n">paged</span> <span class="o">=</span> <span class="o">!!</span><span class="n">cork</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cork</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_ANY_SW_TSTAMP</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_tsflags</span> <span class="o">&amp;</span> <span class="n">SOF_TIMESTAMPING_OPT_ID</span><span class="p">)</span>
		<span class="n">tskey</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_tskey</span><span class="o">++</span><span class="p">;</span>
	<span class="n">hh_len</span> <span class="o">=</span> <span class="n">LL_RESERVED_SPACE</span><span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">fragheaderlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">opt</span> <span class="o">?</span> <span class="n">opt</span><span class="o">-&gt;</span><span class="n">optlen</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">maxfraglen</span> <span class="o">=</span> <span class="p">((</span><span class="n">mtu</span> <span class="o">-</span> <span class="n">fragheaderlen</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">fragheaderlen</span><span class="p">;</span>
	<span class="n">maxnonfragsize</span> <span class="o">=</span> <span class="n">ip_sk_ignore_df</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0xFFFF</span> <span class="o">:</span> <span class="n">mtu</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cork</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">maxnonfragsize</span> <span class="o">-</span> <span class="n">fragheaderlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip_local_error</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">EMSGSIZE</span><span class="p">,</span> <span class="n">fl4</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_dport</span><span class="p">,</span>
			       <span class="n">mtu</span> <span class="o">-</span> <span class="p">(</span><span class="n">opt</span> <span class="o">?</span> <span class="n">opt</span><span class="o">-&gt;</span><span class="n">optlen</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*
	 * transhdrlen &gt; 0 means that this is the first fragment and we wish
	 * it won't be fragmented in the future.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transhdrlen</span> <span class="o">&amp;&amp;</span>
	    <span class="n">length</span> <span class="o">+</span> <span class="n">fragheaderlen</span> <span class="o">&lt;=</span> <span class="n">mtu</span> <span class="o">&amp;&amp;</span>
	    <span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NETIF_F_HW_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_IP_CSUM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_MORE</span><span class="p">)</span> <span class="o">||</span> <span class="n">cork</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">exthdrlen</span> <span class="o">||</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_ESP_TX_CSUM</span><span class="p">)))</span>
		<span class="n">csummode</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_ZEROCOPY</span> <span class="o">&amp;&amp;</span> <span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZEROCOPY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">uarg</span> <span class="o">=</span> <span class="n">sock_zerocopy_realloc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">skb_zcopy</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uarg</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="n">extra_uref</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_SG</span> <span class="o">&amp;&amp;</span>
		    <span class="n">csummode</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">paged</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uarg</span><span class="o">-&gt;</span><span class="n">zerocopy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">skb_zcopy_set</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">uarg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extra_uref</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cork</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
	<span class="cm">/* So, what's going on in the loop below?
	 *
	 * We use calculated fragment length to generate chained skb,
	 * each of segments is IP fragment ready for sending to network after
	 * adding appropriate IP header.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">alloc_new_skb</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check if the remaining data fits into current packet. */</span>
		<span class="n">copy</span> <span class="o">=</span> <span class="n">mtu</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">maxfraglen</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fraglen</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fraggap</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloclen</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pagedlen</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_prev</span><span class="p">;</span>
<span class="nl">alloc_new_skb:</span>
			<span class="n">skb_prev</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_prev</span><span class="p">)</span>
				<span class="n">fraggap</span> <span class="o">=</span> <span class="n">skb_prev</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">maxfraglen</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">fraggap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/*
			 * If remaining data exceeds the mtu,
			 * we know we need more fragment(s).
			 */</span>
			<span class="n">datalen</span> <span class="o">=</span> <span class="n">length</span> <span class="o">+</span> <span class="n">fraggap</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">datalen</span> <span class="o">&gt;</span> <span class="n">mtu</span> <span class="o">-</span> <span class="n">fragheaderlen</span><span class="p">)</span>
				<span class="n">datalen</span> <span class="o">=</span> <span class="n">maxfraglen</span> <span class="o">-</span> <span class="n">fragheaderlen</span><span class="p">;</span>
			<span class="n">fraglen</span> <span class="o">=</span> <span class="n">datalen</span> <span class="o">+</span> <span class="n">fragheaderlen</span><span class="p">;</span>
			<span class="n">pagedlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_MORE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span><span class="o">&amp;</span><span class="n">NETIF_F_SG</span><span class="p">))</span>
				<span class="n">alloclen</span> <span class="o">=</span> <span class="n">mtu</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">paged</span><span class="p">)</span>
				<span class="n">alloclen</span> <span class="o">=</span> <span class="n">fraglen</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">alloclen</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">fraglen</span><span class="p">,</span> <span class="n">MAX_HEADER</span><span class="p">);</span>
				<span class="n">pagedlen</span> <span class="o">=</span> <span class="n">fraglen</span> <span class="o">-</span> <span class="n">alloclen</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">alloclen</span> <span class="o">+=</span> <span class="n">exthdrlen</span><span class="p">;</span>
			<span class="cm">/* The last fragment gets additional space at tail.
			 * Note, with MSG_MORE we overallocate on fragments,
			 * because we have no idea what fragment will be
			 * the last.
			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">datalen</span> <span class="o">==</span> <span class="n">length</span> <span class="o">+</span> <span class="n">fraggap</span><span class="p">)</span>
				<span class="n">alloclen</span> <span class="o">+=</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">trailer_len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">transhdrlen</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_alloc_send_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
						<span class="n">alloclen</span> <span class="o">+</span> <span class="n">hh_len</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span>
						<span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">refcount_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">)</span> <span class="o">+</span> <span class="n">wmem_alloc_delta</span> <span class="o">&lt;=</span>
				    <span class="mi">2</span> <span class="o">*</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">)</span>
					<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">alloclen</span> <span class="o">+</span> <span class="n">hh_len</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span>
							<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="cm">/*
			 *	Fill in the control structures
			 */</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">csummode</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hh_len</span><span class="p">);</span>
			<span class="cm">/*
			 *	Find where to start putting bytes.
			 */</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fraglen</span> <span class="o">+</span> <span class="n">exthdrlen</span> <span class="o">-</span> <span class="n">pagedlen</span><span class="p">);</span>
			<span class="n">skb_set_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">exthdrlen</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">+</span>
						 <span class="n">fragheaderlen</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">+=</span> <span class="n">fragheaderlen</span> <span class="o">+</span> <span class="n">exthdrlen</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fraggap</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">skb_copy_and_csum_bits</span><span class="p">(</span>
					<span class="n">skb_prev</span><span class="p">,</span> <span class="n">maxfraglen</span><span class="p">,</span>
					<span class="n">data</span> <span class="o">+</span> <span class="n">transhdrlen</span><span class="p">,</span> <span class="n">fraggap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">skb_prev</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">csum_sub</span><span class="p">(</span><span class="n">skb_prev</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span>
							  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">);</span>
				<span class="n">data</span> <span class="o">+=</span> <span class="n">fraggap</span><span class="p">;</span>
				<span class="n">pskb_trim_unique</span><span class="p">(</span><span class="n">skb_prev</span><span class="p">,</span> <span class="n">maxfraglen</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">datalen</span> <span class="o">-</span> <span class="n">transhdrlen</span> <span class="o">-</span> <span class="n">fraggap</span> <span class="o">-</span> <span class="n">pagedlen</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">getfrag</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">transhdrlen</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">fraggap</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">length</span> <span class="o">-=</span> <span class="n">copy</span> <span class="o">+</span> <span class="n">transhdrlen</span><span class="p">;</span>
			<span class="n">transhdrlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">exthdrlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">csummode</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
			<span class="cm">/* only the initial fragment is time stamped */</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">=</span> <span class="n">cork</span><span class="o">-&gt;</span><span class="n">tx_flags</span><span class="p">;</span>
			<span class="n">cork</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tskey</span> <span class="o">=</span> <span class="n">tskey</span><span class="p">;</span>
			<span class="n">tskey</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">skb_zcopy_set</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">uarg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extra_uref</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_CONFIRM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_prev</span><span class="p">)</span>
				<span class="n">skb_set_dst_pending_confirm</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="cm">/*
			 * Put the packet on the pending queue.
			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">sock_wfree</span><span class="p">;</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
				<span class="n">wmem_alloc_delta</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">)</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span><span class="o">&amp;</span><span class="n">NETIF_F_SG</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">copy</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">off</span><span class="p">;</span>
			<span class="n">off</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">getfrag</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">copy</span><span class="p">),</span>
					<span class="n">offset</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uarg</span> <span class="o">||</span> <span class="o">!</span><span class="n">uarg</span><span class="o">-&gt;</span><span class="n">zerocopy</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_page_frag_refill</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">pfrag</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_can_coalesce</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pfrag</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span>
					      <span class="n">pfrag</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
				<span class="n">__skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pfrag</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span>
						     <span class="n">pfrag</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="o">++</span><span class="n">i</span><span class="p">;</span>
				<span class="n">get_page</span><span class="p">(</span><span class="n">pfrag</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">pfrag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">pfrag</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">getfrag</span><span class="p">(</span><span class="n">from</span><span class="p">,</span>
				    <span class="n">page_address</span><span class="p">(</span><span class="n">pfrag</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">pfrag</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
				    <span class="n">offset</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error_efault</span><span class="p">;</span>
			<span class="n">pfrag</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">skb_frag_size_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">copy</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">wmem_alloc_delta</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">skb_zerocopy_iter_dgram</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">length</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wmem_alloc_delta</span><span class="p">)</span>
		<span class="n">refcount_add</span><span class="p">(</span><span class="n">wmem_alloc_delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error_efault:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uarg</span><span class="p">)</span>
		<span class="n">sock_zerocopy_put_abort</span><span class="p">(</span><span class="n">uarg</span><span class="p">,</span> <span class="n">extra_uref</span><span class="p">);</span>
	<span class="n">cork</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">IP_INC_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">IPSTATS_MIB_OUTDISCARDS</span><span class="p">);</span>
	<span class="n">refcount_add</span><span class="p">(</span><span class="n">wmem_alloc_delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Benjamin Yim</name></author><category term="eBPF,Linux,内核,网络代码" /><category term="ebpf" /><summary type="html"><![CDATA[net_rx_action]]></summary></entry><entry><title type="html">net_rx_action</title><link href="http://localhost:4000/Benjamin.github.io/ebpf,linux,%E5%86%85%E6%A0%B8,%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%A0%81/2022/01/09/net_rx_action.html" rel="alternate" type="text/html" title="net_rx_action" /><published>2022-01-09T07:47:45+08:00</published><updated>2022-01-09T07:47:45+08:00</updated><id>http://localhost:4000/Benjamin.github.io/ebpf,linux,%E5%86%85%E6%A0%B8,%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%A0%81/2022/01/09/net_rx_action</id><content type="html" xml:base="http://localhost:4000/Benjamin.github.io/ebpf,linux,%E5%86%85%E6%A0%B8,%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%A0%81/2022/01/09/net_rx_action.html"><![CDATA[<h1 id="net_rx_action">net_rx_action</h1>
<p>软中断触发，开始接收处理帧队列</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">__latent_entropy</span> <span class="kt">void</span> <span class="nf">net_rx_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">softnet_data</span><span class="p">);</span> <span class="c1">// 获取绑定 CPU 的 softnet_data</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time_limit</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">usecs_to_jiffies</span><span class="p">(</span><span class="n">netdev_budget_usecs</span><span class="p">);</span> <span class="c1">// 单次处理时长限制</span>
	<span class="kt">int</span> <span class="n">budget</span> <span class="o">=</span> <span class="n">netdev_budget</span><span class="p">;</span> <span class="c1">// 单次处理 skb 上限，默认 300</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">list</span><span class="p">);</span> <span class="c1">// 移动到列表头</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">repoll</span><span class="p">);</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="c1">// </span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd_has_rps_ipi_waiting</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">repoll</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">napi_struct</span><span class="p">,</span> <span class="n">poll_list</span><span class="p">);</span> <span class="c1">// </span>
		<span class="n">budget</span> <span class="o">-=</span> <span class="n">napi_poll</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repoll</span><span class="p">);</span> <span class="c1">// NAPI poll 虚拟函数处理，并返回处理数量</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">budget</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">time_limit</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">time_squeeze</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span> <span class="c1">// 连接两个列表，并重新初始化空列表</span>
	<span class="n">list_splice_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">repoll</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span> <span class="c1">// 连接两个列表，每个列表是一个队列</span>
	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">))</span>
		<span class="n">__raise_softirq_irqoff</span><span class="p">(</span><span class="n">NET_RX_SOFTIRQ</span><span class="p">);</span>
	<span class="n">net_rps_action_and_irq_enable</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">__kfree_skb_flush</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">napi_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">repoll</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">have</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">);</span>
	<span class="n">have</span> <span class="o">=</span> <span class="n">netpoll_poll_lock</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="n">weight</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
	<span class="n">work</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// NAPI 调用 poll 虚拟函数</span>
		<span class="n">work</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
		<span class="n">trace_napi_poll</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">work</span> <span class="o">&gt;</span> <span class="n">weight</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">work</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">napi_disable_pending</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// 将设备从 poll_list 中把设备删除，并触发 NET_RX_SOFTIRQ</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">gro_bitmask</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 是否使用 gro 功能</span>
		<span class="n">napi_gro_flush</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pr_warn_once</span><span class="p">(</span><span class="s">"%s: Budget exhausted after napi rescheduled</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
			     <span class="n">n</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">?</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">"backlog"</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">,</span> <span class="n">repoll</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">netpoll_poll_unlock</span><span class="p">(</span><span class="n">have</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">work</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">napi_poll</code> 调用的是虚拟函数 <code class="language-plaintext highlighter-rouge">poll</code> 是 <code class="language-plaintext highlighter-rouge">NAPI</code> 采用的标准形式，<code class="language-plaintext highlighter-rouge">process_backlog</code> 是在 <code class="language-plaintext highlighter-rouge">NAPI</code>
没有使用的情况下使用的一种帧处理函数操作。与 <code class="language-plaintext highlighter-rouge">NAPI</code> 的区别就是 <code class="language-plaintext highlighter-rouge">NAPI</code> 的处理函数被调用的过程中
中断是关闭的，但是 <code class="language-plaintext highlighter-rouge">process_backlog</code> 处理的过程中断是开启的。所以在对 <code class="language-plaintext highlighter-rouge">softnet_data</code> 操作时需要
对数据做保护而开启中断，然后关闭中断防止操作数据时出现不可预测的问题。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">process_backlog</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quota</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">softnet_data</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span> <span class="c1">// 取得 softnet_data</span>
	<span class="n">bool</span> <span class="n">again</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd_has_rps_ipi_waiting</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 对接收 packet 进行负载均衡</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">net_rps_action_and_irq_enable</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">dev_rx_weight</span><span class="p">;</span> 
	<span class="k">while</span> <span class="p">(</span><span class="n">again</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">process_queue</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span> <span class="c1">// 获取读锁</span>
			<span class="n">__netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span> <span class="c1">// 接收数据包</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span> <span class="c1">// 释放读锁</span>
			<span class="n">input_queue_head_incr</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span> <span class="c1">//</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">work</span> <span class="o">&gt;=</span> <span class="n">quota</span><span class="p">)</span> <span class="c1">// 更新 work 次数，与处理次数上限比较</span>
				<span class="k">return</span> <span class="n">work</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">local_irq_disable</span><span class="p">();</span> <span class="c1">// 禁用中断</span>
		<span class="n">rps_lock</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span> <span class="c1">// 负载均衡也上锁?当禁用中断的情况先是否需要对 rps 上锁，而且上锁的力度是否需要这么粗</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 如果等于空就结束</span>
			<span class="n">napi</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">again</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">skb_queue_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">process_queue</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">rps_unlock</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">work</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">__netif_receive_skb</code> 是辅助函数，<code class="language-plaintext highlighter-rouge">poll</code> 会用他来处理入口帧。<code class="language-plaintext highlighter-rouge">__netif_receive_skb</code> 主要有三个任务:</p>

<ol>
  <li>把帧的副本传给每个协议分流器，如果正在运行的话</li>
  <li>把帧的副本传给 <code class="language-plaintext highlighter-rouge">skb-&gt;protocol</code> 所关联的 <code class="language-plaintext highlighter-rouge">L3</code> 协议处理函数</li>
  <li>负责当前层必须处理的一些功能，比如桥接功能。</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
* @skb: 数据帧
* @pfmemalloc: 是否使用紧急内存
* @ppt_prev: 网络类型，用于返回到上层使用，分配给不同的协议栈处理
*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__netif_receive_skb_core</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">pfmemalloc</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">**</span><span class="n">ppt_prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">ptype</span><span class="p">,</span> <span class="o">*</span><span class="n">pt_prev</span><span class="p">;</span> <span class="c1">// 帧协议类型</span>
	<span class="n">rx_handler_func_t</span> <span class="o">*</span><span class="n">rx_handler</span><span class="p">;</span> <span class="c1">// 帧接收处理器</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">orig_dev</span><span class="p">;</span> <span class="c1">// 来源设备列表</span>
	<span class="n">bool</span> <span class="n">deliver_exact</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 分流</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">net_timestamp_check</span><span class="p">(</span><span class="o">!</span><span class="n">netdev_tstamp_prequeue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span> <span class="c1">// 如果没设置 timestamp 则对 skb-&gt;stamp 做初始化</span>
	<span class="n">trace_netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">orig_dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span> 
	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span> <span class="c1">// 初始化 skb-&gt;(n,nh,mac_len)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_transport_header_was_set</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>  
		<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span> 
	<span class="n">skb_reset_mac_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span> 
	<span class="n">pt_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">another_round:</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span> <span class="c1">// 网卡接口</span>
	<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">.</span><span class="n">processed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_8021AD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_vlan_untag</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_skip_tc_classify</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="c1">// 是否需要 tc 分流器</span>
		<span class="k">goto</span> <span class="n">skip_classify</span><span class="p">;</span> <span class="c1">// 不需要分流器就跳过</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfmemalloc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">skip_taps</span><span class="p">;</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptype_all</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">deliver_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span> 
		<span class="n">pt_prev</span> <span class="o">=</span> <span class="n">ptype</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ptype_all</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">deliver_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
		<span class="n">pt_prev</span> <span class="o">=</span> <span class="n">ptype</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">skip_taps:</span>
<span class="cp">#ifdef CONFIG_NET_INGRESS
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">static_branch_unlikely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ingress_needed_key</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">sch_handle_ingress</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt_prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_ingress</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt_prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif
</span>	<span class="n">skb_reset_tc</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">skip_classify:</span>
	<span class="c1">// ETH_P_ARP、ETH_P_IP、ETH_P_IPV6、ETH_P_8021Q、ETH_P_8021AD 允许使用紧急内存，其他不允许</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfmemalloc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_pfmemalloc_protocol</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_vlan_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 是否  vlan 协议</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">deliver_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
			<span class="n">pt_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vlan_do_receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="p">))</span> <span class="c1">// 做 vlan 的协议解析，然后重新走一遍处理 __netif_receive_skb_core 流程</span>
			<span class="k">goto</span> <span class="n">another_round</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rx_handler</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_handler</span><span class="p">);</span> <span class="c1">// 获取rcu保护的指针解引用</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">deliver_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span> 
			<span class="n">pt_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">rx_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">RX_HANDLER_CONSUMED</span><span class="p">:</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">RX_HANDLER_ANOTHER</span><span class="p">:</span>
			<span class="k">goto</span> <span class="n">another_round</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">RX_HANDLER_EXACT</span><span class="p">:</span>
			<span class="n">deliver_exact</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">RX_HANDLER_PASS</span><span class="p">:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_vlan_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_vlan_tag_get_id</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_OTHERHOST</span><span class="p">;</span>
		<span class="cm">/* Note: we might in the future use prio bits
		 * and set skb-&gt;priority like in vlan_do_receive()
		 * For the time being, just ignore Priority Code Point
		 */</span>
		<span class="n">__vlan_hwaccel_clear_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="cm">/* 仅在指定时提供完全匹配 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">deliver_exact</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">deliver_ptype_list_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">ptype_base</span><span class="p">[</span><span class="n">ntohs</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;</span>
						   <span class="n">PTYPE_HASH_MASK</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">deliver_ptype_list_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">orig_dev</span><span class="o">-&gt;</span><span class="n">ptype_specific</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">!=</span> <span class="n">orig_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">deliver_ptype_list_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ptype_specific</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_orphan_frags_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ppt_prev</span> <span class="o">=</span> <span class="n">pt_prev</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="nl">drop:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">deliver_exact</span><span class="p">)</span>
			<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_dropped</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_nohandler</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="cm">/* Jamal, now you will not able to escape explaining
		 * me how you were going to use this. :-)
		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><strong>diverter 允许内核改变原本发往其他主机帧的 L2 目的地址，使得帧可以改道发往本地主机。这种功能可以</strong>
<strong>用于：所有 IP 包、所有 TCP 包、特定端口的 TCP 包、所有 UDP 包、特定端口的 UDP 包</strong></p>

<h1 id="帧传输">帧传输</h1>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
		<span class="n">skb_tx_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">iowrite32_rep</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TX_FIFO</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// ioaddr:地址空间</span>
		<span class="n">dev_consume_skb_any</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioread16</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">TxFree</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1536</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果可用空间大于 1536 字节</span>
			<span class="n">netif_start_queue</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* AKPM: redundant? */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Interrupt us when the FIFO has room for max-sized packet. */</span>
			<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span> <span class="c1">// 停止传输</span>
			<span class="n">iowrite16</span><span class="p">(</span><span class="n">SetTxThreshold</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1536</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">),</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">EL3_CMD</span><span class="p">);</span>
		<span class="p">}</span>
<span class="p">...</span>
</code></pre></div></div>

<h1 id="扩展阅读">扩展阅读</h1>
<p><a href="https://tqr.ink/2017/07/09/implementation-of-rps-and-rfs/">Linux中rps/rfs的原理及实现</a>
<a href="https://blog.csdn.net/kickxxx/article/details/9303845">伙伴系统分配器 - PF_MEMALLOC 标志位</a></p>]]></content><author><name>Benjamin Yim</name></author><category term="eBPF,Linux,内核,网络代码" /><category term="ebpf" /><summary type="html"><![CDATA[net_rx_action 软中断触发，开始接收处理帧队列 ```c static __latent_entropy void net_rx_action(struct softirq_action *h) { struct softnet_data *sd = this_cpu_ptr(&amp;softnet_data); // 获取绑定 CPU 的 softnet_data unsigned long time_limit = jiffies + usecs_to_jiffies(netdev_budget_usecs); // 单次处理时长限制 int budget = netdev_budget; // 单次处理 skb 上限，默认 300 LIST_HEAD(list); // 移动到列表头 LIST_HEAD(repoll); local_irq_disable(); list_splice_init(&amp;sd-&gt;poll_list, &amp;list); local_irq_enable(); for (;;) { struct napi_struct *n; // if (list_empty(&amp;list)) { if (!sd_has_rps_ipi_waiting(sd) &amp;&amp; list_empty(&amp;repoll)) goto out; break; } n = list_first_entry(&amp;list, struct napi_struct, poll_list); // budget -= napi_poll(n, &amp;repoll); // NAPI poll 虚拟函数处理，并返回处理数量 if (unlikely(budget &lt;= 0 || time_after_eq(jiffies, time_limit))) { sd-&gt;time_squeeze++; break; } } local_irq_disable(); list_splice_tail_init(&amp;sd-&gt;poll_list, &amp;list); // 连接两个列表，并重新初始化空列表 list_splice_tail(&amp;repoll, &amp;list); // 连接两个列表，每个列表是一个队列 list_splice(&amp;list, &amp;sd-&gt;poll_list); if (!list_empty(&amp;sd-&gt;poll_list)) __raise_softirq_irqoff(NET_RX_SOFTIRQ); net_rps_action_and_irq_enable(sd); out: __kfree_skb_flush(); }]]></summary></entry><entry><title type="html">Raft 实现</title><link href="http://localhost:4000/Benjamin.github.io/other/2021/11/29/raft.html" rel="alternate" type="text/html" title="Raft 实现" /><published>2021-11-29T19:11:43+08:00</published><updated>2021-11-29T19:11:43+08:00</updated><id>http://localhost:4000/Benjamin.github.io/other/2021/11/29/raft</id><content type="html" xml:base="http://localhost:4000/Benjamin.github.io/other/2021/11/29/raft.html"><![CDATA[<p>Raft 实现的三个核心模块</p>
<ol>
  <li>通信</li>
  <li>共识算法</li>
  <li>持久化存储</li>
</ol>

<p>持久化存储可以暂时方式。满足一般通信即可，主要还是一致性算法。
一致性算法涉及到数据结构的定义。</p>

<h1 id="介绍">介绍</h1>

<p>这个课程包括一系列实验，目标是开发一个容错的KV系统，本实验是其中的第一个。在这个实验里，要求你实现Raft，它是一个复制状态机。在后续的实验中，会要求你在这个Raft的基础上开发一个KV服务。这个服务会把请求打散（Shard）到多个复制状态机上去处理，以提高性能。</p>

<p>复制服务能做到容错的方法是：把多份完整拷贝存放到多个副本服务器上。复制使得这个KV服务在多个服务器故障的情况下（崩溃了、坏了或者网络掉线了）也能正常工作。难点在于，故障可能导致不同服务器上存储的数据副本也是不同的。</p>

<p>Raft把客户端的请求组织成一个序列，叫做日志，并且确保所有副本服务器看到的日志都是相同的。每个副本服务器都按顺序执行这些客户端请求，并且把这些请求应用到自己的服务状态机的本地副本上。因为所有的活着的服务器都有相同的日志内容，并且它们以相同的顺序运行相同的日志，所以他们的状态也就是相同的。如果一个节点故障了，然后又恢复了，Raft负责把它的日志重新带到最新的状态。只要集群里面多数（超过半数）节点正常工作，并且相互之间能够正常通信，那么Raft就可以正常工作。一旦多数节点都不能正常工作了，那么Raft也就停止工作了，只要集群多数节点又恢复正常了，Raft就能立即从上次它停止的状态中恢复过来。</p>

<p>在这个实验中，要求你把Raft实现成一个go的Object类型，并且带有关联的方法，也就是说，这个raft可以作为一个模块用在另外一个更大的服务中。一个Raft实例用RPC相互通信来共同维护日志。你的raft接口应该支持未确定的待编号命令序列，也就是所说的日志条目。这些条目都用index number进行编号。带有特定index的条目最终都会被提交。在这个时刻，你实现的raft服务应该把这个日志条目发送给更大的服务去执行。</p>

<p>你应该按照raft论文（<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">raft-extended.pdf</a>）里面描述的设计去实现，特别是要注意论文中的图2，包括：持久化保存状态、节点故障重启之后读入这些状态。你不需要实现集群成员变更（Section6里面内容）。</p>

<p>这个指导书（<a href="https://thesquareplanet.com/blog/students-guide-to-raft/">students-guide-to-raft/</a>）里面的内容可能对你有用，也包括这些关于锁（<a href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt">raft-locking.txt</a>）和<a href="https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt">并发结构</a> 的建议。从拓宽知识面的角度说，浏览一下Paxos，Chubby，PaxosMade Live，Spanner，Zookeeper，Harp，Viewstamped Replication，以及Bolosky et al (<a href="http://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf">Bolosky.pdf</a>都是有好处的。（注意：这个学生指导书是很多年之前写的了，其中2D部分现在已经有些变化了，你自己要思考为这些特殊的实现策略的意义是什么，不要盲从）。</p>

<p>一个raft模块和其他部分的交互图（https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf），可以帮助你理解raft模块与其他部分是如何交互的。</p>

<h1 id="开始">开始</h1>
<p>如果你完成了实验1，那么你应该有一份实验的源码了。如果你没完成，那么你可以用这里面的命令（<a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">lab-mr.html</a>）去下载这些代码。</p>

<p>我们给你提供了一些代码框架（src/raft/raft.go）。我们也提供一个测试集，你应该用它驱动你自己实现raft。我们也会用这个测试集给你的实验作业打分。测试代码在/src/raft/test_test.go里面。</p>

<p>用下面命令开始运行。不要忘了用get pull下载最新的软件。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cd</span> <span class="err">~</span><span class="o">/</span><span class="m">6.824</span>
<span class="err">$</span> <span class="n">git</span> <span class="n">pull</span>
<span class="o">...</span>
<span class="err">$</span> <span class="n">cd</span> <span class="n">src</span><span class="o">/</span><span class="n">raft</span>
<span class="err">$</span> <span class="k">go</span> <span class="n">test</span> <span class="o">-</span><span class="n">race</span>
<span class="n">Test</span> <span class="p">(</span><span class="m">2</span><span class="n">A</span><span class="p">)</span><span class="o">:</span> <span class="n">initial</span> <span class="n">election</span> <span class="o">...</span>
<span class="o">---</span> <span class="n">FAIL</span><span class="o">:</span> <span class="n">TestInitialElection2A</span> <span class="p">(</span><span class="m">5.04</span><span class="n">s</span><span class="p">)</span>
        <span class="n">config</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">326</span><span class="o">:</span> <span class="n">expected</span> <span class="n">one</span> <span class="n">leader</span><span class="p">,</span> <span class="n">got</span> <span class="n">none</span>
<span class="n">Test</span> <span class="p">(</span><span class="m">2</span><span class="n">A</span><span class="p">)</span><span class="o">:</span> <span class="n">election</span> <span class="n">after</span> <span class="n">network</span> <span class="n">failure</span> <span class="o">...</span>
<span class="o">---</span> <span class="n">FAIL</span><span class="o">:</span> <span class="n">TestReElection2A</span> <span class="p">(</span><span class="m">5.03</span><span class="n">s</span><span class="p">)</span>
        <span class="n">config</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">326</span><span class="o">:</span> <span class="n">expected</span> <span class="n">one</span> <span class="n">leader</span><span class="p">,</span> <span class="n">got</span> <span class="n">none</span>
<span class="o">...</span>
<span class="err">$</span>
</code></pre></div></div>

<h1 id="代码">代码</h1>
<p>你实现的raft代码添加到raft/raft.go里面。在这个文件里面，有一些框架代码，以及一些给你展示如何发送和接收RPC的例子代码。</p>

<p>你的实现必须支持下面这些接口，测试代码和以后你要实现的kev/value服务都会用到这些接口。在raft.go里面还有很多有用的注释，就像下面这样。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// create a new Raft server instance:</span>
<span class="n">rf</span> <span class="o">:=</span> <span class="n">Make</span><span class="p">(</span><span class="n">peers</span><span class="p">,</span> <span class="n">me</span><span class="p">,</span> <span class="n">persister</span><span class="p">,</span> <span class="n">applyCh</span><span class="p">)</span>

<span class="c">// start agreement on a new log entry:</span>
<span class="n">rf</span><span class="o">.</span><span class="n">Start</span><span class="p">(</span><span class="n">command</span> <span class="k">interface</span><span class="p">{})</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">isleader</span><span class="p">)</span>

<span class="c">// ask a Raft for its current term, and whether it thinks it is leader</span>
<span class="n">rf</span><span class="o">.</span><span class="n">GetState</span><span class="p">()</span> <span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">isLeader</span><span class="p">)</span>

<span class="c">// each time a new entry is committed to the log, each Raft peer</span>
<span class="c">// should send an ApplyMsg to the service (or tester).</span>
<span class="k">type</span> <span class="n">ApplyMsg</span>
</code></pre></div></div>

<p>服务调用Make(peers, me, …)来产生一个Raft peer。这个参数peers就是一些Raft peers的网络标识符，RPC用这些标识符。这个参数me是本peer在这个peers数组中的index。Start(command)请求Raft开始一个把命令追加到replicated log中的处理流程。Start()应该立刻返回，不能等到日志追加完毕才返回。服务希望你代码在日志条目提交的时候，给applyCh发送ApplyMsg，每个新提交的日志条目都要发，applyCh是在调用Make()函数时传入的一个参数。</p>

<p>Raft.go有发送RPC的例子代码（sendRequestVote()），以及处理收到的RPC的例子代码（RequestVote()）。你的Raft peers应该用Go语言包labrpc来收发RPC消息。测试代码会控制librpc来对RPC消息人为地制造时延、乱序、丢包等问题来模拟网络故障。你也可以临时修改labrpc，但是你要保证你的代码能够跟原始的labrpc一起正常工作，因为我们要用这个给你的作业打分。你的raft实例之间只能用RPC进行交互，比如，不允许他们之间用共享变量或者文件来交互。</p>

<p>这个课程后面的这些实验都是在这个实验基础上开展的，所以，多花点时间，把代码写的健壮一点，是很重要的。</p>

<h1 id="实验2a领导选举">实验2A：领导选举</h1>

<p><strong><em>任务：实现 Raft 的领导选举和心跳（不带日志条目的 AppendEntries RPC 消息）。实验 2 A 的目标是：如果没有故障，那么领导就一直</em></strong>
<strong><em>是领导。如果发送故障，那么新领导就要接管（集群），这里说的故障，可能是老领导死机或者丢包导致联系不上。运行 <code class="language-plaintext highlighter-rouge">go test -run 2a -race</code></em></strong>
<strong><em>来测试你的 2A 代码</em></strong></p>

<ul>
  <li>
    <p>提示：没办法很容易地直接运行Raft实现，你应该用测试框架去运行：go test -run 2A -race。</p>
  </li>
  <li>
    <p>提示：仔细读Raft论文上的图2。现在这个时间点，你需要关心发送和接收RequestVote RPC消息，跟选举相关的一些服务器规则，以及跟选举相关的领导者规则。</p>
  </li>
  <li>
    <p>提示：把图2中的一些领导者选举状态添加到raft.go文件的Raft结构中。另外，还需要定义一个结构去保存每个日志条目的信息。</p>
  </li>
  <li>
    <p>提示：填充RequestVoteArgs和RequestVoteReply这两个结构。修改Make()这个函数，创建一个后台goroutine，如果长时间没有收到其他peer的消息，这个goroutine就会发送RequestVote RPCs消息，周期性的启动leader选举。如果已经存在一个领导者，或者它自己成了领导者，通过这种方法(周期性发送消息)，让peer知道谁是领导者。实现RequestVote()这个RPC处理函数，这样服务器节点之间就会相互投票。</p>
  </li>
  <li>
    <p>提示：实现心跳，定义AppendEntries的RPC结构（尽管现在可能还不需要所有参数），并且让Leader周期性的发送这个AppendEntries RPC消息。写AppendEntries RPC消息的处理函数，在这个函数中，对选举超时变量进行清零，这样一旦选出一个领导者之后，其他节点就不会再继续尝试成为领导者了。</p>
  </li>
  <li>
    <p>提示：确保不同的peers的超时时间不一样，要不然所有peer都会投票给他们自己，这样就选不出来领导者了。</p>
  </li>
  <li>
    <p>提示：测试框架要求领导者发送心跳RPC消息的频率不超过10次/秒。</p>
  </li>
  <li>
    <p>提示：测试框架要求你的Raft实现应该在老领导者故障后的5秒钟之内选出新领导者（假设多数peers之间可以相互通信）。注意，选举可能会有多轮，因为可能会有多个候选人平分选票的情况（可能是报文丢失导致的，也可能是两个候选人使用了相同的回退时间）。你必须定一个足够短的选举的超时时间（以及heartbeat的间隔），尽量在5秒钟之内能够完成选举，即便经历多轮选举也应该能完成。</p>
  </li>
  <li>
    <p>提示：在Raft论文的5.2节提到，选举超时时间在150ms到300ms之间，这个超时值只在领导者发送心跳的间隔远远小于150ms的情况下才有意义。因为测试框架把心跳频率现在小于10次/1秒，这样你就必须把选举间隔设置为大于论文中给出的150到300ms，但是也不能太长，否则5秒钟之内无法完成选举。</p>
  </li>
  <li>
    <p>提示：你需要用go语言的rand函数（https://golang.org/pkg/math/rand/）。</p>
  </li>
  <li>
    <p>提示：当你要写一个周期性的处理函数，或者需要延时一段时间再处理，那么最方便的实现方法就是创建一个goroutine，里面一个大循环，循环里面调用time.Sleep()。（参见Make()里面创建的ticker() goroutine就是这个目的）。不要用Go的time.Timer或者time.Ticker，想把这俩货用对很难。</p>
  </li>
  <li>
    <p>提示：指导书（https://pdos.csail.mit.edu/6.824/labs/guidance.html）里面有一些怎么开发，怎么调试代码的建议。</p>
  </li>
  <li>
    <p>提示：如果你的代码无法通过测试，那么建议你再回头仔细看论文里面的图2。整个领导者选举的逻辑散落在这个图里面的各个角落。（需要仔细看）</p>
  </li>
  <li>
    <p>提示：别忘了实现GetState()这个函数。</p>
  </li>
  <li>
    <p>提示：测试框架要永久终止某个raft实例的时候，会调用rf.Kill()这个函数。你调用rf.killed()来检查Kill（）是否已经被调用了。你应该在所有的循环中都调用rf.killed()来检查，避免那些已经死掉的raft实例还继续输出迷惑性的打印信息。</p>
  </li>
  <li>
    <p>提示：Go的RPC只能发送struct中名字是大写字母的字段，嵌套结构的字段名字也必须是大写的（主要数组中的logrecord）。Labgob包会提示你这一点，不要忽略这些警告信息。</p>
  </li>
</ul>

<p>交实验2A的作业之前，确保通过了2A的测试用例，就像下面这样：</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="k">go</span> <span class="n">test</span> <span class="o">-</span><span class="n">run</span> <span class="m">2</span><span class="n">A</span> <span class="o">-</span><span class="n">race</span>
<span class="n">Test</span> <span class="p">(</span><span class="m">2</span><span class="n">A</span><span class="p">)</span><span class="o">:</span> <span class="n">initial</span> <span class="n">election</span> <span class="o">...</span>
  <span class="o">...</span> <span class="n">Passed</span> <span class="o">--</span>   <span class="m">4.0</span>  <span class="m">3</span>   <span class="m">32</span>    <span class="m">9170</span>    <span class="m">0</span>
<span class="n">Test</span> <span class="p">(</span><span class="m">2</span><span class="n">A</span><span class="p">)</span><span class="o">:</span> <span class="n">election</span> <span class="n">after</span> <span class="n">network</span> <span class="n">failure</span> <span class="o">...</span>
  <span class="o">...</span> <span class="n">Passed</span> <span class="o">--</span>   <span class="m">6.1</span>  <span class="m">3</span>   <span class="m">70</span>   <span class="m">13895</span>    <span class="m">0</span>
<span class="n">PASS</span>
<span class="n">ok</span>      <span class="n">raft</span>    <span class="m">10.187</span><span class="n">s</span>
<span class="err">$</span>
</code></pre></div></div>

<p>每个”Passed”行都有五个数字，它们是：这个测试用了多少秒，有多少个Raft peers（一般是3个或者5个），这次测试发送了多少个RPC消息，这些RPC消息的总字节数是多少，Raft报告了多少个日志条目被提交了。你的代码实际运行时的数字可能跟上图不一样。你也可以不管这些数字，尽管这些数字可能对排错有用。尽量把每个单独的测试都控制在120秒之内，因为所有实验2、3、4加起来时间不能超过120秒，超时不给分</p>

<h1 id="论文概述">论文概述</h1>

<ul>
  <li>server 会处在三种状态中的一种：leader、follower 和 candidate</li>
  <li>集群中的参与者是被动的</li>
  <li><del>Raft 将时间分为任意长度的间隔，每个间隔是一个任期</del></li>
  <li>每个任期会由一个连续的整数进行表示，在这个阶段会有一个或者多个候选者参与竞选，</li>
  <li>每个任期只会选举出至多一个 leader</li>
  <li>每个 server 都用一个变量存储了当前任期,并且这个变量随着时间是单调递增的</li>
  <li>当 servers 进行通讯的时候，也会交换当前的任期（心跳）</li>
  <li>如果一个 server 存储的任期小于其他机器存储的任期，那么它将更新自己的任期为其它机器传送的最大任期（心跳）</li>
  <li>如果一个 server 接受到一个请求，这个请求中的任期是过时的，它将直接拒绝该请求（小于任期，问题：没有说是谁发送的心跳）</li>
  <li>RequestVote RPCs 是候选在这选举过程中使用的</li>
  <li>AppendEntries RPCs 是 leader 进行日志复制和心跳时使用的</li>
</ul>

<ol>
  <li>Raft 使用心跳机制来触发选主的过程</li>
  <li>leader 会发送心跳到其它的 server 来授权延长自己的任期。（发送心跳的过程中，发现server 返回更大的任期，自动跟随？）</li>
  <li>选举定时器超时的时候还没有收到任何请求，它可以假设整个集群没有可用的leader 或者候选者，然后发起新的选举
  （投票后，等待下一个超时。超时后还是没有心跳更新，就发起投票）</li>
  <li>候选者先选举自己，并行的给集群中的其它机器发送 RequestVote RPCs。（只需要过半以上的票就可以了，自己默认+1）</li>
  <li>一个候选者如果接收到集群中大多数机器在同一个任期的选票，它将胜出成为 leader
  （先到先得，先到之后直接将当前任期修改为候选任期，后续除非大于当前任期，否则都是反对票，候选人根据投票结果自己判断，然后等待一个心跳周期）</li>
  <li>每台机器在一个任期只能投票给一个候选者（先到先得，先到之后直接将当前任期修改为候选任期，后续除非大于当前任期，否则都是反对票）</li>
  <li>一旦一个候选者胜出将成为集群的 leader，它将会并行的给集群的其它机器发送心跳来宣示自己胜出，并阻止进行新的选举
  （这里是并行，看似困难，其实简单需要归纳法证明，如何阻止）</li>
  <li></li>
</ol>

<blockquote>
  <p>一个候选者可能接受到来自其它 server 的请求，该请求声明自己已经成为 leader。</p>
</blockquote>

<ol>
  <li>如果请求中的 leader 的任期大于候选者本地存储的任期，那么当前候选者认为这个 leader 是合法的并转变为参与者状态。
（这里是并行，需要证明，看似简单其实困难需要证明）</li>
  <li>如果请求中 leader 的任期小于当前候选者本地存储的任期，那么候选将拒绝这个请求并保持在候选者状态。
  （这里是并行，需要证明，看似简单其实困难）</li>
  <li>整个集群的所有候选者都没有胜出,等待候选者的选举定时器超时，增加自己本地存储的任期并启动新一轮的选举</li>
  <li></li>
</ol>

<p><strong><em>注：来源消息看做完全信任，即永远不会被破坏、出现间谍情况，只会出现乱序、重复、超时、失败的情况</em></strong></p>

<p>方法实现流程：</p>

<h1 id="server-处理心跳">server 处理心跳</h1>
<p>接收 未知来源（默认是 ） 携带 <code class="language-plaintext highlighter-rouge">Term</code>、<code class="language-plaintext highlighter-rouge">LeaderId</code> 数据发送的心跳，处理流程如下</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">来源.Term</code> 大于等于当前 <code class="language-plaintext highlighter-rouge">server</code> 保存的 <code class="language-plaintext highlighter-rouge">leader.currentTerm</code></li>
  <li>表示接收到心跳</li>
  <li>修改 当前 <code class="language-plaintext highlighter-rouge">server</code> 保存的 <code class="language-plaintext highlighter-rouge">leader.currentTerm</code> 为 <code class="language-plaintext highlighter-rouge">来源.Term</code></li>
  <li>修改 当前 <code class="language-plaintext highlighter-rouge">server</code> 保存的 <code class="language-plaintext highlighter-rouge">leader.LeaderId</code> 为 <code class="language-plaintext highlighter-rouge">来源.LeaderId</code></li>
  <li>更新最新收到的心跳时间为 <code class="language-plaintext highlighter-rouge">NOW</code>
  解释：
    <ul>
      <li>当前 Server 如果是 Follow
        <ul>
          <li><code class="language-plaintext highlighter-rouge">leader.Term</code> 小于 <code class="language-plaintext highlighter-rouge">来源.Term</code> ，自动跟随 <code class="language-plaintext highlighter-rouge">Term</code> 最新的 <code class="language-plaintext highlighter-rouge">Leader</code>。不会关心上次心跳的信息包括 <code class="language-plaintext highlighter-rouge">LeaderId</code>、<code class="language-plaintext highlighter-rouge">Term</code>，永远追随最新的 <code class="language-plaintext highlighter-rouge">Leader</code></li>
          <li><code class="language-plaintext highlighter-rouge">leader.Term</code> 等于 <code class="language-plaintext highlighter-rouge">来源.Term</code></li>
        </ul>
      </li>
    </ul>
    <ul>
      <li>情况一：当前 <code class="language-plaintext highlighter-rouge">Leader</code> 已经持续一段时间，属于正常情况</li>
      <li>情况二：当前  <code class="language-plaintext highlighter-rouge">来源.Term</code> 为未胜出的 <code class="language-plaintext highlighter-rouge">候选人</code>，根据归纳法证明：只有 <code class="language-plaintext highlighter-rouge">候选人</code> 在胜出的情况下才可以发送心跳，基于完全相互信任的法则
        <ul>
          <li><code class="language-plaintext highlighter-rouge">leader.Term</code> 大于 <code class="language-plaintext highlighter-rouge">来源.Term</code>，自动拒绝
     - 当前 <code class="language-plaintext highlighter-rouge">Server</code> 如果是 <code class="language-plaintext highlighter-rouge">候选人</code></li>
          <li><code class="language-plaintext highlighter-rouge">候选人</code> 与上面的情况一致，候选人处了身份特殊以外并无特殊情况</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h1 id="server-处理拉票">server 处理拉票</h1>

<p>接收 未知来源（默认是 ） 携带 <code class="language-plaintext highlighter-rouge">Term</code>、<code class="language-plaintext highlighter-rouge">LeaderId</code> 数据发送的心跳，处理流程如下</p>

<p><strong>选举超时是为了负载均衡？？？？经验证翻译的并准确，英文原版将心跳拦截他们选举超时，表达的意思就是心跳检测时间就是选举超时时间</strong></p>

<p><strong><em>此选举任期将持续到追随者停止接收心跳并成为候选人为止。</em></strong> 好像和之前理解的不一样
<strong><em>下次心跳都要重新设置随机，下次选举超时也是</em></strong></p>]]></content><author><name>Jony</name></author><category term="Other" /><category term="http" /><category term="glang" /><summary type="html"><![CDATA[Raft 实现的三个核心模块 通信 共识算法 持久化存储]]></summary></entry><entry><title type="html">Kubernetes - ISTIO2</title><link href="http://localhost:4000/Benjamin.github.io/grpc/2021/11/18/istio2.html" rel="alternate" type="text/html" title="Kubernetes - ISTIO2" /><published>2021-11-18T00:49:53+08:00</published><updated>2021-11-18T00:49:53+08:00</updated><id>http://localhost:4000/Benjamin.github.io/grpc/2021/11/18/istio2</id><content type="html" xml:base="http://localhost:4000/Benjamin.github.io/grpc/2021/11/18/istio2.html"><![CDATA[<h1 id="梅开二度">梅开二度</h1>

<p><strong><em>主要搞清上下文边界</em></strong></p>

<p>Pilot 的代码主要分为两部分:</p>
<ul>
  <li>pilot-agent 负责数据面 Sidecar 实例的生命周期管理</li>
  <li>pilot-discovery 负责控制面流量管理配置及路由规则的生成和下发</li>
</ul>

<p>pilot-discovery 的主服务，包含了三个比较重要的组件：</p>
<ul>
  <li>Config Controller： 管理配置信息，比如路由规则、流量权重控制、故障注入。主在下发各种动作</li>
  <li>Service Controller：管理各种服务及其服务下具体实例，比如：k8s 的 Service 和 Pod，来
自其他注册中心的服务和实例信息</li>
  <li>XdsServer：将上述信息下发至各个实例，被动发送和主动发送。因为开源热衷于各种标准化，所以有了 xDS</li>
</ul>

<p>基础概念：</p>

<p><code class="language-plaintext highlighter-rouge">C端</code>：调用方
<code class="language-plaintext highlighter-rouge">S端</code>：服务方
<code class="language-plaintext highlighter-rouge">G端</code>：中间件，可以理解为 <code class="language-plaintext highlighter-rouge">Nginx</code></p>

<p><code class="language-plaintext highlighter-rouge">VirtualService</code>: 定义了对特定目标服务的一组规则，一种抽象出来的虚拟服务，可以理解为 <code class="language-plaintext highlighter-rouge">G</code> 端
<code class="language-plaintext highlighter-rouge">DestinationRule</code>: 定义了对特定目标服务的细分规则，负载均衡策略、连接池大小、异常实例驱逐规则划分不同的子集</p>

<p><code class="language-plaintext highlighter-rouge">VirtualService</code> 定义了服务请求满足什么条件应该转发到哪里，而<code class="language-plaintext highlighter-rouge">DestinationRule</code>则定义了这些请求
具体的路由规则,比如请求目标服务的什么版本, 负载均衡策略，连接限制等.
<code class="language-plaintext highlighter-rouge">VirtualService</code> 像是代替做了服务发现的操作，只做服务发现和发起调用， <code class="language-plaintext highlighter-rouge">DestinationRule</code> 来控制调用流量
的具体指向，调和断路器、限流器、分流器等中间件。</p>

<p><strong>Example:</strong></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualService</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">service-b</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">hosts</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">service-b</span>  <span class="c1">#客户端访问服务的地址，扩展为 service-b.default.svc.cluster.local</span>
  <span class="na">http</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">route</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">destination</span><span class="pi">:</span>         <span class="c1"># 目标服务，这里不一定是service-b服务，也就是说, 虽然客户端访问service-b，但不一定就需要转到service-b，转发到其它服务也是支持的.</span>
        <span class="na">host</span><span class="pi">:</span> <span class="s">service-b</span>      <span class="c1">#扩展为 service-b.default.svc.cluster.local</span>
        <span class="na">subset</span><span class="pi">:</span> <span class="s">v1</span>           <span class="c1">#subset 会在destinationRule中使用</span>
<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">DestinationRule</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">service-b</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">service-b</span>  <span class="c1">#这里的名字需要跟virtualservice中定义的一致</span>
  <span class="na">trafficPolicy</span><span class="pi">:</span>
    <span class="na">loadBalancer</span><span class="pi">:</span>
      <span class="na">simple</span><span class="pi">:</span> <span class="s">RANDOM</span>
  <span class="na">subsets</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">v1</span> <span class="c1">#这里的名字需要跟virtualservice中定义的一致</span>
    <span class="na">labels</span><span class="pi">:</span>
      <span class="na">version</span><span class="pi">:</span> <span class="s">v1</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">v2</span>
    <span class="na">labels</span><span class="pi">:</span>
      <span class="na">version</span><span class="pi">:</span> <span class="s">v2</span>        
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ServiceEntry</code>: 可以看作是一个网格外部的 <code class="language-plaintext highlighter-rouge">VirtualService</code>。
描述服务的属性: DNS 名称、VIP、端口、协议以及端点</p>

<p><strong>EXAMPLE</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ServiceEntry</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">svc-entry</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">hosts</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">ext-svc.example.com</span>   <span class="c1">#外部服务，与匹配的VirtualServices和DestinationRules中的hosts字段相同。将https://ext-svc.example.com:443认为是外部服务</span>
  <span class="na">ports</span><span class="pi">:</span>                  <span class="c1">#外部服务对应的端口</span>
  <span class="pi">-</span> <span class="na">number</span><span class="pi">:</span> <span class="m">443</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">https</span>
    <span class="na">protocol</span><span class="pi">:</span> <span class="s">HTTPS</span>
  <span class="na">location</span><span class="pi">:</span> <span class="s">MESH_EXTERNAL</span> <span class="c1">#flag，表示该服务是网格外的服务</span>
  <span class="na">resolution</span><span class="pi">:</span> <span class="s">DNS</span>         <span class="c1">#主机服务的发现模型</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">WorkloadEntry</code>: 可以看做是一个网格外部的 <code class="language-plaintext highlighter-rouge">Pod</code> 实例。网格外部服务使用 <code class="language-plaintext highlighter-rouge">ServiceEntry</code> 已经可以提供服务
了，为什么还需要 <code class="language-plaintext highlighter-rouge">WorkloadEntry</code>。因为 <code class="language-plaintext highlighter-rouge">ServiceEntry</code> 只能是作为 <code class="language-plaintext highlighter-rouge">Service</code> 的存在，无法对后端服务的抽象
就像 <code class="language-plaintext highlighter-rouge">Pod</code> 的属性集：名称、标签、安全属性、生命周期状态事件等，这些可以通过 <code class="language-plaintext highlighter-rouge">WorkloadEntry</code> 来描述。</p>

<p>官方解释：服务迁移</p>

<p><strong>EXAMPLE</strong></p>

<p>设想 <code class="language-plaintext highlighter-rouge">ServiceEntry</code> 下有几十个实例在提供服务：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ServiceEntry</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">svc1</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">hosts</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">svc1.internal.com</span>
  <span class="na">ports</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">number</span><span class="pi">:</span> <span class="m">80</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">http</span>
    <span class="na">protocol</span><span class="pi">:</span> <span class="s">HTTP</span>
  <span class="na">resolution</span><span class="pi">:</span> <span class="s">STATIC</span>
  <span class="na">endpoints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">address</span><span class="pi">:</span> <span class="s">1.1.1.1</span>
  <span class="pi">-</span> <span class="na">address</span><span class="pi">:</span> <span class="s">2.2.2.2</span>
  <span class="s">...</span>
</code></pre></div></div>

<p>这种方式的问题:</p>

<ul>
  <li>当工作负载非常多的情况下，<code class="language-plaintext highlighter-rouge">ServiceEntry</code>变得很大，更新极易出错，同时很大的资源对象更新必将带来额外的开销。</li>
  <li>同时，不支持一个服务的容器和虚拟机混合部署。比如说有个服务同时部署在<code class="language-plaintext highlighter-rouge">Kubernetes</code>集群以及虚拟机上，集群内的
服务由<code class="language-plaintext highlighter-rouge">K8s Service</code>、<code class="language-plaintext highlighter-rouge">Pod</code>表示，虚拟机上的只能通过<code class="language-plaintext highlighter-rouge">ServiceEntry</code>表示，这种部署模型在老版本中很难无缝集成。</li>
</ul>

<p>如果您想以主动的方式将此服务迁移到<code class="language-plaintext highlighter-rouge">Kubernetes</code>，即启动一组<code class="language-plaintext highlighter-rouge">POD</code>，通过 <code class="language-plaintext highlighter-rouge">Istio mTLS</code> 将一部分流量
发送到POD，并将其余流量发送到没有 <code class="language-plaintext highlighter-rouge">Sidecar</code> 的<code class="language-plaintext highlighter-rouge">VMs</code>，您将如何做？
您可能需要使用<code class="language-plaintext highlighter-rouge">Kubernetes Service</code>、<code class="language-plaintext highlighter-rouge">VirtualService</code> 和 <code class="language-plaintext highlighter-rouge">DestinationRule</code> 的组合来实现该行为。
现在，假设您决定将 <code class="language-plaintext highlighter-rouge">Sidecar</code> 一个接一个地添加到这些 <code class="language-plaintext highlighter-rouge">VM</code> 中，这样您只希望带 <code class="language-plaintext highlighter-rouge">Sidecar</code> 的 <code class="language-plaintext highlighter-rouge">VM</code> 的流
量使用<code class="language-plaintext highlighter-rouge">Istio mTLS</code>。如果任何其他<code class="language-plaintext highlighter-rouge">ServiceEntry</code>恰好在其 <code class="language-plaintext highlighter-rouge">endpoints</code> 中包含<strong>相同的 <code class="language-plaintext highlighter-rouge">VM</code> 地址</strong> ，事
情就会变得非常复杂和容易出错。</p>

<p>上面说的仍然是第一个点，维护比较困难。在多个 <code class="language-plaintext highlighter-rouge">ServiceEntry</code> 包含相同的 <code class="language-plaintext highlighter-rouge">IP</code> 那么当 <code class="language-plaintext highlighter-rouge">IP</code> 发生更新是就需要
更新所有的 <code class="language-plaintext highlighter-rouge">ServiceEntry</code> ，而且不能漏掉，否则会发生故障。</p>

<p>这些复杂性的主要来源是<code class="language-plaintext highlighter-rouge">Istio</code>缺乏非容器化一级工作负载的定义，这些定义可以独立于其所属的服务进行描述的属性。</p>

<p>这种部署模型在老版本中很难无缝集成，<strong><code class="language-plaintext highlighter-rouge">问题点</code>来自于网格内使用 <code class="language-plaintext highlighter-rouge">Sidecar</code> 相互调用,网格外没有 <code class="language-plaintext highlighter-rouge">Sidecar</code> 。
<code class="language-plaintext highlighter-rouge">VirtualService</code> 如果包含相同的 <code class="language-plaintext highlighter-rouge">VM</code> 那么可能会导致调用方误认为服务方也存在 <code class="language-plaintext highlighter-rouge">Sidecar</code> 而发起 <code class="language-plaintext highlighter-rouge">Istio mTLS</code> 
调用，导致不可预知的错误。</strong></p>

<p><code class="language-plaintext highlighter-rouge">WorkloadEntry</code>的出现，完全解决了上述问题，虚拟机、裸机工作负载由<code class="language-plaintext highlighter-rouge">WorkloadEntry</code>独立表示，类似<code class="language-plaintext highlighter-rouge">K8s</code>中的<code class="language-plaintext highlighter-rouge">Pod</code>。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">WorkloadEntry</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="c">// 工作负载地址，类似Pod IP.</span>
    <span class="n">Address</span> <span class="kt">string</span>
    <span class="c">// 端口，类似K8s Endpoint端口.</span>
    <span class="n">Ports</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">uint32</span>
    <span class="c">// 标签，类似Pod Label.</span>
    <span class="n">Labels</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
    <span class="c">// 网络 ID，主要用于多网络，多集群场景.</span>
    <span class="n">Network</span> <span class="kt">string</span>
    <span class="c">// 工作负载位置拓扑信息，例如us/us-east-1/az-1，可用于基于位置感知的流量分发.</span>
    <span class="n">Locality</span> <span class="kt">string</span>
    <span class="c">// 负载均衡权重信息，值越大，接收到的请求越多.</span>
    <span class="n">Weight</span> <span class="kt">uint32</span>
    <span class="c">// 工作负载身份信息，类似Pod Sa身份</span>
    <span class="n">ServiceAccount</span>       <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">ServiceEntry</code>（类似K8s Service）可以通过标签选择对应的 <code class="language-plaintext highlighter-rouge">WorkloadEntry</code>，避免了用户维护一个超大耦
合的<code class="language-plaintext highlighter-rouge">ServiceEntry</code>，这种解耦的模型用户体验更好。</p>

<p>目前<code class="language-plaintext highlighter-rouge">ServiceEntry</code>可以同时选择<code class="language-plaintext highlighter-rouge">WorkloadEntry</code>和<code class="language-plaintext highlighter-rouge">Pod</code>作为<code class="language-plaintext highlighter-rouge">Endpoint</code>，因此很好地解决了跨虚拟机以及K8s集群部署
服务的管理难题。<strong>Example</strong></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">WorkloadEntry</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">details-svc</span> <span class="c1"># 名称</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">address</span><span class="pi">:</span> <span class="s">2.2.2.2</span> <span class="c1"># 裸机或者虚拟机地址</span>
  <span class="na">labels</span><span class="pi">:</span> <span class="c1"># 当前的 Lable，可以供 ServiceEntry selector</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">details-legacy</span> 
    <span class="na">instance-id</span><span class="pi">:</span> <span class="s">vm1</span> 
<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ServiceEntry</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">details-svc</span> <span class="c1"># 名称</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">hosts</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">details.bookinfo.com</span> <span class="c1"># 目标 hosts</span>
  <span class="na">location</span><span class="pi">:</span> <span class="s">MESH_INTERNAL</span>
  <span class="na">ports</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">number</span><span class="pi">:</span> <span class="m">80</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">http</span>
    <span class="na">protocol</span><span class="pi">:</span> <span class="s">HTTP</span>
    <span class="na">targetPort</span><span class="pi">:</span> <span class="m">8080</span>
  <span class="na">resolution</span><span class="pi">:</span> <span class="s">STATIC</span>
  <span class="na">workloadSelector</span><span class="pi">:</span>  <span class="c1"># workload 选择器</span>
    <span class="na">labels</span><span class="pi">:</span>  <span class="c1"># 选择包含这些条件的 Pod 和 WorkloadEntry</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">details-legacy</span>    
</code></pre></div></div>

<p>了解了 <code class="language-plaintext highlighter-rouge">VirtualService</code>、<code class="language-plaintext highlighter-rouge">DestinationRule</code>、<code class="language-plaintext highlighter-rouge">ServiceEntry</code>、<code class="language-plaintext highlighter-rouge">WorkloadEntry</code> 的职责边界之后
对 <code class="language-plaintext highlighter-rouge">Controller</code> 上下文理解应该更加清晰。</p>

<p><code class="language-plaintext highlighter-rouge">pilot-discovery</code> 三个比较重要的组件：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Config Controller</code>：从不同来源接收流量控制和路由规则等 <code class="language-plaintext highlighter-rouge">Istio</code> 的配置，并响应各类事件</li>
  <li><code class="language-plaintext highlighter-rouge">Service Controller</code>：从不同注册中心同步服务及实例，并响应各类事件</li>
  <li><code class="language-plaintext highlighter-rouge">XdsServer</code>：核心的 xDS 协议推送服务，根据上面组件的数据生成 xDS 协议并下发</li>
</ul>]]></content><author><name>Jony</name></author><category term="gRPC" /><category term="microservices" /><category term="Kubernetes" /><category term="k8s" /><summary type="html"><![CDATA[梅开二度]]></summary></entry><entry><title type="html">Kubernetes - ISTIO2</title><link href="http://localhost:4000/Benjamin.github.io/grpc/2021/11/18/istio3.html" rel="alternate" type="text/html" title="Kubernetes - ISTIO2" /><published>2021-11-18T00:49:53+08:00</published><updated>2021-11-18T00:49:53+08:00</updated><id>http://localhost:4000/Benjamin.github.io/grpc/2021/11/18/istio3</id><content type="html" xml:base="http://localhost:4000/Benjamin.github.io/grpc/2021/11/18/istio3.html"><![CDATA[<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Usage:
  pilot-discovery discovery <span class="o">[</span>flags]

Flags:
      <span class="nt">--caCertFile</span> string                          包含 x509 服务器 CA 证书的文件
      <span class="nt">--clusterAliases</span> stringToString              集群的别名（默认 <span class="o">[]</span>）
      <span class="nt">--clusterID</span> string                           该Istiod实例所在集群的ID（默认为 <span class="s2">"Kubernetes"</span>）
      <span class="nt">--clusterRegistriesNamespace</span> string          用于存储集群配置的ConfigMap的命名空间（默认为 <span class="s2">"istio-system"</span>）
      <span class="nt">--configDir</span> string                           观察配置yaml文件更新的目录。如果指定，这些文件将被用作配置的来源，而不是CRD客户端。
      <span class="nt">--ctrlz_address</span> string                       要侦听的ControlZ自检工具的IP地址。使用‘<span class="k">*</span>’表示所有地址。<span class="o">(</span>默认为“localhost”<span class="o">)</span>
      <span class="nt">--ctrlz_port</span> uint16                          用于ControlZ自检设施的IP端口<span class="o">(</span>默认值为9876<span class="o">)</span>
      <span class="nt">--domain</span> string                              DNS 域后缀（默认为“cluster.local”）
      <span class="nt">--grpcAddr</span> string                            发现服务 gRPC 地址（默认“:15010”）
  <span class="nt">-h</span>, <span class="nt">--help</span>                                       discovery 帮助信息
      <span class="nt">--httpAddr</span> string                            服务发现HTTP地址<span class="o">(</span>默认值“：8080”<span class="o">)</span>
      <span class="nt">--httpsAddr</span> string                           注入和验证服务HTTPS地址<span class="o">(</span>默认为“：15017”<span class="o">)</span>
      <span class="nt">--keepaliveInterval</span> duration                 时间间隔<span class="o">(</span>如果连接上没有任何活动<span class="o">)</span>，它会ping对等方以查看传输是否处于活动状态<span class="o">(</span>默认值为30秒<span class="o">)</span>
      <span class="nt">--keepaliveMaxServerConnectionAge</span> duration   连接在正常关闭之前将在服务器上保持打开的最长持续时间。<span class="o">(</span>默认为2562047h47m16.854775807s<span class="o">)</span>
      <span class="nt">--keepaliveTimeout</span> duration                  在ping了keepalive检查后，客户/服务器等待keepaliveTimeout的时间，如果之后没有看到任何活动，则关闭连接。<span class="o">(</span>默认为10s<span class="o">)</span>
      <span class="nt">--kubeconfig</span> string                          使用Kubernetes配置文件而不是集群内配置
      <span class="nt">--kubernetesApiBurst</span> int                     与kubernetes API通信时节点流量的最大爆发量（默认为160）
      <span class="nt">--kubernetesApiQPS</span> float32                   与kubernetes API通信时的最大QPS（默认80）。
      <span class="c"># --log_as_json                                是将输出格式化为JSON还是使用简单的控制台格式</span>
      <span class="c"># --log_caller string                          逗号分隔的作用域列表，其中包括调用者信息，作用域可以是[ads, adsc, all, analysis, authn, authorization, ca, controllers, default, file, gateway, grpcgen, installer, klog, kube, model, monitor, pkica, processing, proxyconfig, retry, rootcertrotator, secretcontroller, serverca, spiffe, status, telemetry, tpath, trustBundle, util, validation, validationController, validationServer, wasm, wle] 中的任何一个。</span>
      <span class="c"># --log_output_level string                    以逗号分隔的要输出的每个范围的最小日志级别的消息，形式为&lt;scope&gt;:&lt;level&gt;,&lt;scope&gt;:&lt;level&gt;,... 其中范围可以是[ads, adsc, all, analysis, authn, authorization, ca, controllers, default, file, gateway, grpcgen, installer, klog, kube, model, monitor, pkica, processing, proxyconfig, retry, rootcertrotator, secretcontroller, serverca, spiffe, status, telemetry, tpath, trustBundle, util, validation, validationController, validationServer, wasm, wle]，级别可以是[debug, info, warn, error, fatal, none]之一（默认 "default: info"）。</span>
      <span class="c"># --log_rotate string                          可选rotate日志文件的路径</span>
      <span class="c"># --log_rotate_max_age int                     日志文件的最长使用期限(以天为单位)，超过该天数后，该文件将被 rotate(0表示没有限制)(默认值为30)</span>
      <span class="c"># --log_rotate_max_backups int                 删除旧文件之前保留的日志文件备份的最大数量(0表示没有限制)(默认值为1000)</span>
      <span class="c"># --log_rotate_max_size int                    日志文件的最大大小(以MB为单位)，超过此大小，文件将被轮换(默认值为104857600)</span>
      <span class="c"># --log_stacktrace_level string                逗号分隔的最小每个范围的日志级别，在该级别上捕获堆栈痕迹，形式为&lt;scope&gt;:&lt;level&gt;,&lt;scope:level&gt;,... 其中范围可以是[ads, adsc, all, analysis, authn, authorization, ca, controllers, default, file, gateway, grpcgen, installer, klog, kube, model, monitor, pkica, processing, proxyconfig, retry, rootcertrotator, secretcontroller, serverca, spiffe, status, telemetry, tpath, trustBundle, util, validation, validationController, validationServer, wasm, wle]，级别可以是[debug, info, warn, error, fatal, none]之一（默认 "default: none"）。</span>
      <span class="c"># --log_target stringArray                     输出日志的路径集。这可以是任何路径，也可以是特殊值stdout和stderr（默认[stdout]）。</span>
      <span class="nt">--meshConfig</span> string                          Istio网格配置的文件名。如果没有指定，将使用默认的网格。<span class="o">(</span>默认为<span class="s2">"./etc/istio/config/mesh"</span><span class="o">)</span>
      <span class="nt">--monitoringAddr</span> string                      用于 Polit 自我监测信息的HTTP地址（默认为<span class="s2">":15014"</span>）。
  <span class="nt">-n</span>, <span class="nt">--namespace</span> string                           选择一个控制器所在的命名空间。如果没有设置，使用<span class="k">${</span><span class="nv">POD_NAMESPACE</span><span class="k">}</span>环境变量（默认为 <span class="s2">"istio-system"</span>）。
      <span class="nt">--networksConfig</span> string                      Istio网状网络配置的文件名。如果不指定，将使用默认的网状网络。<span class="o">(</span>默认为<span class="s2">"./etc/istio/config/meshNetworks"</span><span class="o">)</span>
      <span class="nt">--plugins</span> strings                            使用逗号分隔的网络插件列表<span class="o">(</span>默认[ext_authz,authn,authz]<span class="o">)</span>
      <span class="nt">--profile</span>                                    通过Web界面启用分析功能 host:port/debug/pprof（默认为true）。
      <span class="nt">--registries</span> strings                         逗号分隔的要读取的平台服务注册表（从<span class="o">{</span>Kubernetes, Mock<span class="o">}</span>中选择一个或多个）（默认[Kubernetes]）。
      <span class="nt">--resync</span> duration                            控制器resync间隔<span class="o">(</span>默认为1m0s<span class="o">)</span>
      <span class="nt">--secureGRPCAddr</span> string                      发现服务安全的gRPC地址（默认为<span class="s2">":15012"</span>）。
      <span class="nt">--shutdownDuration</span> duration                  发现服务器需要优雅地终止的时间（默认为10s）。
      <span class="nt">--tls-cipher-suites</span> strings                  逗号分隔的istiod TLS服务器的密码套件列表。如果省略，将使用默认的Go密码套件。
                                                   首选值: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_GCM_SHA384. 
                                                   不安全的值: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_RC4_128_SHA.
      <span class="nt">--tlsCertFile</span> string                         包含x509服务器证书的文件
      <span class="nt">--tlsKeyFile</span> string                          包含x509私钥匹配的文件 <span class="nt">--tlsCertFile</span>

Global Flags:
      <span class="nt">--vklog</span> Level   日志级别粗略程度的数字。例如： <span class="nt">--vklog</span><span class="o">=</span>9
</code></pre></div></div>

<p>run</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>discovery
<span class="nt">--registries</span>
Mock
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="s">---</span>
<span class="na">proxyListenPort</span><span class="pi">:</span> <span class="m">15001</span>
<span class="na">connectTimeout</span><span class="pi">:</span> <span class="s">10s</span>
<span class="na">protocolDetectionTimeout</span><span class="pi">:</span> <span class="s">0s</span>
<span class="na">ingressClass</span><span class="pi">:</span> <span class="s">istio</span>
<span class="na">ingressService</span><span class="pi">:</span> <span class="s">istio-ingressgateway</span>
<span class="na">ingressControllerMode</span><span class="pi">:</span> <span class="s">STRICT</span>
<span class="na">enableTracing</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">defaultConfig</span><span class="pi">:</span>
  <span class="na">configPath</span><span class="pi">:</span> <span class="s2">"</span><span class="s">./etc/istio/proxy"</span>
  <span class="na">binaryPath</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/usr/local/bin/envoy"</span>
  <span class="na">serviceCluster</span><span class="pi">:</span> <span class="s">istio-proxy</span>
  <span class="na">drainDuration</span><span class="pi">:</span> <span class="s">45s</span>
  <span class="na">parentShutdownDuration</span><span class="pi">:</span> <span class="s">60s</span>
  <span class="na">discoveryAddress</span><span class="pi">:</span> <span class="s">istiod.istio-system.svc:15012</span>
  <span class="na">proxyAdminPort</span><span class="pi">:</span> <span class="m">15000</span>
  <span class="na">controlPlaneAuthPolicy</span><span class="pi">:</span> <span class="s">MUTUAL_TLS</span>
  <span class="na">statNameLength</span><span class="pi">:</span> <span class="m">189</span>
  <span class="na">concurrency</span><span class="pi">:</span> <span class="m">2</span>
  <span class="na">tracing</span><span class="pi">:</span>
    <span class="na">zipkin</span><span class="pi">:</span>
      <span class="na">address</span><span class="pi">:</span> <span class="s">zipkin.istio-system:9411</span>
  <span class="na">statusPort</span><span class="pi">:</span> <span class="m">15020</span>
  <span class="na">terminationDrainDuration</span><span class="pi">:</span> <span class="s">5s</span>
<span class="na">outboundTrafficPolicy</span><span class="pi">:</span>
  <span class="na">mode</span><span class="pi">:</span> <span class="s">ALLOW_ANY</span>
<span class="na">enableAutoMtls</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">trustDomain</span><span class="pi">:</span> <span class="s">cluster.local</span>
<span class="na">trustDomainAliases</span><span class="pi">:</span> <span class="pi">[]</span>
<span class="na">defaultServiceExportTo</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">*"</span>
<span class="na">defaultVirtualServiceExportTo</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">*"</span>
<span class="na">defaultDestinationRuleExportTo</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">*"</span>
<span class="na">rootNamespace</span><span class="pi">:</span> <span class="s">istio-system</span>
<span class="na">localityLbSetting</span><span class="pi">:</span>
  <span class="na">enabled</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">dnsRefreshRate</span><span class="pi">:</span> <span class="s">5s</span>
<span class="na">certificates</span><span class="pi">:</span> <span class="pi">[]</span>
<span class="na">thriftConfig</span><span class="pi">:</span> <span class="pi">{}</span>
<span class="na">serviceSettings</span><span class="pi">:</span> <span class="pi">[]</span>
<span class="na">extensionProviders</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">prometheus</span>
  <span class="na">prometheus</span><span class="pi">:</span> <span class="pi">{}</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">stackdriver</span>
  <span class="na">stackdriver</span><span class="pi">:</span> <span class="pi">{}</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">envoy</span>
  <span class="na">envoyFileAccessLog</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/dev/stdout"</span>
<span class="na">defaultProviders</span><span class="pi">:</span> <span class="pi">{}</span>




 <span class="s">---</span>
<span class="na">ServerOptions</span><span class="pi">:</span>
  <span class="na">HTTPAddr</span><span class="pi">:</span> <span class="s2">"</span><span class="s">:8080"</span>
  <span class="na">HTTPSAddr</span><span class="pi">:</span> <span class="s2">"</span><span class="s">:15017"</span>
  <span class="na">GRPCAddr</span><span class="pi">:</span> <span class="s2">"</span><span class="s">:15010"</span>
  <span class="na">MonitoringAddr</span><span class="pi">:</span> <span class="s2">"</span><span class="s">:15014"</span>
  <span class="na">EnableProfiling</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">TLSOptions</span><span class="pi">:</span>
    <span class="na">CaCertFile</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>
    <span class="na">CertFile</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>
    <span class="na">KeyFile</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>
    <span class="na">TLSCipherSuites</span><span class="pi">:</span>
    <span class="na">CipherSuits</span><span class="pi">:</span>
  <span class="na">SecureGRPCAddr</span><span class="pi">:</span> <span class="s2">"</span><span class="s">:15012"</span>
<span class="na">InjectionOptions</span><span class="pi">:</span>
  <span class="na">InjectionDirectory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">./var/lib/istio/inject"</span>
<span class="na">PodName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>
<span class="na">Namespace</span><span class="pi">:</span> <span class="s">istio-system</span>
<span class="na">Revision</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>
<span class="na">MeshConfigFile</span><span class="pi">:</span> <span class="s2">"</span><span class="s">./etc/istio/config/mesh"</span>
<span class="na">NetworksConfigFile</span><span class="pi">:</span> <span class="s2">"</span><span class="s">./etc/istio/config/meshNetworks"</span>
<span class="na">RegistryOptions</span><span class="pi">:</span>
  <span class="na">FileDir</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>
  <span class="na">Registries</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Mock</span>
  <span class="na">KubeOptions</span><span class="pi">:</span>
    <span class="na">SystemNamespace</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>
    <span class="na">MeshServiceController</span><span class="pi">:</span>
    <span class="na">ResyncPeriod</span><span class="pi">:</span> <span class="m">60000000000</span>
    <span class="na">DomainSuffix</span><span class="pi">:</span> <span class="s">cluster.local</span>
    <span class="na">ClusterID</span><span class="pi">:</span> <span class="s">Kubernetes</span>
    <span class="na">ClusterAliases</span><span class="pi">:</span> <span class="pi">{}</span>
    <span class="na">Metrics</span><span class="pi">:</span>
    <span class="na">XDSUpdater</span><span class="pi">:</span>
    <span class="na">NetworksWatcher</span><span class="pi">:</span>
    <span class="na">MeshWatcher</span><span class="pi">:</span>
    <span class="na">EndpointMode</span><span class="pi">:</span> <span class="m">0</span>
    <span class="na">KubernetesAPIQPS</span><span class="pi">:</span> <span class="m">80</span>
    <span class="na">KubernetesAPIBurst</span><span class="pi">:</span> <span class="m">160</span>
    <span class="na">SyncInterval</span><span class="pi">:</span> <span class="m">0</span>
    <span class="na">SyncTimeout</span><span class="pi">:</span>
    <span class="na">DiscoveryNamespacesFilter</span><span class="pi">:</span>
  <span class="na">ClusterRegistriesNamespace</span><span class="pi">:</span> <span class="s">istio-system</span>
  <span class="na">KubeConfig</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>
  <span class="na">DistributionCacheRetention</span><span class="pi">:</span> <span class="m">60000000000</span>
  <span class="na">DistributionTrackingEnabled</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">CtrlZOptions</span><span class="pi">:</span>
  <span class="na">Port</span><span class="pi">:</span> <span class="m">9876</span>
  <span class="na">Address</span><span class="pi">:</span> <span class="s">localhost</span>
<span class="na">Plugins</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">ext_authz</span>
<span class="pi">-</span> <span class="s">authn</span>
<span class="pi">-</span> <span class="s">authz</span>
<span class="na">KeepaliveOptions</span><span class="pi">:</span>
  <span class="na">Time</span><span class="pi">:</span> <span class="m">30000000000</span>
  <span class="na">Timeout</span><span class="pi">:</span> <span class="m">10000000000</span>
  <span class="na">MaxServerConnectionAge</span><span class="pi">:</span> <span class="m">9223372036854776000</span>
  <span class="na">MaxServerConnectionAgeGrace</span><span class="pi">:</span> <span class="m">10000000000</span>
<span class="na">ShutdownDuration</span><span class="pi">:</span> <span class="m">10000000000</span>
<span class="na">JwtRule</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>


</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl 10.42.77.70:8080/debug
/debug/adsz ADS的状态和调试接口
/debug/adsz?push<span class="o">=</span><span class="nb">true </span>启动向所有连接的端点推送当前状态的程序
/debug/authorizationz 内部授权政策
/debug/cachez 关于内部XDS缓存的信息
/debug/config_distribution 连接到这个Pilot实例的所有Envoy的版本状态。     
/debug/config_dump 以Envoy admin config dump API的形式对传递的proxyID进行配置转储。     
/debug/configz 对配置的调试支持     
/debug/edsz EDS的状态和调试接口     
/debug/endpointShardz 关于端点分片的信息     
/debug/endpointz 对端点的调试支持     
/debug/inject 活跃的注入模板     
/debug/instancesz 对服务实例的调试支持     
/debug/ndsz NDS的状态和调试接口     
/debug/pprof/ 显示pprof索引     
/debug/pprof/cmdline 当前程序的命令行调用。     
/debug/pprof/profile CPU简介     
/debug/pprof/symbol 符号查找请求中列出的程序计数器     
/debug/pprof/trace 对当前程序的执行情况进行跟踪。     
/debug/push_status 最后的PushContext细节     
/debug/registryz 对注册表的调试支持     
/debug/resourcesz 对被监视资源的调试支持     
/debug/syncz 连接到这个Pilot实例的所有Envoys的同步状态     
</code></pre></div></div>]]></content><author><name>Jony</name></author><category term="gRPC" /><category term="microservices" /><category term="Kubernetes" /><category term="k8s" /><summary type="html"><![CDATA[```bash Usage: pilot-discovery discovery [flags]]]></summary></entry><entry><title type="html">Kubernetes - ISTIO</title><link href="http://localhost:4000/Benjamin.github.io/grpc/2021/10/29/istio1.html" rel="alternate" type="text/html" title="Kubernetes - ISTIO" /><published>2021-10-29T03:17:35+08:00</published><updated>2021-10-29T03:17:35+08:00</updated><id>http://localhost:4000/Benjamin.github.io/grpc/2021/10/29/istio1</id><content type="html" xml:base="http://localhost:4000/Benjamin.github.io/grpc/2021/10/29/istio1.html"><![CDATA[<h1 id="理解">理解</h1>

<p>服务网格采用 sidecar 的运行模式，将 client-server 连接起来，形成格子的效果。
而这个 <code class="language-plaintext highlighter-rouge">sidecar</code> 系统就是 <code class="language-plaintext highlighter-rouge">envoy</code>。至于 <code class="language-plaintext highlighter-rouge">envoy</code> 需要如何运行就需要 <code class="language-plaintext highlighter-rouge">istio</code>
之类的系统。
所以服务网格大致分为两个部分组成执行和命令下发，即：数据面（Envoy）和控制面板（Istio）
个人总结：istio 应该数据面向 API 编程，严格按照数据面API 的方式编程，包括启动、
更新、命令下发。</p>

<p>istio-pliot：监督资源的变化、VirtualService 修改、DestinationRule修改，翻译为对外协议。
资源包括：service、endpoint、pod、node</p>

<p>VirtualService: 用于定义指定流量行为、路由规则，告诉 Sidecar 如何发送虚拟服务的流量到适当的目标
DestinationRule：访问目标规则与 VirtualService 一起使用
ServiceEntry：将集群外部的服务注册到 Pilot 中，再统一由 ServiceController 进行管理
WorkloadEntry：用于描述将非 Kubernetes 工作负载的实例，如虚拟机或裸机服务器，加入服务网格
ServiceEntry 是服务的抽象描述类似于 app-key ，WorkloadEntry 是服务的具体实例类似于 app-key 下的具体实例
<strong>ServiceEntry 可以通过 LabelSelector 筛选出自身对应的实例</strong></p>

<p>Pilot支持从Kubernetes、Consul等多种平台获取服务发现功能
用户通过VirtualService、DestinationRule等API制定服务间的流量治理规则</p>

<p>Pilot将发现的服务以及用户定义的服务间的调用规则进行融合并与底层Proxy的API进行适配后将规则下发</p>

<p>pilot-discovery  分为三层
上层 pilot-discovery  调用 kuberntes 来发现服务之间的关系，名称：Platform Adapter 层
中层 抽象模型，将获取的数据转换为istio 自己的数据模型。名称：Abstrace Model 层
下层 pilot-discovery  被 envoy 调用，数据通过 envoy API 暴露出去等待envoy去拉取这些规则。名称：Envoy API 层</p>

<p>pilot-discovery 三大模块：
Config Controller ：从不同来源接收路由规则</p>
<ul>
  <li>Config Controller 比较核心的就是对接 Kubernetes，从 kube-apiserver 中 Watch 集
群中的 VirtualService、ServiceEntry、DestinationRules 等配置信息，有变化则生
成 PushRequest 推送至 EnvoyXdsServer 中的推送队列。
<strong>除此之外，还支持对接 MCP(Mesh Configuration Protocol) 协议的 gRPC Server，需
要在 meshconfig 中配置 configSources .如 Nacos 的 MCP 服务等</strong>
<em>最后一种是基于内存的 Config Controller 实现，通过 Watch 一个文件目录，加载目录
中的 yaml 文件生成配置数据，主要用来测试。</em></li>
</ul>

<p>Service Controller：从不同注册中心获取注册实例</p>
<ul>
  <li>原生支持 Kubernetes 注册在这些注册中心中的服务可以无痛接入 Mesh，</li>
</ul>

<p>另外一种比较特殊，就是ServiceEntryStore，它本质是储存在 Config Controller 中的 
Istio 配置数据,但它描述的却是集群外部的服务信息,详情可阅读文档 ServiceEntry</p>

<p>XDSServer：核心的 xDS 协议推送服务，根据上面组件的数据生成 xDS 协议并下发</p>
<ul>
  <li>XdsServer 对接所有集群中的边车代理，如 Envoy、MOSN 等，当配置或服务发生变化时主动推送，也会响应代理发送的请求，依据请求的信息下发相应的 xDS 配置。</li>
</ul>

<p>还有对外的接口 Rules API 用于,给管理员的接口，管理员通过这个接口设定一些规则</p>

<p>总结：自动发现的这些Clusters和Endpoints，外加管理员设置的规则，形成了Pilot的数据模型，其实就是 istio 
定义的一系列数据结构，然后通过envoy API暴露出去，等待envoy去拉取这些规则</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Server</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">configController</span>  <span class="n">model</span><span class="o">.</span><span class="n">ConfigStoreCache</span>
  <span class="n">ConfigStores</span>      <span class="p">[]</span><span class="n">model</span><span class="o">.</span><span class="n">ConfigStoreCache</span>
  <span class="n">serviceEntryStore</span> <span class="o">*</span><span class="n">serviceentry</span><span class="o">.</span><span class="n">ServiceEntryStore</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>ConfigStores 是一个列表，里面存储了各类 Istio 配置文件，包括 ServiceEntry 、WorkloadEntry 等
服务数据，也包括 VirtualService、DestinationRules、Sidecar 等流量控制、路由规则的配置数据
pilot-discovery 将这些 ConfigStores 聚合成一个 <strong>configController 统一进行管理，之后再从其中衍</strong>
<strong>生出 IstioConfigStore，将其作为 serviceEntryStore 的配置源。serviceEntryStore 其实就是</strong>
<strong>ServiceEntry Controller，响应 ServiceEntry 和 WorkloadEntry 这类服务信息的变化。</strong></p>
</blockquote>

<blockquote>
  <p>XDSServer 比较核心，一切与 xDS 协议相关的接收、转换、下发操作都由它完成。
XDSServer 对接所有集群中的边车代理，如 Envoy、MOSN 等，当配置或服务发生变化
时主动推送，也会响应代理发送的请求，依据请求的信息下发相应的 xDS 配置。</p>
</blockquote>

<blockquote>
  <p>PushContext 是 Pilot 在推送 xDS 前，生成配置期间保存相关信息的上下文的地方，在全量推送配置和
配置发生改变时重置</p>
</blockquote>

<blockquote>
  <p>initMeshHandlers 为两个配置文件 mesh 和 meshNetworks 注册了两个 Handler ，当配置文件发生变化时触发全量 xDS 下发
下发到每个 Endpoint 好像还没有限流，不知道会不会引发什么并发性的问题</p>
</blockquote>

<blockquote>
  <p>initRegistryEventHandlers 设置了三个事件处理器 serviceHandler 、 apigatewayHandler 和 configHandler
分别响应服务、实例和配置数据的更新事件.
可以看到当服务本身发生变化时，会触发 xDS 的全量下发，所有与该服务相关的代理都会收到推送。
十万个节点也全量推送么
configController ，它操作的对象主要是像 VirtualService 、 DestinationRules 这些 Istio 定义的配置，这些配置的变化也会触发 xDS 的全量下发
ServiceEntryStore 负责ServiceEntry 和 WorkloadEntry
RunAndWait 启动后所有 Informer 将开始缓存，并等待它们同步完成</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">PushContext</code>：跟踪推送状态
<code class="language-plaintext highlighter-rouge">aggregate</code>:ADS 控制器
<code class="language-plaintext highlighter-rouge">DiscoveryServer</code>:从Pilot的内部网格数据结构中获取数据。
<code class="language-plaintext highlighter-rouge">ConfigGenerator</code>:数据平面配置生成器实例。
<code class="language-plaintext highlighter-rouge">Environment</code>:为Pilot提供了一个综合环境API
<code class="language-plaintext highlighter-rouge">NetworksWatcher</code>:l3 层拓扑结构感知
<code class="language-plaintext highlighter-rouge">MeshHandlers</code>:网格和网络处理程序
<code class="language-plaintext highlighter-rouge">MeshConfig</code>:定义了Istio服务网格的设置</p>

<p>上层使用指定注册中心机制，将除了 k8s 之外的依赖支持 MCP 的组件接入到 istio 中。
如果外部组件支持 MCP 那么 istio 将会预期建立长连接获取其中的数据。以 Nacos 为例
只需要指定 Nacos 就可以从 Nacos 获取数据，支持 MCP 协议就是将数据模型抽象为了中
间层。</p>

<hr />]]></content><author><name>Jony</name></author><category term="gRPC" /><category term="microservices" /><category term="Kubernetes" /><category term="k8s" /><summary type="html"><![CDATA[理解]]></summary></entry><entry><title type="html">Kubernetes - kube-proxy 无秘密（iptables）</title><link href="http://localhost:4000/Benjamin.github.io/grpc/2021/10/19/k8s4.html" rel="alternate" type="text/html" title="Kubernetes - kube-proxy 无秘密（iptables）" /><published>2021-10-19T00:42:00+08:00</published><updated>2021-10-19T00:42:00+08:00</updated><id>http://localhost:4000/Benjamin.github.io/grpc/2021/10/19/k8s4</id><content type="html" xml:base="http://localhost:4000/Benjamin.github.io/grpc/2021/10/19/k8s4.html"><![CDATA[<p>翻译：<a href="https://ssup2.github.io/theory_analysis/Kubernetes_Service_Proxy/">Kubernetes Service Proxy</a></p>

<h1 id="背景">背景</h1>

<p><code class="language-plaintext highlighter-rouge">kube-proxy</code> 是负责 k8s 集群内通信规则创建的组建，k8s 官方文档解释</p>

<blockquote>
  <p>Kubernetes 网络代理在每个节点上运行。网络代理反映了每个节点上 Kubernetes API 中定义的服务，
并且可以执行简单的 TCP、UDP 和 SCTP 流转发，或者在一组后端进行 循环 TCP、UDP 和 SCTP 转发。</p>
</blockquote>

<p>但是 kube-proxy 本身并不负责流量转发等工作。
Kubernetes 支持三种 Service Proxy 模式：iptables、IPVS 和 Userspace。根据服务代理方式分析服务请求报文路径。</p>

<h1 id="service-和-pod-信息">Service 和 Pod 信息</h1>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get pod <span class="nt">-o</span> wide
NAME                              READY   STATUS    RESTARTS   AGE   IP              NODE     NOMINATED NODE
my-nginx-756f645cd7-gh7sq         1/1     Running   14         15d   192.167.2.231   kube03   &lt;none&gt;
my-nginx-756f645cd7-hm7rg         1/1     Running   17         20d   192.167.2.206   kube03   &lt;none&gt;
my-nginx-756f645cd7-qfqbp         1/1     Running   16         20d   192.167.1.123   kube02   &lt;none&gt;

<span class="nv">$ </span>kubectl get pod <span class="nt">-o</span> wide
NAME                    TYPE           CLUSTER-IP       EXTERNAL-IP    PORT<span class="o">(</span>S<span class="o">)</span>                           AGE     SELECTOR
my-nginx-cluster        ClusterIP      10.103.1.234     &lt;none&gt;         80/TCP                            15d     <span class="nv">run</span><span class="o">=</span>my-nginx
my-nginx-loadbalancer   LoadBalancer   10.96.98.173     172.35.0.200   80:30781/TCP                      15d    <span class="nv">run</span><span class="o">=</span>my-nginx
my-nginx-nodeport       NodePort       10.97.229.148    &lt;none&gt;         80:30915/TCP 
</code></pre></div></div>
<p>这里展示了 <code class="language-plaintext highlighter-rouge">Kubernetes Service Proxy</code> 的 <code class="language-plaintext highlighter-rouge">Service</code> 和 <code class="language-plaintext highlighter-rouge">Pod</code> 信息。可以从上面的信息看出部署了三个 <code class="language-plaintext highlighter-rouge">nginx</code> Pod。并添加了
<code class="language-plaintext highlighter-rouge">ClusterIP</code> 类型的 <code class="language-plaintext highlighter-rouge">my-nginx-cluster</code> 、<code class="language-plaintext highlighter-rouge">NodePort</code> 类型的 <code class="language-plaintext highlighter-rouge">nginx-nodeport</code> 和 <code class="language-plaintext highlighter-rouge">LoadBalancer</code> 的 <code class="language-plaintext highlighter-rouge">my-nginx-loadbalancer</code>。</p>

<h1 id="iptables-模式">Iptables 模式</h1>

<p><img src="/images/k8s/iptables_Mode_Service_Packet_Path.png" alt="iptables模式下的服务请求包路径" /></p>

<p><code class="language-plaintext highlighter-rouge">iptables</code> 模式下的 <code class="language-plaintext highlighter-rouge">KUBE-SERVICES</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Chain KUBE-SERVICES <span class="o">(</span>2 references<span class="o">)</span>
 pkts bytes target     prot opt <span class="k">in     </span>out     <span class="nb">source               </span>destination
    0     0 KUBE-MARK-MASQ  tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>      <span class="o">!</span>192.167.0.0/16       10.96.98.173         /<span class="k">*</span> default/my-nginx-loadbalancer: cluster IP <span class="k">*</span>/ tcp dpt:80
    0     0 KUBE-SVC-TNQCJ2KHUMKABQTD  tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            10.96.98.173         /<span class="k">*</span> default/my-nginx-loadbalancer: cluster IP <span class="k">*</span>/ tcp dpt:80
    0     0 KUBE-FW-TNQCJ2KHUMKABQTD  tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            172.35.0.200         /<span class="k">*</span> default/my-nginx-loadbalancer: loadbalancer IP <span class="k">*</span>/ tcp dpt:80
    0     0 KUBE-MARK-MASQ  tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>      <span class="o">!</span>192.167.0.0/16       10.103.1.234         /<span class="k">*</span> default/my-nginx-cluster: cluster IP <span class="k">*</span>/ tcp dpt:80
    0     0 KUBE-SVC-52FY5WPFTOHXARFK  tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            10.103.1.234         /<span class="k">*</span> default/my-nginx-cluster: cluster IP <span class="k">*</span>/ tcp dpt:80 
    0     0 KUBE-MARK-MASQ  tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>      <span class="o">!</span>192.167.0.0/16       10.97.229.148        /<span class="k">*</span> default/my-nginx-nodeport: cluster IP <span class="k">*</span>/ tcp dpt:80
    0     0 KUBE-SVC-6JXEEPSEELXY3JZG  tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            10.97.229.148        /<span class="k">*</span> default/my-nginx-nodeport: cluster IP <span class="k">*</span>/ tcp dpt:80
    0     0 KUBE-NODEPORTS  all  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> kubernetes service nodeports<span class="p">;</span> NOTE: this must be the last rule <span class="k">in </span>this chain <span class="k">*</span>/ ADDRTYPE match dst-type LOCAL
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">iptables</code> 模式下的 <code class="language-plaintext highlighter-rouge">KUBE-NODEPORTS</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Chain KUBE-NODEPORTS <span class="o">(</span>1 references<span class="o">)</span>
 pkts bytes target     prot opt <span class="k">in     </span>out     <span class="nb">source               </span>destination
    0     0 KUBE-MARK-MASQ  tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> default/my-nginx-loadbalancer: <span class="k">*</span>/ tcp dpt:30781
    0     0 KUBE-SVC-TNQCJ2KHUMKABQTD  tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> default/my-nginx-loadbalancer: <span class="k">*</span>/ tcp dpt:30781
    0     0 KUBE-MARK-MASQ  tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> default/my-nginx-nodeport: <span class="k">*</span>/ tcp dpt:30915
    0     0 KUBE-SVC-6JXEEPSEELXY3JZG  tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> default/my-nginx-nodeport: <span class="k">*</span>/ tcp dpt:30915 
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">iptables</code> 模式下的 <code class="language-plaintext highlighter-rouge">KUBE-FW-XXX</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Chain KUBE-FW-TNQCJ2KHUMKABQTD <span class="o">(</span>1 references<span class="o">)</span>
 pkts bytes target     prot opt <span class="k">in     </span>out     <span class="nb">source               </span>destination
    0     0 KUBE-MARK-MASQ  all  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> default/my-nginx-loadbalancer: loadbalancer IP <span class="k">*</span>/
    0     0 KUBE-SVC-TNQCJ2KHUMKABQTD  all  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> default/my-nginx-loadbalancer: loadbalancer IP <span class="k">*</span>/
    0     0 KUBE-MARK-DROP  all  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> default/my-nginx-loadbalancer: loadbalancer IP <span class="k">*</span>/
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">iptables</code> 模式下的 <code class="language-plaintext highlighter-rouge">KUBE-SVC-XXX</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Chain KUBE-SVC-TNQCJ2KHUMKABQTD <span class="o">(</span>2 references<span class="o">)</span>
 pkts bytes target     prot opt <span class="k">in     </span>out     <span class="nb">source               </span>destination
    0     0 KUBE-SEP-6HM47TA5RTJFOZFJ  all  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            statistic mode random probability 0.33332999982
    0     0 KUBE-SEP-AHRDCNDYGFSFVA64  all  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            statistic mode random probability 0.50000000000
    0     0 KUBE-SEP-BK523K4AX5Y34OZL  all  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0      
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">iptables</code> 模式下的 <code class="language-plaintext highlighter-rouge">KUBE-SEP-XXX</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Chain KUBE-SEP-6HM47TA5RTJFOZFJ <span class="o">(</span>1 references<span class="o">)</span>
 pkts bytes target     prot opt <span class="k">in     </span>out     <span class="nb">source               </span>destination
    0     0 KUBE-MARK-MASQ  all  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       192.167.2.231        0.0.0.0/0
    0     0 DNAT       tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            tcp to:192.167.2.231:80 
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">iptables</code> 模式下的 <code class="language-plaintext highlighter-rouge">KUBE-POSTROUTING</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Chain KUBE-POSTROUTING <span class="o">(</span>1 references<span class="o">)</span>
 pkts bytes target     prot opt <span class="k">in     </span>out     <span class="nb">source               </span>destination
    0     0 MASQUERADE  all  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> kubernetes service traffic requiring SNAT <span class="k">*</span>/ mark match
0x4000/0x4000 
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">iptables</code> 模式下的 <code class="language-plaintext highlighter-rouge">KUBE-MARK-MASQ</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Chain KUBE-MARK-MASQ <span class="o">(</span>23 references<span class="o">)</span>
 pkts bytes target     prot opt <span class="k">in     </span>out     <span class="nb">source               </span>destination
    0     0 MARK       all  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            MARK or 0x4000 
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">iptables</code> 模式下的 <code class="language-plaintext highlighter-rouge">KUBE-MARK-DROP</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Chain KUBE-MARK-DROP <span class="o">(</span>10 references<span class="o">)</span>
 pkts bytes target     prot opt <span class="k">in     </span>out     <span class="nb">source               </span>destination
    0     0 MARK       all  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            MARK or 0x8000
</code></pre></div></div>

<p>这里的 <code class="language-plaintext highlighter-rouge">Service Proxy</code> 使用是 <code class="language-plaintext highlighter-rouge">iptables</code> 模式。这是 <code class="language-plaintext highlighter-rouge">Kubernetes</code> 当前使用的默认代理模式。
在上方图中展示了 <code class="language-plaintext highlighter-rouge">iptables</code> 模式下服务请求包的路径。上方的 <code class="language-plaintext highlighter-rouge">bash</code> 是展示了主要 <code class="language-plaintext highlighter-rouge">NAT</code> 表的内容。</p>

<p>由于大多数 <code class="language-plaintext highlighter-rouge">Pod</code> 传输的请求包是通过 <code class="language-plaintext highlighter-rouge">Pod</code> 的 <code class="language-plaintext highlighter-rouge">veth</code> 传递到主机的网络命名空间，因此请求包通过 <code class="language-plaintext highlighter-rouge">PREROUTING</code> 表传递到 <code class="language-plaintext highlighter-rouge">KUBE-SERVICES</code> 表。
<code class="language-plaintext highlighter-rouge">Pod</code> 或者 <code class="language-plaintext highlighter-rouge">Host</code>进程 使用 <code class="language-plaintext highlighter-rouge">Host</code> 的网络命名空间传输的请求数据包由 <code class="language-plaintext highlighter-rouge">OUTPUT</code> 表传递到 <code class="language-plaintext highlighter-rouge">KUBE-SERVICES</code> 表。</p>

<p>如果<code class="language-plaintext highlighter-rouge">KUBE-SERVICES</code> 表中请求包的目标<code class="language-plaintext highlighter-rouge">IP</code>和目标<code class="language-plaintext highlighter-rouge">Port</code>与<code class="language-plaintext highlighter-rouge">ClusterIP Service</code>的<code class="language-plaintext highlighter-rouge">IP</code>和<code class="language-plaintext highlighter-rouge">Port</code>匹配，则请求的包
被转发到<code class="language-plaintext highlighter-rouge">KUBE-SVC-XXX</code> 表，即<code class="language-plaintext highlighter-rouge">ClusterIP Service</code>的<code class="language-plaintext highlighter-rouge">NAT</code>表.</p>

<p>如果 <code class="language-plaintext highlighter-rouge">KUBE-SERVICES</code> 表中请求包的目标 <code class="language-plaintext highlighter-rouge">IP</code> 是节点自己的 <code class="language-plaintext highlighter-rouge">IP</code>，则将请求包转发到 <code class="language-plaintext highlighter-rouge">KUBE-NODEPORTS</code> 表。
如果 <code class="language-plaintext highlighter-rouge">KUBE-NODEPORTS</code> 表中请求报文的目标 <code class="language-plaintext highlighter-rouge">Port</code> 与 <code class="language-plaintext highlighter-rouge">NodePort Service</code> 的 <code class="language-plaintext highlighter-rouge">Port</code>匹配，则将请求报文传送到 <code class="language-plaintext highlighter-rouge">KUBE-SVC-XXX</code> 表，
即 <code class="language-plaintext highlighter-rouge">NodePort Service</code> 的 <code class="language-plaintext highlighter-rouge">NAT</code> 表。</p>

<p>如果<code class="language-plaintext highlighter-rouge">KUBE-SERVICES</code> 表中请求包的目标 <code class="language-plaintext highlighter-rouge">IP</code>和目标 <code class="language-plaintext highlighter-rouge">Port</code>与<code class="language-plaintext highlighter-rouge">LoadBalancer Service</code> 的<code class="language-plaintext highlighter-rouge">External IP</code>和<code class="language-plaintext highlighter-rouge">Port</code>匹配，
则将请求包转发到<code class="language-plaintext highlighter-rouge">KUBE-FW-XXX</code> 表，<code class="language-plaintext highlighter-rouge">LoadBalancer Service</code>的<code class="language-plaintext highlighter-rouge">NAT</code>表，然后再将 <code class="language-plaintext highlighter-rouge">LoadBalancer Service</code> 传送
到 <code class="language-plaintext highlighter-rouge">KUBE-SVC-XXX</code> 表，也就是 <code class="language-plaintext highlighter-rouge">NAT</code> 表</p>

<p>在<code class="language-plaintext highlighter-rouge">KUBE-SVC-XXX</code> 表中，请求包通过<code class="language-plaintext highlighter-rouge">iptables</code>的统计功能，在构成<code class="language-plaintext highlighter-rouge">Service</code>的<code class="language-plaintext highlighter-rouge">Pod</code>之间起到随机均匀负载均衡的作用。
在 <em><code class="language-plaintext highlighter-rouge">KUBE-SVC-TNQCJ2KHUMKABQTD</code></em> 中，由于<code class="language-plaintext highlighter-rouge">Service</code>由三个<code class="language-plaintext highlighter-rouge">pod</code>组成，可以看出请求包设置为随机均衡负载均衡，使用三个<code class="language-plaintext highlighter-rouge">KUBE-SEP-XXX</code>表。
在 <code class="language-plaintext highlighter-rouge">KUBE-SEP-XXX</code> 表中，请求包使用 <code class="language-plaintext highlighter-rouge">Pod</code> 的 <code class="language-plaintext highlighter-rouge">IP</code> 和 <code class="language-plaintext highlighter-rouge">Service</code> 中设置的 <code class="language-plaintext highlighter-rouge">Port</code> 进行 <code class="language-plaintext highlighter-rouge">DNAT</code>。
由<code class="language-plaintext highlighter-rouge">Pod</code>的<code class="language-plaintext highlighter-rouge">IP</code>发出的<code class="language-plaintext highlighter-rouge">DNAT</code>请求包通过<code class="language-plaintext highlighter-rouge">CNI Plugin</code>构建的容器网络传递给该<code class="language-plaintext highlighter-rouge">Pod</code>。</p>

<p>由于传递给<code class="language-plaintext highlighter-rouge">service</code>的请求包是通过<code class="language-plaintext highlighter-rouge">iptables</code>的<code class="language-plaintext highlighter-rouge">DNAT</code>传递给<code class="language-plaintext highlighter-rouge">Pod</code>的，所以<code class="language-plaintext highlighter-rouge">Pod</code>发出的响应包的<code class="language-plaintext highlighter-rouge">Src IP</code>应该<code class="language-plaintext highlighter-rouge">SNAT</code>到<code class="language-plaintext highlighter-rouge">Service IP</code>，
而不是<code class="language-plaintext highlighter-rouge">Pod IP</code> 。<code class="language-plaintext highlighter-rouge">iptables</code> 中未指定 <code class="language-plaintext highlighter-rouge">Serivce</code> 的 <code class="language-plaintext highlighter-rouge">SNAT</code> 规则。但是，<code class="language-plaintext highlighter-rouge">iptables</code>根据<code class="language-plaintext highlighter-rouge">Linux Kernel</code> 的<code class="language-plaintext highlighter-rouge">Conntrack</code>（连接跟踪）的 
<code class="language-plaintext highlighter-rouge">TCP</code> 连接信息对从 <code class="language-plaintext highlighter-rouge">Service Pod</code> 收到的响应数据包进行 <code class="language-plaintext highlighter-rouge">SNAT</code>。</p>

<h1 id="source-ip">Source IP</h1>

<p><code class="language-plaintext highlighter-rouge">Service</code>请求包的<code class="language-plaintext highlighter-rouge">Src IP</code>将被留存，或通过<code class="language-plaintext highlighter-rouge">Masquerade</code>作为<code class="language-plaintext highlighter-rouge">Host</code>的<code class="language-plaintext highlighter-rouge">IP</code>进行<code class="language-plaintext highlighter-rouge">SNAT</code>。
<code class="language-plaintext highlighter-rouge">KUBE-MARK-MASQ</code> 是一个表，将使用 <code class="language-plaintext highlighter-rouge">Masquerade</code> 对请求包进行标记。
<code class="language-plaintext highlighter-rouge">Marking</code>的<code class="language-plaintext highlighter-rouge">Packet</code>在<code class="language-plaintext highlighter-rouge">KUBE-POSTROUTING</code> 表中成为<code class="language-plaintext highlighter-rouge">Masquerade</code>，<code class="language-plaintext highlighter-rouge">Src IP</code>作为<code class="language-plaintext highlighter-rouge">Host</code>的<code class="language-plaintext highlighter-rouge">IP</code>成为<code class="language-plaintext highlighter-rouge">SNAT</code>。
在<code class="language-plaintext highlighter-rouge">iptables</code> 表中，你会发现<code class="language-plaintext highlighter-rouge">KUBE-MARK-MASQ</code> 表会检测出被<code class="language-plaintext highlighter-rouge">Masquerade</code>标记过的包。</p>

<p><img src="/images/k8s/NodePort_Policy.png" alt="根据NodePort、LoadBalancer Service的externalTrafficPolicy的数据包路径" />
<strong>根据NodePort、LoadBalancer Service的externalTrafficPolicy的数据包路径图</strong></p>

<p><em>图中左侧为<code class="language-plaintext highlighter-rouge">externalTrafficPolicy</code>值为<code class="language-plaintext highlighter-rouge">Cluster</code>，执行 <code class="language-plaintext highlighter-rouge">Masquerade</code>。</em>
<code class="language-plaintext highlighter-rouge">LoadBalancer Service</code> 的 <code class="language-plaintext highlighter-rouge">NodePort</code> 和 <code class="language-plaintext highlighter-rouge">externalTrafficPolicy</code> 的 <code class="language-plaintext highlighter-rouge">Cluster</code>。
如果<code class="language-plaintext highlighter-rouge">externalTrafficPolicy</code>值设置为<code class="language-plaintext highlighter-rouge">Cluster</code>，则请求包的<code class="language-plaintext highlighter-rouge">Src IP</code>通过<code class="language-plaintext highlighter-rouge">Masquerade</code> 被 <code class="language-plaintext highlighter-rouge">SNAT</code>到<code class="language-plaintext highlighter-rouge">Host</code>的<code class="language-plaintext highlighter-rouge">IP</code>。
在 <code class="language-plaintext highlighter-rouge">KUBE-NODEPORTS</code> 表中，可以通过 <code class="language-plaintext highlighter-rouge">KUBE-MARK-MASQ</code> 表检查所有以 <code class="language-plaintext highlighter-rouge">NodePort</code> 和 <code class="language-plaintext highlighter-rouge">LoadBalancer Service Port</code> 
作为 <code class="language-plaintext highlighter-rouge">Dest Port</code> 的数据包。</p>

<p><em>图右侧是通过将<code class="language-plaintext highlighter-rouge">externalTrafficPolicy</code>设置为<code class="language-plaintext highlighter-rouge">Local</code>，不执行<code class="language-plaintext highlighter-rouge">Masquerade</code></em>
如果将 <code class="language-plaintext highlighter-rouge">externalTrafficPolicy</code> 值设置为 <code class="language-plaintext highlighter-rouge">Local</code>，则 <code class="language-plaintext highlighter-rouge">KUBE-MARK-MASQ</code> 表中相关规则将不会出现在 <code class="language-plaintext highlighter-rouge">KUBE-NODEPORTS</code> 表中，
所以就不会执行到 <code class="language-plaintext highlighter-rouge">Masquerade</code>。请求数据包的 <code class="language-plaintext highlighter-rouge">Src IP</code> 不会被修改。另外，请求包在宿主机中不会被负载均衡，而是将请求包发送
到的 <code class="language-plaintext highlighter-rouge">Host</code> 中的目标<code class="language-plaintext highlighter-rouge">pod</code>。如果请求数据包被发送到主机不存在目标 <code class="language-plaintext highlighter-rouge">pod</code>，那么请求数据包将被丢弃。</p>

<p><code class="language-plaintext highlighter-rouge">ExternalTrafficPolicy Local</code>主要用于<code class="language-plaintext highlighter-rouge">LoadBalancer Service</code>。因为由 <code class="language-plaintext highlighter-rouge">Cloud Provider</code> 的负载均衡器执行负载均衡，
所以主机不需要负载均衡，所以可以保留请求包的<code class="language-plaintext highlighter-rouge">Src IP</code>。
如果<code class="language-plaintext highlighter-rouge">externalTrafficPolicy</code>值为<code class="language-plaintext highlighter-rouge">Local</code>，云服务提供商的负载均衡器会对目标 Pod 执行健康检查，如果健康检查失败
或者目标 Pod 不存在，那么发送到主机上的数据包将会被丢弃删除。</p>

<p><img src="/images/k8s/iptables_Mode_Hairpinning.png" alt="iptables模式下发夹前/后的数据包路径" /></p>

<p>在<code class="language-plaintext highlighter-rouge">Pod</code>中向自己所属的<code class="language-plaintext highlighter-rouge">Service</code>的<code class="language-plaintext highlighter-rouge">IP</code>发送请求数据包，在请求数据包返回时也需要 <code class="language-plaintext highlighter-rouge">Masquerade</code>。图中左边就标识这种情况。
请求数据包被DNAT, 数据包的<code class="language-plaintext highlighter-rouge">Src IP</code>和<code class="language-plaintext highlighter-rouge">Dest IP</code>都是<code class="language-plaintext highlighter-rouge">Pod</code>本身的<code class="language-plaintext highlighter-rouge">IP</code>。
因此，<code class="language-plaintext highlighter-rouge">Pod</code>返回响应数据包时，响应数据包不通过<code class="language-plaintext highlighter-rouge">Host</code>的<code class="language-plaintext highlighter-rouge">NAT</code>表，因此不会执行<code class="language-plaintext highlighter-rouge">SNAT</code>，直接在 <code class="language-plaintext highlighter-rouge">Pod</code> 中处理。</p>

<p>如果使用 <code class="language-plaintext highlighter-rouge">Masquerade</code>，则可以通过将返回 <code class="language-plaintext highlighter-rouge">Pod</code> 的请求包强制传递给 Host 来执行 SNAT。这种通过故意绕过数据包来接收数据包的方法称为<code class="language-plaintext highlighter-rouge">Hairpinning</code>。
图中的右侧显示了使用<code class="language-plaintext highlighter-rouge">Masqurade</code>应用<code class="language-plaintext highlighter-rouge">Hairpinning</code>的情况。如果<code class="language-plaintext highlighter-rouge">KUBE-SEP-XXX</code>表中请求数据包的Src IP与DNAT的IP相同，
即<code class="language-plaintext highlighter-rouge">Pod</code>发送到<code class="language-plaintext highlighter-rouge">Service</code>的数据包由自己接收时，则请求的数据包经过<code class="language-plaintext highlighter-rouge">KUBE-MARK-MASQ</code> 表是被 <code class="language-plaintext highlighter-rouge">Marking</code>，
在<code class="language-plaintext highlighter-rouge">KUBE-POSTROUTING</code> 表中被<code class="language-plaintext highlighter-rouge">Masquerade</code>
因为<code class="language-plaintext highlighter-rouge">Pod</code>接收到的数据包的<code class="language-plaintext highlighter-rouge">Src IP</code>被设置为<code class="language-plaintext highlighter-rouge">Host</code>的<code class="language-plaintext highlighter-rouge">IP</code>，因此<code class="language-plaintext highlighter-rouge">Pod</code>的响应被发送到<code class="language-plaintext highlighter-rouge">Host</code>的<code class="language-plaintext highlighter-rouge">NAT</code> 表，然后进行<code class="language-plaintext highlighter-rouge">SNAT</code>和<code class="language-plaintext highlighter-rouge">DNAT</code>传递给<code class="language-plaintext highlighter-rouge">Pod</code>。</p>

<h1 id="用户空间">用户空间</h1>

<p>Userspace Mode下的服务请求报文路径图：
<img src="/images/k8s/Userspace_Mode_Service_Packet_Path.png" alt="Userspace_Mode_Service_Packet_Path.png" /></p>

<p>用户空间模式下的 KUBE-PORTALS-CONTAINER：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Chain KUBE-PORTALS-CONTAINER <span class="o">(</span>1 references<span class="o">)</span>
 pkts bytes target     prot opt <span class="k">in     </span>out     <span class="nb">source               </span>destination
    0     0 REDIRECT   tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            10.96.98.173         /<span class="k">*</span> default/my-nginx-loadbalancer: <span class="k">*</span>/ tcp dpt:80 redir ports 38023
    0     0 REDIRECT   tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            172.35.0.200         /<span class="k">*</span> default/my-nginx-loadbalancer: <span class="k">*</span>/ tcp dpt:80 redir ports 38023
    0     0 REDIRECT   tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            10.103.1.234         /<span class="k">*</span> default/my-nginx-cluster: <span class="k">*</span>/ tcp dpt:80 redir ports 36451
    0     0 REDIRECT   tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            10.97.229.148        /<span class="k">*</span> default/my-nginx-nodeport: <span class="k">*</span>/ tcp dpt:80 redir ports 44257
</code></pre></div></div>

<p>用户空间模式下的 KUBE-NODEPORT-CONTAINER：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Chain KUBE-NODEPORT-CONTAINER <span class="o">(</span>1 references<span class="o">)</span>
 pkts bytes target     prot opt <span class="k">in     </span>out     <span class="nb">source               </span>destination
    0     0 REDIRECT   tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> default/my-nginx-loadbalancer: <span class="k">*</span>/ tcp dpt:30781 redir ports 38023
    0     0 REDIRECT   tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> default/my-nginx-nodeport: <span class="k">*</span>/ tcp dpt:30915 redir ports 44257
</code></pre></div></div>

<p>用户空间模式下的 KUBE-PORTALS-HOST：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Chain KUBE-PORTALS-HOST <span class="o">(</span>1 references<span class="o">)</span>
 pkts bytes target     prot opt <span class="k">in     </span>out     <span class="nb">source               </span>destination
    0     0 DNAT       tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            10.96.98.173         /<span class="k">*</span> default/my-nginx-loadbalancer: <span class="k">*</span>/ tcp dpt:80 to:172.35.0.100:38023
    0     0 DNAT       tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            172.35.0.200         /<span class="k">*</span> default/my-nginx-loadbalancer: <span class="k">*</span>/ tcp dpt:80 to:172.35.0.100:38023
    0     0 DNAT       tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            10.103.1.234         /<span class="k">*</span> default/my-nginx-cluster: <span class="k">*</span>/ tcp dpt:80 to:172.35.0.100:46635
    0     0 DNAT       tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            10.97.229.148        /<span class="k">*</span> default/my-nginx-nodeport: <span class="k">*</span>/ tcp dpt:80 to:172.35.0.100:32847
</code></pre></div></div>

<p>用户空间模式下的 KUBE-NODEPORT-HOST：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Chain KUBE-NODEPORT-HOST <span class="o">(</span>1 references<span class="o">)</span>
 pkts bytes target     prot opt <span class="k">in     </span>out     <span class="nb">source               </span>destination
    0     0 DNAT       tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> default/my-nginx-loadbalancer: <span class="k">*</span>/ tcp dpt:30781 to:172.35.0.100:38023
    0     0 DNAT       tcp  <span class="nt">--</span>  <span class="k">*</span>      <span class="k">*</span>       0.0.0.0/0            0.0.0.0/0            /<span class="k">*</span> default/my-nginx-nodeport: <span class="k">*</span>/ tcp dpt:30915 to:172.35.0.100:44257
</code></pre></div></div>

<p>Service Proxy 的 iptables 模式是一种运行在用户空间的 kube-proxy 扮演 Service Proxy 角色的模式。
这是 Kubernetes 提供的第一个代理模式。目前使用的不是很好，因为与iptables模式相比性能较差。
上图中展示了 Userspace 模式下Service 请求包的路径。</p>

<p>由于大多数 <code class="language-plaintext highlighter-rouge">Pod</code> 传输的请求包是通过 <code class="language-plaintext highlighter-rouge">Pod</code> 的 <code class="language-plaintext highlighter-rouge">veth</code> 传递到 <code class="language-plaintext highlighter-rouge">Host</code> 的 <code class="language-plaintext highlighter-rouge">Network</code> 命名空间，因此请求包通过 PREROUTING 表传递到
<code class="language-plaintext highlighter-rouge">KUBE-PORTALS-CONTAINER</code> 表。如果 <code class="language-plaintext highlighter-rouge">KUBE-PORTALS-CONTAINER</code> 标准中请求包的 目标 <code class="language-plaintext highlighter-rouge">IP</code> 和目标 <code class="language-plaintext highlighter-rouge">Port</code> 与 <code class="language-plaintext highlighter-rouge">ClusterIP</code> 服务
的 <code class="language-plaintext highlighter-rouge">IP</code> 和 <code class="language-plaintext highlighter-rouge">Port</code> 匹配，则请求包被重定向到<code class="language-plaintext highlighter-rouge">kube-proxy</code> 。如果请求数据包的目标 <code class="language-plaintext highlighter-rouge">IP</code>是节点自己的<code class="language-plaintext highlighter-rouge">IP</code>，则将数据包投递到
<code class="language-plaintext highlighter-rouge">KUBE-NODEPORT-CONTAINER</code>表。如果 <code class="language-plaintext highlighter-rouge">KUBE-NODEPORT-CONTAINER</code> 表中请求包的 目标 <code class="language-plaintext highlighter-rouge">Port</code> 与 <code class="language-plaintext highlighter-rouge">NodePort Service</code> 的端
口匹配，则请求包被重定向到 <code class="language-plaintext highlighter-rouge">kube-proxy</code>。如果请求包的目标 <code class="language-plaintext highlighter-rouge">IP</code>和目标 <code class="language-plaintext highlighter-rouge">Port</code>与<code class="language-plaintext highlighter-rouge">LoadBalancer Service</code>的<code class="language-plaintext highlighter-rouge">External IP</code>和<code class="language-plaintext highlighter-rouge">Port</code>匹配，
请求包也会被重定向到kube-proxy。</p>

<p><code class="language-plaintext highlighter-rouge">Pod</code> 或 <code class="language-plaintext highlighter-rouge">Host</code> 进程使用 <code class="language-plaintext highlighter-rouge">Host</code> 的 <code class="language-plaintext highlighter-rouge">Network Namespace</code> 传输的请求数据包由 <code class="language-plaintext highlighter-rouge">OUTPUT</code> 表 传递到 <code class="language-plaintext highlighter-rouge">KUBE-PORTALS-HOST</code> 表。
<code class="language-plaintext highlighter-rouge">KUBE-PORTALS-HOST</code> 和 <code class="language-plaintext highlighter-rouge">KUBE-NODEPORT-HOST</code> 表中的后续请求包处理类似于 <code class="language-plaintext highlighter-rouge">KUBE-PORTALS-CONTAINER</code> 和 <code class="language-plaintext highlighter-rouge">KUBE-NODEPORT-CONTAINER</code> 表
中的请求包处理。不同之处在于，DNAT是在不重定向请求包的情况下执行的。</p>

<p><strong>通过 <code class="language-plaintext highlighter-rouge">Redirect</code> 和 <code class="language-plaintext highlighter-rouge">DNAT</code> 发送到 <code class="language-plaintext highlighter-rouge">Service</code> 的所有请求数据包都被传递到 <code class="language-plaintext highlighter-rouge">kube-proxy</code></strong>。<code class="language-plaintext highlighter-rouge">kube-proxy</code> 收到的请求数据包的
每个目标 <code class="language-plaintext highlighter-rouge">Port</code> 映射一个服务。因此，<code class="language-plaintext highlighter-rouge">kube-proxy</code> 可以通过重定向和 <code class="language-plaintext highlighter-rouge">NAT</code> 请求数据包的 目标 <code class="language-plaintext highlighter-rouge">Port</code> 确定请求数据包应该传递到哪个服务。
<code class="language-plaintext highlighter-rouge">kube-proxy</code> 通过将接收到的请求数据包均匀地负载均衡到属于请求数据包要传输到的服务的多个 <code class="language-plaintext highlighter-rouge">Pod</code> 来重新传输接收到的请求数据包。</p>

<p>由于 <code class="language-plaintext highlighter-rouge">kube-proxy</code> 运行在主机的 <code class="language-plaintext highlighter-rouge">Network Namespace</code> 中，因此 <code class="language-plaintext highlighter-rouge">kube-proxy</code> 发送的请求包也会经过 <code class="language-plaintext highlighter-rouge">Service NAT</code> 表。
但是由于<code class="language-plaintext highlighter-rouge">kube-proxy</code>发送的请求包的目标 <code class="language-plaintext highlighter-rouge">IP</code>是<code class="language-plaintext highlighter-rouge">Pod</code>的<code class="language-plaintext highlighter-rouge">IP</code>，所以请求包不会被<code class="language-plaintext highlighter-rouge">Service NAT</code> 表改变，而是通过<code class="language-plaintext highlighter-rouge">CNI Plugin</code>搭建
的<code class="language-plaintext highlighter-rouge">Container Network</code>传递给<code class="language-plaintext highlighter-rouge">Pod</code>。</p>]]></content><author><name>Jony</name></author><category term="gRPC" /><category term="microservices" /><category term="Kubernetes" /><category term="k8s" /><summary type="html"><![CDATA[翻译：Kubernetes Service Proxy]]></summary></entry><entry><title type="html">Kubernetes - 网络专题 - CNI</title><link href="http://localhost:4000/Benjamin.github.io/grpc/2021/10/19/k8s5.html" rel="alternate" type="text/html" title="Kubernetes - 网络专题 - CNI" /><published>2021-10-19T00:42:00+08:00</published><updated>2021-10-19T00:42:00+08:00</updated><id>http://localhost:4000/Benjamin.github.io/grpc/2021/10/19/k8s5</id><content type="html" xml:base="http://localhost:4000/Benjamin.github.io/grpc/2021/10/19/k8s5.html"><![CDATA[<h1 id="cni">CNI</h1>

<p>CNI Container Network Interface 的缩写。就是标准的、通用接口。应用于 Kubernetes、docker、
contained。还有其他网络解决方案。</p>

<p>CNI 的主要工作是从容器管理系统处获取运行信息。包括 network namespace的路径、容器 ID 和 network interface name。再从容器网络的配置文件中加载网络配置信息，再将这些信息传递给对应的插件。由插件进行具体的网络配置工作。</p>

<p>上面的描述总结来说 CNI 用于管理网络插口类似于网管的工作。但是不会介入通信管理。不支持通信。抽象来说像给容器安装网络插口、插上网线、分配IP。</p>

<p>CNI 主要职责：</p>

<ol>
  <li>分配网络插口</li>
</ol>

<p>分配网络插口需要存储到仓库中，仓库唯一键需要包含：network_name、CNI_CONTAINERID、CNI_IFNAME 三元组信息
network namespace 必须要在容器中创建</p>

<ol>
  <li>管理 IP 地址分配。IPAM</li>
</ol>

<p>ADD 操作必须在 DEL 之后，如果没有 DEL　操作，那么如果遇到　三元组冲突应当返回错误信息，不进行分配
DEL　操作应当存在幂等性。</p>

<h1 id="cni-工作模式"><code class="language-plaintext highlighter-rouge">CNI</code> 工作模式</h1>

<p><code class="language-plaintext highlighter-rouge">CNI</code> 接口并不是 <code class="language-plaintext highlighter-rouge">HTTP</code>、<code class="language-plaintext highlighter-rouge">gRPC</code> 接口，<code class="language-plaintext highlighter-rouge">CNI</code> 接口是指对可执行文件的调用。（所以在宿主机上查找 
<code class="language-plaintext highlighter-rouge">CNI</code> 进程可能查找不到）这些可执行程序称之为CNI插件，以<code class="language-plaintext highlighter-rouge">k8s</code>为例，<code class="language-plaintext highlighter-rouge">s8s</code>节点默认的<code class="language-plaintext highlighter-rouge">CNI</code>插件路径为
 <code class="language-plaintext highlighter-rouge">/opt/cni/bin</code></p>]]></content><author><name>Jony</name></author><category term="gRPC" /><category term="microservices" /><category term="Kubernetes" /><category term="k8s" /><summary type="html"><![CDATA[CNI]]></summary></entry></feed>