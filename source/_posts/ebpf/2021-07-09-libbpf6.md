---
title: eBPF的编程艺术:入门 译
date: 2021-07-09 12:44:19
categories: 'eBPF'
tags:
  - ebpf
  - cilium
author: Jony
---

# 用ebpf编写XDP网络过滤器 
原文:[The art of writing eBPF programs: a primer.](https://sysdig.com/blog/the-art-of-writing-ebpf-programs-a-primer/)

对编写eBPF程序感兴趣吗?在这个博客中，这将是我们的重点-编写eBPF程序的过程。现在，我们将深入
研究验证过程和eBPF虚拟机——这两个都是eBPF提供的运行时安全特性的关键促成因素。我们的目标是让您了解不同的部分是如何一起工作的。

我们下面的eBPF练习完全由示例驱动。我们将尝试增量地构建一些代码来拦截系统调用数据。当我们遇到意想不到的错误时，我们将停下来分析下面发生了什么。

关于eBPF有很多需要了解的。我们只会触及表面。编写复杂的eBPF程序需要更多的上下文，而不是我们将在这篇博客中分享的内容。
但是，您当然可以将其视为“入门”。
另外，请记住，使用 [bcc](https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md) 提供的Python/Lua接口编写eBPF程序，或者使用 [bpftrace](https://github.com/iovisor/bpftrace) 提供的高级语言编写eBPF程序，肯定会使过程更加用户友好。
这篇文章的目标是在不抽象太多步骤的情况下找到问题的核心。


# 用eBPF进行系统调用解码

## 第一个实验

在这个例子中，我们将解码一个非常简单和广泛使用的系统调用:openat。
这个系统调用用于在Linux中通过传递文件的路径名来打开文件。系统调用要么返回正确的文件描述符，要么在出错时返回负数。这是它的原型：

```c
int openat(int dirfd, const char *pathname, int flags, mode_t mode);
```

我们的练习包括对系统调用的输入参数进行解码，其中最有趣的是路径名称本身。虽然这似乎是一个相当容易的任务，
但我们将看到在eBPF中编写代码来彻底完成这项工作时隐藏着一些复杂的问题。

我们将写的代码可以从根本上用于任何eBPF项目，只需稍作调整。你可以自由地使用bcc、
一个自定义的eBPF加载器（内核提供了一些例子，如 [bpf_load.c](https://github.com/torvalds/linux/blob/v4.18/samples/bpf/bpf_load.c)，或 [sysdig](https://github.com/draios/sysdig) 本身）进行实验。

让我们从最简单的例子开始:

```c
__attribute__((section("raw_tracepoint/sys_enter"), used))
void bpf_openat_parser()
{
}
```

这里，空函数bpf_openat_parser是我们希望在进入openat系统调用时被执行的。那么它上面的属性呢？那是一个编译器属性，
我们用来告诉 **LLVM** 将 `bpf_openat_parser` 函数的目标代码放入一个单独的 [可执行和可链接格式](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)（ELF）部分，
在最终的目标文件中名为 `raw_tracepoint/sys_enter`。
我们很快就会看到，这是编写`bpf_openat_parser`函数的开发者（我们）和 `sysdig` 进程中的eBPF加载器之间的隐性协议的一部分，
该加载器需要知道它应该把这种eBPF程序附加到哪个系统事件中。

在我们编译程序后（在这种情况下，我使用的是sysdig，所以标准的 "make "就可以了），
**Clang** 和 **LLVM** 将处理源代码并发出一个包含eBPF程序的单一对象文件。在 `sysdig` 的情况下，
这将是在 `driver/bpf/probe.o` 位置。我们知道它是一个ELF文件，所以我们可以检查它的部分。

```bash
$ llvm-readelf -sections driver/bpf/probe.o
There are 203 section headers, starting at offset 0x2d8890:

Section Headers:
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
...
  [179] raw_tracepoint/sys_enter_openat PROGBITS 0000000000000000 1074b8 000008 00  AX  0   0  8
...
```

正如预期的那样，我们可以找到一个以我们放在源代码中的字符串命名的ELF部分。我们也可以检查其内容。

```bash
$ llvm-objdump -no-show-raw-insn -section=raw_tracepoint/sys_enter -S driver/bpf/probe.o
Disassembly of section raw_tracepoint/sys_enter:
bpf_openat_parser:
       0:       exit
```

在这里，我们第一次接触到eBPF字节码。ELF部分包含 `bpf_openat_parser` 函数的eBPF字节码。由于函数为空，
程序由一条指令出口组成，这将终止程序并指示eBPF虚拟机将控制权返回到正常的内核执行流程。


## eBPF 加载器
我们如何运行这个程序?这是 **eBPF加载器** 的责任，它是一个用户空间组件，在`sysdig`中嵌入到 [scap库](https://github.com/draios/sysdig/blob/0.23.1/userspace/libscap/scap_bpf.c#L1195)中。
包含eBPF程序的ELF文件作为输入传递给eBPF加载器，该加载器执行以下操作:

1. 解析ELF部分，并选择以给定关键字开头的部分。例如，sysdig中使用的关键字是 `raw_tracepoint`。
   这向加载器表明，ELF部分包含一个需要附加到 `raw tracepoint` 内核事件的eBPF程序。
   与eBPF程序可以附加到的其他内核事件类型(kprobes、uprobes、跟踪点……)不同，
   `raw tracepoint` 在可用时允许以灵活性为代价获得最佳性能。

2. ELF 部分名称的另一部分将被解释为事件名称。 在我们的例子中，事件名称是 `sys_enter`。 
   这标识了每次完成新的系统调用调用时都会调用的 [原始跟踪点（ `raw tracepoint` ）](https://github.com/torvalds/linux/blob/v4.18/arch/x86/entry/common.c#L127)。 这本质上是内核直接识别为系统事件的字符串，
   可以用来唯一标识它。 通过在主机上运行 perf list 可以轻松浏览支持的跟踪点的完整列表。

3. 一旦内核事件通过验证，eBPF程序就会加载到内核中。这是通过 [bpf系统调用](http://man7.org/linux/man-pages/man2/bpf.2.html)完成的。在此步骤中，
   内核将验证程序是否可以安全运行，并可选择通过JIT进程将其转换为机器码。bpf系统调用将返回一个文件描述符来识别加载的eBPF程序，
   或者返回一个错误。

4. 最后，使用bpf系统调用，或perf_event_open系统调用，取决于 [内核的事件类型](http://man7.org/linux/man-pages/man2/perf_event_open.2.html)，
   eBPF加载器将指示内核将刚刚加载的eBPF程序附加到上一步标识的事件。


整个事情有点棘手，但大部分只是模板。在这之后，我们的程序将在每次事件在内核中触发时被调用。


# eBPF 验证器

现在我们知道发生了什么，我们可以继续运行sysdig，看看我们的eBPF程序是否被正确加载和附加:

```bash
$ sudo sysdig
0: (95) exit
R0 !read_ok
bpf_load_program() err=13 event=sys_enter
```

这并不奏效。这是我们第一次遇到eBPF验证器。验证器告诉我们，程序不能被加载（上面的步骤3），
原因是 **R0** ! 那是什么意思？R0是eBPF的11个虚拟机寄存器之一（R0-R10）。
验证器正在告诉我们，它`不能读取它的值`。这里发生的情况是，我们违反了eBPF程序的要求。
每个eBPF程序在执行结束时必须总是 **返回一个整数值** ，而这个返回值必须存储在R0中。返回值是需要的，
因为大多数时候内核会实际使用程序的返回值，并根据其值采取行动。
例如，如果一个eBPF程序被用来过滤网络数据包，其返回值将被解释为一个布尔值，以放弃/接受数据包。

验证器在这里 **报错**，因为它检测到R0在程序执行过程中从未被写入。它包含 `"垃圾"`。
它通过有效地模拟eBPF程序在运行时可能出现的每一个执行分支来检测。它跟踪每个分支的寄存器的值和类型，确保它们在被读取时被正确初始化。


我们可以通过改变函数原型并返回一个整数来修复第一个错误:

```c
__attribute__((section("raw_tracepoint/sys_enter"), used))
int bpf_openat_parser()
{
    return 0;
}
```

```bash
$ llvm-objdump -no-show-raw-insn -section=raw_tracepoint/sys_enter -S driver/bpf/probe.o 
Disassembly of section raw_tracepoint/sys_enter:
bpf_openat_parser:
       0:       r0 = 0
       1:       exit
```
我们可以看到这一次eBPF程序是如何变成两条指令的。第一个确实在退出前将返回值寄存器初始化为0。如果我们这次运行`sysdigg`，它不会失败。

# eBPF 的内存访问

因为eBPF程序完全是空的，所以这不是特别有用。我们需要实际访问传递给系统调用的参数。为了做到这一点，我们必须引入 "上下文 "的概念。
每个eBPF程序，在启动时，在`R1寄存器`中得到一个指向上下文的指针。上下文基本上是一种结构，
它根据我们`附加eBPF程序`的特定事件类型而具有不同的含义-并且由eBPF虚拟机直接处理。对于我们在本例中使用的**原始跟踪点**，上下文是指向此类型结构的指针：

```c
struct bpf_raw_tracepoint_args {
    __u64 args[0];
};
```
该结构只有一个成员args，它是一个未声明大小的数组，包含在内核中静态调用跟踪点时传递给它的所有参数，
并强制转换为`8字节`的无符号整数。那么系统调用跟踪点的`args`值是多少?我们可以在内核树中搜索`sys_enter` tracepoint的定义，我们会发现这个:

```c
TRACE_EVENT_FN(sys_enter,
    TP_PROTO(struct pt_regs *regs, long id),
…
```
这告诉我们，每次通过`sys_enter` tracepoint 调用我们的eBPF程序时，上下文的前两个参数将包含一个指针，
指向调用时保存的 **CPU寄存器副本(Pt_Regs)** 以及被调用的系统调用的ID。
- 用户级应用程序作为整数寄存器使用，用于传递序列%rdi、%rsi、%rdx、%rcx、%r8和%r9。
- 内核接口使用%rdi、%rsi、%rdx、%r10、%r8和%r9。

这意味着对于我们的openat系统调用，我们将在rsi寄存器中找到路径名称参数（因为它是系统调用的第二个参数），
其形式是指向字符串的指针。rsi自然是存在于传递给我们BPF程序的pt_regs结构中的一个值，我们可以从[内核源](https://github.com/torvalds/linux/blob/v4.18/arch/x86/include/asm/ptrace.h#L73)中看到）。

```c
struct pt_regs {
...
    unsigned long si;
...
```

现在我们有了所有的材料来编写一个更实质性的BPF程序，例如：

```c
__attribute__((section("raw_tracepoint/sys_enter"), used))
int bpf_openat_parser(struct bpf_raw_tracepoint_args *ctx)
{
    unsigned long syscall_id = ctx->args[1];
    volatile struct pt_regs *regs;
    volatile const char *pathname;

    if (syscall_id != __NR_openat)
        return 0;

    regs = (struct pt_regs *)ctx->args[0];
    pathname = (const char *)regs->si;

    return 0;
}
```

注意我们如何从tracepoint参数获取调用的系统调用id，并将其与openat系统调用id进行比较，
后者是固定的，是内核ABI的一部分。然后，我们从第一个tracepoint参数访问寄存器结构，
并使用它的值取消引用si寄存器中保存的路径名参数的值，我们将该值转换为指向字符串的正确指针。
Volatile关键字只是为了确保编译器在生成优化代码期间不会删除这些赋值。

让我们从eBPF字节码的角度来看一下:

```bash
$ llvm-objdump-7 -no-show-raw-insn -section=raw_tracepoint/sys_enter -S driver/bpf/probe.o 
Disassembly of section raw_tracepoint/sys_enter:
bpf_openat_parser:
       0:       r2 = *(u64 *)(r1 + 8)
       1:       if r2 != 257 goto +2 <lbb81_2>
       2:       r1 = *(u64 *)(r1 + 0)
       3:       r1 = *(u64 *)(r1 + 104)

LBB81_2:
       4:       r0 = 0
       5:       exit
</lbb81_2>
```
这里有很多新东西需要分析。特别是:

- **指令0**:对系统调用id进行解引用，它同样是跟踪点参数结构的第二个成员。
  由于参数数组地址存储在R1(上下文)中，第二个成员是通过访问上下文的偏移量8获得的。

- **指令1**:我们比较系统调用id和openat id(257)，如果它们不匹配，我们跳转并退出程序。


- **指令2**:这与指令0相同，不同之处在于这里我们将数组的第一个成员(偏移量为0)从包含pt_regs结构指针的上下文中引用。

- **指令3**:从上一条指令获得的pt_regs结构体中解引用si寄存器的值，该结构体恰好位于偏移量104处。
  所以，R1现在终于包含了指向路径名字符串的指针。

如果我们试着运行这个程序会怎么样？这就是我们得到的：

```bash
$ sudo sysdig
3: (79) r1 = *(u64 *)(r1 +104)
R1 invalid mem access 'inv'
bpf_load_program() err=13 event=sys_enter
```

没有工作。验证者似乎不喜欢**3号**指令。

让我们花点时间思考一下我们想要做的事情。

NOTE： 在指令3中，我们通过取消引用pt_regs结构的指针来访问它。然而，这样做真的安全吗？
NOTE：如果pt_regs为空或指向虚假区域(例如0x42424242)，会发生什么情况？
NOTE： 如果是这种情况，当eBPF虚拟机运行这样的代码时，或者更糟糕的是，当转换后的JIT代码尝试使用本机机器指令进行内存访问时，
我们在内核空间中实际上会得到**无效的内存访问**，这很可能**导致内核崩溃**。
NOTE: 因此，eBPF验证器正在**阻止**我们执行这一潜在的不安全操作。

**`这里的解决方案是使用检查访问，然后正确地解除对潜在不安全内存的定义，我们很快就会看到。`**


NOTE：作为一个小问题，为什么验证器没有让指令0或指令2 报错呢？
NOTE：与指令3一样，这些指令也取消了对内存的引用。
NOTE：不同之处在于，这些指令取消了对上下文结构成员的引用，eBPF验证器知道上下文结构的成员总是被设置为正确的bpf_raw_tracepoint结构。
这永远不会产生崩溃，除非访问中使用的偏移量超过了结构本身的大小，**验证器也会检查结构本身的大小**。
换句话说，eBPF验证器跟踪每个寄存器针对可能执行的每个分支指向的内存，并拒绝可能不安全的访问。理解这一点是轻松编写eBPF程序的关键。

# eBPF 辅助函数

前一个问题的解决方案是通过eBPF帮助器进行检查的内存访问。在标准的虚拟执行环境之上，eBPF还提供了调用一组固定的内核函数(称为eBPF 辅助函数)的可能性。
EBPF帮助器在本地代表eBPF程序执行一些操作。这些函数是用C语言在内核内部实现的，因此是硬编码的，是内核ABI的一部分。
其中一个辅助函数是[`bpf_probe_read`](https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#1-bpf_probe_read)。它可以被认为是一个安全版本的`memcpy`。
您可以向它传递一个任意的内存指针，它将尝试读取这样的内存，而不会崩溃。如果内存不能安全读取，它将简单而安全地返回错误。
它的实现细节非常有趣，并且与Linux中页面错误处理程序的工作方式相关。

这意味着我们可以将BPF程序更改为以下内容：

```c
__attribute__((section("raw_tracepoint/sys_enter"), used))
int bpf_openat_parser(struct bpf_raw_tracepoint_args *ctx)
{
    unsigned long syscall_id = ctx->args[1];
    struct pt_regs *regs;
    const char *pathname;

    if (syscall_id != __NR_openat)
        return 0;

    regs = (struct pt_regs *)ctx->args[0];
    bpf_probe_read(&pathname, sizeof(pathname), &regs->si);

    return 0;
}
```

如您所见，bpf_probe_read的语法非常类似于传统的memcpy。这一次内存访问正常，因为我们使用帮助器取消了对不安全内存的引用。
让我们来看看字节码:

```bash
$ llvm-objdump-7 -no-show-raw-insn -section=raw_tracepoint/sys_enter -S driver/bpf/probe.o 
Disassembly of section raw_tracepoint/sys_enter:
bpf_openat_parser:
       0:       r2 = *(u64 *)(r1 + 8)
       1:       if r2 != 257 goto +6 <lbb81_2>
       2:       r3 = *(u64 *)(r1 + 0)
       3:       r3 += 104
       4:       r1 = r10
       5:       r1 += -8
       6:       r2 = 8
       7:       call 4

LBB81_2:
       8:       r0 = 0
       9:       exit
</lbb81_2>
```

除了2-7范围内的指令外，这一条与前一条相似。这些指令涉及到 call 辅助器，
而我们之前并没有这样的指令。eBPF的调用惯例规定，辅助器函数的参数必须使用寄存器R1-R5，按顺序传递。我们可以对这些指令做如下分析。

- **指令2-3**：R3 被填充为`regs->si`的地址，它表示数据将被复制的地址，就像memcpy（源代码中的第三个参数）。

- **指令4-5**：我们在这里设置r1，它被设置为局部变量**“pathname”**的地址，数据将被复制到这，
   就像memcpy(源代码中的第一个参数)一样。在这里，编译器第一次使用R10。R10是一个特殊的寄存器，
   它由虚拟机自动初始化为eBPF程序的“帧指针”。它指向eBPF程序可以用来存储局部变量的堆栈顶部。
   堆栈大小限制为512字节。这里我们将r1设置为r10-8，这意味着我们为一个8字节的本地堆栈变量保留空间，
   该变量将保存regs->si的内容。
- **指令6**：简单地将r2设置为8，它对应于我们要复制的数据的大小(源代码中的第二个参数)。
- **指令7**：调用辅助器。每个eBPF帮助器都由一个唯一的整数来识别，
     这个整数在内核ABI中通过[枚举](https://github.com/torvalds/linux/blob/v4.18/include/uapi/linux/bpf.h#L2081)来设置。) 我们可以看到**bpf_probe_read**辅助函数的**id是4**。

# 字符串和eBPF

现在我们有了路径名字符串指针，让我们对它做一些事情。通常这涉及到将其值发送到用户空间。
为了做到这一点，首先要做的是把**字符串复制到某个地方**，这样我们就可以把它保存在一个**临时缓冲区**中。
eBPF程序栈似乎是一个承载这个缓冲区的完美地方。由于读取字符串意味着从本质上**解除对内存的引用**，这可能是不安全的，
就像以前一样，我们需要使用另一个辅助工具。

在这种情况下，我们可以使用**[`bpf_probe_read_str`](https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#2-bpf_probe_read_str)**，它与bpf_probe_read类似，只是它是字符串感知的。
这意味着它将在字符串末尾停止，这更有效率（并且它还将**返回复制的字符串的长度**）。
这是一个eBPF辅助函数。

```c
__attribute__((section("raw_tracepoint/sys_enter"), used))
int bpf_openat_parser(struct bpf_raw_tracepoint_args *ctx)
{
    unsigned long syscall_id = ctx->args[1];
    struct pt_regs *regs;
    const char *pathname;
    char buf[64];
    int res;

    if (syscall_id != __NR_openat)
        return 0;

    regs = (struct pt_regs *)ctx->args[0];
    bpf_probe_read(&pathname, sizeof(pathname), &regs->si);
    res = bpf_probe_read_str(buf, sizeof(buf), pathname);

    return 0;
}
```
`bpf_probe_>read_str`的用法非常简单。我们保留一个64字节的局部变量，并将路径名复制到其中。让我们来看看字节码:

```bash
$ llvm-objdump-7 -no-show-raw-insn -section=raw_tracepoint/sys_enter -S driver/bpf/probe.o 
Disassembly of section raw_tracepoint/sys_enter:
bpf_openat_parser:
       0:       r2 = *(u64 *)(r1 + 8)
       1:       if r2 != 257 goto +11 <lbb81_2>
       2:       r3 = *(u64 *)(r1 + 0)
       3:       r3 += 104
       4:       r1 = r10
       5:       r1 += -8
       6:       r2 = 8
       7:       call 4
       8:       r3 = *(u64 *)(r10 - 8)
       9:       r1 = r10
      10:       r1 += -80
      11:       r2 = 64
      12:       call 45

LBB81_2:
      13:       r0 = 0
      14:       exit
</lbb81_2>
```
这看起来也是很直接的。额外的eBPF指令在9-12的范围内，它们只是为bpf_probe_read_str 辅助函数设置适当的参数。
在这种情况下，编译器决定将buf变量放在堆栈中，从地址 **`R10 - 80`** 开始，所以接下来的64个字节将被填充为字符串内容。


如果我们尝试运行此示例，它会起作用。通过使用其他帮助器，比如 [bpf_trace_printk](https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#1-bpf_trace_printk) 或 [bpf_perf_event_output](https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#3-perf_submit)，我们可以把刚刚复制的路径名称打印到内核日志中，或者将其推送到与用户空间共享的**高性能环形缓冲区**。


然而，这个程序有一个重大缺陷。64个字节可能不足以正确容纳完整的路径名称。
在出于系统调用审计目的进行系统调用检测时(就像Falco那样)，处理截断的数据不是很理想。最好是适当地调整临时缓冲区的大小，
以确保它可以容纳更长的路径。我们可以使用常量PATH_MAX，它被扩展到4096，并且应该保持Linux支持的最大路径长度。
但是，如果我们尝试将buf的大小更改为PATH_MAX，则会在编译时收到以下错误：

```bash
error: <unknown>:0:0: in function bpf_openat_parser i32 (%struct.bpf_raw_tracepoint_args*): Looks like the BPF stack limit of 512 bytes is exceeded. Please move large on stack variables into BPF per-cpu array map.
</unknown>
```

记住，eBPF虚拟环境给我们的堆栈只有512字节。在其上保留4096字节的变量肯定会导致堆栈冲突。。
而且，如果程序运行，我们肯定会**覆盖其他内核内存**--所以这是一个不安全的操作。我们很幸运，
编译器这么早就发现了这个问题。即使编译器没有发现它，eBPF验证器也会检测到这种情况，并会阻止程序的加载。

# eBPF maps

我们怎么解决这个问题？我们需要将临时缓冲区存储到**堆栈之外**的不同位置。
EBPF虚拟环境不能让我们像在普通C用户/内核程序中那样分配外部内存或使用全局变量。
然而，我们确实有可能使用**eBPF Map**。EBPF Map 是键/值数据结构，可以通过一组额外的**辅助函数**从eBPF程序访问，并且在调用中是持久的。
内核提供了不同类型的映射(这里[描述](https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#maps)的哈希表、数组等)。我们在这里可以使用的是每`CPU数组映射`。
这样，eBPF程序的每次调用都将获得其自己的 Map 嶆，该时隙可以在整个程序周期内持续使用。
由于eBPF程序在**执行期间**从不被抢占，因此将这些程序存储在每个CPU Map中是安全的，
并且永远不会导致争用条件或损坏的数据。调整后的程序如下所示：

```c
__attribute__((section("maps"), used))
struct bpf_map_def tmp_storage_map = {
    .type = BPF_MAP_TYPE_PERCPU_ARRAY,
    .key_size = sizeof(u32),
    .value_size = PATH_MAX,
    .max_entries = 1,
};

__attribute__((section("raw_tracepoint/sys_enter"), used))
int bpf_openat_parser(struct bpf_raw_tracepoint_args *ctx)
{
    unsigned long syscall_id = ctx->args[1];
    struct pt_regs *regs;
    const char *pathname;
    char *map_value;
    u32 map_id;
    int res;

    if (syscall_id != __NR_openat)
        return 0;

    regs = (struct pt_regs *)ctx->args[0];

    res = bpf_probe_read(&pathname, sizeof(pathname), &regs->si);

    map_id = 0;
    map_value = bpf_map_lookup_elem(&tmp_storage_map, &map_id);
    if (!map_value)
        return 0;

    res = bpf_probe_read_str(map_value, PATH_MAX, pathname);

    return 0;
}
```

这看起来有点复杂，所以我们来分析一下。第一部分是位于单独 ELF 部分中的 Map 定义，
以便eBPF加载器可以正确地检测和设置它（这也发生在bpf系统调用中）。我们可以看到映射被声明为
具有单个条目的 per-cpu 数组类型（这样每个 CPU 将获得自己的单个插槽），并且 Map 的大小是PATH_MAX，
希望足以容纳来自系统调用的完整路径名称。我们可以通过添加其他字段来使之更加丰富，
例如，为其他系统调用参数或进程的pid提供空间。

在`bpf_openat_parser`函数中，我们可以使用[`bpf_map_lookup_elem`](https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#12-maplookup) 辅助函数在运行时获取分配给当时运行eBPF程序的特定CPU的 Map
 槽。如果它为 NULL ，我们也会返回，这样eBPF验证器就不会报错了。

最后，我们可以简单地调用 `bpf_probe_read_str`。但是，我们没有像以前那样将堆栈缓冲区作为目的地指针传递，
而是把 Map 存储区域的指针传给它。我们可以直接将BPF 辅助函数参数指向 Map 区域。



# eBPF中的可变内存访问

该程序运行良好，并得到了校验器的认可。我们只是遗漏了一个棘手的部分，在使用eBPF时知道这一点是很好的。
文档指出，即使目标缓冲区小于原始字符串本身，`bpf_probe_read_str`可以正确地将复制的字符串以NULL结束，
并且它将返回复制的字符串的最终长度(包括NULL)。

为了更安全起见，让我们暂时忘掉自动 NULL 终止，让我们手动终止字符串。我们可以通过如下方式更改 `bpf_probe_read_str` 调用来实现这一点：

```c
res = bpf_probe_read_str(map_value, PATH_MAX, pathname);
    if (res > 0)
        map_value[res - 1] = 0;
```

相当合理的C代码。我们确信helper的返回值为正值时将小于或等于PATH_MAX，因此上面的代码应该是安全的。

然而，校验器不会通过:

```bash
$ sudo sysdig
...
20: (85) call bpf_probe_read_str#45
 R1_w=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R2_w=inv4096 R3_w=inv(id=0) R6=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R10=fp0,call_-1
21: (67) r0 <<= 32
22: (c7) r0 s>>= 32
23: (b7) r1 = 1
24: (6d) if r1 s> r0 goto pc+3
 R0=inv(id=0,umin_value=1,umax_value=9223372036854775807,var_off=(0x0; 0x7fffffffffffffff)) R1=inv1 R6=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R10=fp0,call_-1
25: (0f) r6 += r0
26: (b7) r1 = 0
27: (73) *(u8 *)(r6 -1) = r1
 R0=inv(id=0,umin_value=1,umax_value=9223372036854775807,var_off=(0x0; 0x7fffffffffffffff)) R1_w=inv0 R6_w=map_value(id=0,off=0,ks=4,vs=4096,umin_value=1,umax_value=9223372036854775807,var_off=(0x0; 0x7fffffffffffffff)) R10=fp0,call_-1
R6 unbounded memory access, make sure to bounds check any array access into a map
bpf_load_program() err=13 event=sys_enter
```
这看起来有很多输出需要消化。它实际上很容易通过它，特别是当验证器在验证过程中模拟每条指令后打印寄存器内容的摘要时:

- **指令20**：调用bpf_probe_read_str。调用之后，在R0中有“res”变量。校验器还告诉我们，
   包含该字符串的映射值存储在R1和R6中(查找关键字“R6=MAP_VALUE”和“VS=4096”，表示槽的大小为PATH_MAX)。

- **指令24**：如果“res”为零或更小，我们跳过字符串终止代码，否则就没有意义了。请注意，
   包含“res”变量的R0由标量值(“inv”)类型的验证器标识，由于我们通过了分支检查(“UMIN_VALUE=1”)，因此R0具有适当的下限1，
   但没有已知的上限(“UMAX_VALUE=9223372036854775807”)。换句话说，除非我们进行显式检查，
   否则验证器不会假定有关bpf_probe_read_str帮助器的返回值的任何内容。

- **指令25**：包含“res”变量的R0用作R6的偏移量，R6包含“MAP_VALUE”变量。这条指令将R6设置为相当于C语言的&map_value[res]。

- **指令27**：我们现在取在指令25计算出的值，加上-1的偏移量，然后将0写入该地址所指向的内存。这是我们在POSITION&MAP_VALUE[res-1]位置的明确的NULL终止。


现在希望更清楚了，指令27失败是因为验证器不知道“res”变量的上限，因为它只根据if条件中的下限1进行了检查。
通过使用“res”作为偏移量进行 NULL 终止，我们可能正在进行不安全的内存访问。除了这一次，我们知道一个事实，我们不是，
因为“res”从来不会大于PATH_MAX。不幸的是，校验器并不知道这一点。

**解决方案?帮助验证器理解变量的全部可能范围都在PATH_MAX内。** 我们通过添加传统C代码中不需要的免费检查来做到这一点，例如:

```c
 res = bpf_probe_read_str(map_value, PATH_MAX, pathname);
    if (res > 0 && res <= PATH_MAX)
        map_value[res - 1] = 0;
```

如果你试一下这段代码，你会发现它不起作用，并再次被验证器拒绝，出现类似的错误。
这是由于编译器喜欢以一种校验器还不理解的方式重新排列该分支。在家里尝试验证这种行为，
这就是为什么我们称之为 "编写eBPF程序的艺术"，而不是 "科学":-) 。一个效果更好的解决方案是利用PATH_MAX是2的幂（4096）这一事实，将上界检查尽可能地移到变量被用作偏移量的地方。

```c
res = bpf_probe_read_str(map_value, PATH_MAX, pathname);
    if (res > 0)
        map_value[(res - 1) & (PATH_MAX - 1)] = 0;
```

考虑到我们知道“res”值是正数并且不大于PATH_MAX(由辅助函数保证)，这样做是可行的，并且在语义上与前面更显式的检查相同。
换句话说，我们只是在帮助校验器验证代码。字节码如下所示：

```bash
25: (07) r0 += 4095
26: (57) r0 &= 4095
27: (bf) r1 = r6
28: (0f) r1 += r0
29: (b7) r2 = 0
30: (73) *(u8 *)(r1 +0) = r2
 R0_w=inv(id=0,umax_value=4095,var_off=(0x0; 0xfff)) <br />R1_w=map_value(id=0,off=0,ks=4,vs=4096,umax_value=4095,var_off=(0x0; 0xfff)) R2_w=inv0 <br />R6=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R10=fp0,call_-1
```

我们可以看到，在减去1和按位AND运算4095之后，R0寄存器现在的上限是4095(“UMAX_VALUE=4095)，因此可以安全地用作 Map 值指针的偏移量。

这是 Sysdig 对内核的[另一项改进](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=06c1c049721a995dee2829ad13b24aaf5d7c5cce)，它使处理在验证时不确定大小的数据的过程变得更加容易，这对于系统调用检测至关重要。

现在，让我们将提取的完整路径名打印到内核跟踪日志中，从而结束这段旅程:

```c
    char fmt[] = "path_name:%sn";
    bpf_trace_printk(fmt, sizeof(fmt), map_value);
```
如果我们运行代码，然后观察内核跟踪日志(/sys/kernel/debug/tracing/trace_pipe)，我们会看到:

```bash
htop-1960  [001] .... 20839.191270: 0: path_name:/proc/124286/task
htop-1960  [001] .... 20839.191283: 0: path_name:/proc/124286/statm
htop-1960  [001] .... 20839.191292: 0: path_name:/proc/124286/stat
htop-1960  [001] .... 20839.191308: 0: path_name:/proc/124290/task
htop-1960  [001] .... 20839.191321: 0: path_name:/proc/124290/statm
htop-1960  [001] .... 20839.191331: 0: path_name:/proc/124290/stat
htop-1960  [001] .... 20839.191443: 0: path_name:/proc/loadavg
htop-1960  [001] .... 20839.191472: 0: path_name:/proc/uptime
tmux: server-936   [003] .... 20839.964390: 0: path_name:/proc/124286/cmdline
```
任务完成!

# 总结

这是eBPF系列的第二部分。我们已经直接了解了核心技术如何在引擎盖下工作，以及如何编程。

如前所述，请记住，我们还没有介绍编写eBPF程序的其他几个关键方面，例如不能执行循环，
以及除了跟踪用例之外还可以在eBPF中编写的所有其他程序类型。此外，虽然此内容是静态的，但eBPF肯定不是。
随着每个新内核版本的发布，验证器变得越来越智能，使eBPF程序开发人员的生活变得更轻松。
所以，这个内容在未来的某个时候肯定会过时。如果您想要编写支持第三方用户可能运行的各种内核版本的eBPF程序，
您仍然必须处理这些问题，以便尽可能地向后兼容。

如果您希望看到大量的实际eBPF代码，请随时查看我们的sysdig存储库，并在将来继续关注我们提供的其他eBPF内容。







