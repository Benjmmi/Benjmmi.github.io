I",<h1 id="用ebpf-编写网络监控">用ebpf 编写网络监控</h1>

<p>网络流量将空应该在 raw_tracepoint 监控。
参考文档：<a href="https://lwn.net/Articles/801992/">bpf: revolutionize bpf tracing</a>、<a href="https://lwn.net/Articles/748352/">bpf, tracing: introduce bpf raw tracepoints</a></p>

<p>SO  网络流量监控并不一定要在入口和出口才可以去监控，这里将介绍一个早就已经存在得技术，但是不常见得东东，<code class="language-plaintext highlighter-rouge">kfree_skb</code> 释放 <code class="language-plaintext highlighter-rouge">skb_buff</code> ，
方法名就可以看出用处。</p>

<p>开始之前来复习下如何 trace 内核方法，之前都没有关注过，一直认为不会与内核打交道，看了程序得世界里不会有这种假设了，程序员要死于学习。
分析下现有得程序吧。代码流程应该与前面得类似</p>

<p>猜测中
加载器</p>
<ol>
  <li>指定 BPF 程序</li>
  <li>打开 BPF 程序</li>
  <li>读取 section ，按照 section 读取 program</li>
  <li>attach 到函数入口</li>
  <li>获取所有 map_fd</li>
  <li>pin 住 map</li>
</ol>

<p>BPF 程序</p>
<ol>
  <li>找到入参</li>
  <li>分析入参</li>
  <li>函数返回值是否参与决断，根据情况返回返回值</li>
</ol>

<p>看看简单得如下程序：</p>

<p>minimal.bpf.c</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/bpf.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;bpf/bpf_helpers.h&gt;</span><span class="cp">
</span>
<span class="kt">char</span> <span class="n">LICENSE</span><span class="p">[]</span> <span class="n">SEC</span><span class="p">(</span><span class="s">"license"</span><span class="p">)</span> <span class="o">=</span> <span class="s">"Dual BSD/GPL"</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">my_pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">SEC</span><span class="p">(</span><span class="s">"tp/syscalls/sys_enter_write"</span><span class="p">)</span> <span class="c1">// 指定是 tracepoint:syscalls:sys_enter_write</span>
<span class="kt">int</span> <span class="nf">handle_tp</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>  <span class="c1">// 因为不需要分析参数所以这里就直接使用了 void * 任何参数类型</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">bpf_get_current_pid_tgid</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">my_pid</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">bpf_printk</span><span class="p">(</span><span class="s">"BPF triggered from PID %d.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>大致调用编译得方式如下：</p>

<ol>
  <li>因为程序依赖 libbpf 所以先将 libbpf 编译为库文件</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> .output

<span class="nb">mkdir</span> <span class="nt">-p</span> .output/libbpf

make <span class="nt">-C</span> /home/vagrant/libbpf-bootstrap/libbpf/src <span class="nv">BUILD_STATIC_ONLY</span><span class="o">=</span>1                    <span class="se">\</span>
            <span class="nv">OBJDIR</span><span class="o">=</span>/home/vagrant/libbpf-bootstrap/examples/c/.output//libbpf <span class="nv">DESTDIR</span><span class="o">=</span>/home/vagrant/libbpf-bootstrap/examples/c/.output/                     <span class="se">\</span>
            <span class="nv">INCLUDEDIR</span><span class="o">=</span> <span class="nv">LIBDIR</span><span class="o">=</span> <span class="nv">UAPIDIR</span><span class="o">=</span>                              <span class="se">\</span>
            <span class="nb">install</span>
</code></pre></div></div>

<p>libbpf 安装完成后就可以编译 bpf 程序了</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git pull <span class="o">&amp;&amp;</span> clang <span class="nt">-g</span> <span class="nt">-O2</span> <span class="se">\</span>
<span class="nt">-target</span> bpf <span class="se">\</span>
<span class="nt">-D__TARGET_ARCH_x86</span> <span class="se">\</span>
<span class="nt">-I</span>.output <span class="se">\</span>
<span class="nt">-I</span>../../libbpf/include/uapi <span class="se">\</span>
<span class="nt">-I</span>../../vmlinux/ <span class="se">\</span>
<span class="nt">-idirafter</span> /usr/local/include <span class="se">\</span>
<span class="nt">-idirafter</span> /usr/lib/llvm-11/lib/clang/11.1.0/include <span class="se">\</span>
<span class="nt">-idirafter</span> /usr/include/x86_64-linux-gnu <span class="se">\</span>
<span class="nt">-idirafter</span> /usr/include <span class="se">\</span>
<span class="nt">-c</span> trace_consume_skb.bpf.c <span class="se">\</span>
<span class="nt">-o</span> .output/trace_consume_skb.bpf.o
</code></pre></div></div>

<p>命令参数还是比较容易理解的：目标 bpf 程序，架构：arch x86 架构，连接系统库目录</p>

<p>然后执行下面命令，将目标程序进一步处理：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 裁剪</span>
llvm-strip <span class="nt">-g</span> .output/trace_consume_skb.bpf.o
</code></pre></div></div>

<p>通过 bpftool skel 工具将代码提取生成文件:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/home/vagrant/libbpf-bootstrap/tools/bpftool gen skeleton .output/trace_consume_skb.bpf.o <span class="o">&gt;</span> .output/trace_consume_skb.skel.h
</code></pre></div></div>

<p>编译用户态程序：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 编译用户程序</span>
cc <span class="nt">-g</span> <span class="nt">-Wall</span> <span class="nt">-I</span>.output <span class="nt">-I</span>../../libbpf/include/uapi <span class="nt">-I</span>../../vmlinux/ <span class="nt">-c</span> trace_consume_skb.c <span class="nt">-o</span> .output/trace_consume_skb.o
<span class="c"># 连接目标文件组成可执行文件</span>
cc <span class="nt">-g</span> <span class="nt">-Wall</span> .output/trace_consume_skb.o /home/vagrant/libbpf-bootstrap/examples/c/.output/libbpf.a <span class="nt">-lelf</span> <span class="nt">-lz</span> <span class="nt">-o</span> trace_consume_skb
</code></pre></div></div>

<p>下面就需要着实考虑下 sk_buff 转存到用户空间的实现了。直接看下 trace 的定义：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="n">TRACE_EVENT</span><span class="p">(</span><span class="n">consume_skb</span><span class="p">,</span>

  <span class="n">TP_PROTO</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">),</span>

  <span class="n">TP_ARGS</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>

  <span class="n">TP_STRUCT__entry</span><span class="p">(</span>
    <span class="n">__field</span><span class="p">(</span>  <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">skbaddr</span> <span class="p">)</span>
  <span class="p">),</span>

  <span class="n">TP_fast_assign</span><span class="p">(</span>
    <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">skbaddr</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
  <span class="p">),</span>

  <span class="n">TP_printk</span><span class="p">(</span><span class="s">"skbaddr=%p"</span><span class="p">,</span> <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">skbaddr</span><span class="p">)</span>
<span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div>

<p>consume_skb 的功能就是 sk_buff 正常消费的后进行释放的一个函数。所以我们在上面对其进行了 attach。通过 <code class="language-plaintext highlighter-rouge">TP_PROTO</code>
属性确定参数类型。</p>

<h1 id="参考文档">参考文档</h1>
<p><a href="https://blog.arstercz.com/introduction_to_linux_dynamic_tracing/">Linux 系统动态追踪技术介绍</a></p>

<h1 id="常用命令合集">常用命令合集</h1>

<p>clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I.output -I../../libbpf/include/uapi -I../../vmlinux/ <br />
-idirafter /usr/local/include <br />
-idirafter /usr/lib/llvm-11/lib/clang/11.1.0/include <br />
-idirafter /usr/include/x86_64-linux-gnu <br />
-idirafter /usr/include <br />
-c url_map.bpf.c <br />
-o url_map.bpf.o</p>

<p>cc -g -Wall -I.output -I../../libbpf/include/uapi -I../../vmlinux/ -c url_map_read.c -o .output/url_map_read.o &amp;&amp; cc -g -Wall .output/url_map_read.o /home/vagrant/libbpf-bootstrap/examples/c/.output/libbpf.a -lelf -lz -o url_map_read</p>

<p>cc -g -Wall -I.output -I../../libbpf/include/uapi -I../../vmlinux/ -c url_map.c -o .output/url_map.o &amp;&amp; cc -g -Wall .output/url_map.o /home/vagrant/libbpf-bootstrap/examples/c/.output/libbpf.a -lelf -lz -o url_map</p>

<p>tc filter add dev eth0 ingress bpf da obj url_map.bpf.o sec ingress
tc filter add dev eth0 ingress bpf da obj url_map.bpf.o</p>

<p>sudo tc filter del dev eth0 ingress
sudo ip link set dev eth0 xdp off
sudo tc qdisc del dev eth0 clsact</p>

<p>sudo tc qdisc add dev eth0 clsact
sudo tc qdisc del dev eth0 ingress
sudo ip link set dev eth0 xdp off &amp;&amp; sudo tc qdisc del dev eth0 clsact &amp;&amp; sudo ./url_map</p>

<p>sudo cat /sys/kernel/debug/tracing/trace_pipe</p>

<p>git pull &amp;&amp; clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I.output -I../../libbpf/include/uapi -I../../vmlinux/ -idirafter /usr/local/include -idirafter /usr/lib/llvm-11/lib/clang/11.1.0/include -idirafter /usr/include/x86_64-linux-gnu -idirafter /usr/include -c url_map.bpf.c -o url_map.bpf.o &amp;&amp; sudo ip link set dev eth0 xdp off &amp;&amp; sudo tc qdisc del dev eth0 clsact &amp;&amp; sudo ./url_map</p>

<p>git pull &amp;&amp; cc -g -Wall -I.output -I../../libbpf/include/uapi -I../../vmlinux/ -c url_map_read.c -o .output/url_map_read.o &amp;&amp; cc -g -Wall .output/url_map_read.o /home/vagrant/libbpf-bootstrap/examples/c/.output/libbpf.a -lelf -lz -o url_map_read &amp;&amp; sudo ./url_map_read</p>
:ET