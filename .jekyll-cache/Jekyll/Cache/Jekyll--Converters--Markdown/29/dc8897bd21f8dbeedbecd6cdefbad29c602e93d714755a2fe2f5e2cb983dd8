I"<h1 id="知根知底">知根知底</h1>

<p>Kubernetes，又称为 k8s 或者简称为 “kube” ，是一种可<strong>自动实施</strong> <a href="https://linuxcontainers.org/">Linux 容器</a>操作的开源平台。原先的容器化过程需要很多手动部署和扩展操作。</p>

<p>如果体验不到，那可能是容器化过程在公司以及规模化了，如果个人搭建容器化的过程觉得还不算苦难，
但是如果需要管理亿级、十亿或者更高数量级容器时如何更高效的节省人力。所以 k8s 就是 <code class="language-plaintext highlighter-rouge">DevOps</code> 管理平台，可以提供所需的编排和管理功能，以便您针对这些工作负载大规模部署容器。</p>

<p>历史：Google 每周会启用超过 20 亿个容器——全都由内部平台 Borg 支撑。Borg 是 
<code class="language-plaintext highlighter-rouge">Kubernetes</code> 的前身，多年来开发 Borg 的经验教训成了影响 Kubernetes 中许多技术的主要因素。</p>

<h2 id="常见术语">常见术语</h2>

<ul>
  <li><strong>容器集（Pod）</strong>： k8s 通过将容器分类组成的”容器集” ，Pod 是 Kubernetes 的原子对象</li>
  <li><strong>主机（Master）</strong>：用于控制 Kubernetes 节点的计算机。所有任务分配都来自于此</li>
  <li><strong>节点（Node）</strong>：负责执行请求和所分配任务的计算机。由 Kubernetes 主机负责对节点进行控制</li>
  <li><strong>复制控制器（Replication controller）</strong>：用于控制应在集群某处运行的完全相同的容器集副本数量</li>
  <li><strong>服务（Service）</strong>：将工作内容与容器集分离</li>
  <li><strong>Kubelet</strong>：运行在节点上的服务，可读取容器清单（container manifest），确保指定的容器启动并运行。</li>
</ul>

<h1 id="设计准则">设计准则</h1>

<ul>
  <li><strong>安全</strong>：它应遵循最新的安全最佳实践</li>
  <li><strong>易于使用</strong>：它应能通过一些简单的命令进行操作</li>
  <li><strong>可扩展</strong>：不应偏向于某一个提供商，而是能通过配置文件进行自定义</li>
</ul>

<p>K8s 架构图：
<img src="https://www.redhat.com/cms/managed-files/kubernetes_diagram-v3-770x717_0.svg" alt="架构图" /></p>

<p>架构图显示了各个部分之间的关系：</p>

<h2 id="控制平面">控制平面</h2>

<p>k8s 的神经中枢，主要负责处理重要的工作，以确保容器以足够的梳理和所需的资源运行。控制平面会
一直与<strong>计算机器</strong>保持连接。</p>

<ul>
  <li><strong>kube-apiserver</strong>: 对外提供 REST API 让外部请求与集群进行交互</li>
  <li><strong>kube-scheduler</strong>: 统计各个节点的资源使用情况，计算 Pod 的资源需求并下发到适合的节点</li>
  <li><strong>kube-controller-manager</strong>: 负责实际运行集群，用户查询调度程序确保正确数量的容器集运行</li>
  <li><strong>etcd</strong>: 配置数据以及集群状态的信息存储在 Etcd 中</li>
</ul>

<h2 id="集群机器-节点">集群机器-节点</h2>

<p>Pod 经过调度和编排后，最终由每个节点承载运行。</p>

<ul>
  <li><strong>kubelet</strong>:与控制平面通信的微型应用。kubelet 确保容器在容器集内运行。</li>
  <li><strong>kube-proxy</strong>: 用于优化 kubernetes 网络服务的网络代理。</li>
  <li><strong>容器运行时引擎</strong>: 比如 Docker、由 OCI 标准接口定义</li>
</ul>

<h2 id="其他">其他</h2>

<ul>
  <li><strong>存储仓库</strong>: 持久卷等存储资源</li>
  <li><strong>容器镜像仓库</strong>:存储容器镜像的仓库</li>
</ul>

<h1 id="k8s-创建-pod-运行流程">k8s 创建 Pod 运行流程</h1>

<ol>
  <li>外方客户端通过向 API Server 发起请求</li>
  <li>请求到达 API Server 以后，经过鉴权和验证之后。解析为指定数据格式存储到 Etcd 中</li>
  <li>相关 Reflector 通过控制循环监听 Etcd 中的数据变化，将数据下发到每个 Controller 
继续处理相关数据信息</li>
  <li>Controller 处理完之后，Pod 数据还没有分配节点信息</li>
  <li>Scheduler 是一个单独的控制平面，与 Controller 一样监听数据的变化符合要求之后进行调和</li>
  <li>Scheduler 根据调度算法找出适合的 Node 节点信息，创建 Binding 对象指定 Node 信息
对应到 Pod 的 ObjectReference 字段信息，将信息发送到 kube-apiserver</li>
  <li>API Server 将数据信息设置到指定的 Pod 对象下</li>
  <li>到目前为止，我们看到的所有东西（状态），还只是存在于 etcd 中的元数据</li>
  <li>kubelet 通过监听 kube-apiserver 获取属于本节点的 Pod 列表</li>
  <li>然后与自己本地缓存的 Pod 列表对比，如果有 Pod 创建、删除、更新等操作，就开始同步状态信息</li>
  <li>kubelet 负责后期的 CRI 和 CNI 相关的接口对接，创建符合用户预期的容器实例</li>
</ol>

<h1 id="k8s-内部外部流量处理流程---kube-proxy">k8s 内部/外部流量处理流程 - kube-proxy</h1>

<p>Pod 创建完成之后最终还要要对外提供访问服务，所以 <strong>kube-proxy</strong> 就是默认的流量承载器。虽然目前大多数使用的
是第三方符合 CNI 规范的</p>

<p>根据上面的流程我们大概知道了每个组件的分工和职责。其中核心点就是 Etcd 的数据耦合。总体操作都是每个组件
通过数据约定来约束自己的行为和操作。</p>

<h1 id="参考来源">参考来源</h1>
<ul>
  <li><a href="https://www.redhat.com/zh/topics/containers/kubernetes-architecture">K8s 原理：Kubernetes 架构解析</a></li>
  <li><a href="https://www.redhat.com/zh/topics/containers/what-is-kubernetes">Kubernetes是什么?</a></li>
  <li><a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/implementation-details/">实现细节</a></li>
  <li><a href="https://kubernetes.io/zh/docs/reference/glossary/?fundamental=true">术语表</a></li>
</ul>

:ET