I"
<p><strong>解决动态规划问题最难的地方有两点：</strong></p>

<ul>
  <li>如何定义 f(n)f(n)</li>
  <li>如何通过 f(1)f(1), f(2)f(2), … f(n - 1)f(n−1) 推导出 f(n)f(n)，即状态转移方程</li>
</ul>

<h1 id="分治">分治</h1>

<p>解决分治问题的时候，思路就是想办法把问题的规模减小，有时候减小一个，有时候减小一半，然后将每个小问题的
解以及当前的情况组合起来得出最终的结果。例如归并排序和快速排序，归并排序将要排序的数组平均地分成两半，
快速排序将数组随机地分成两半。然后不断地对它们递归地进行处理。</p>

<p>这里存在有最优的子结构，即原数组的排序结果是在子数组排序的结果上组合出来的，但是<strong>不存在重复子问题</strong>，因为
不断地对待排序的数组进行对半分的时候，两半边的数据并不重叠，分别解决左半边和右半边的两个子问题的时候，
没有子问题重复出现，这是动态规划和分治的区别。</p>

<h1 id="贪心">贪心</h1>
<p>关于最优子结构</p>

<p>贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录
动态规划：全局最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解，因此需要记录之前的所有的局部最优解
关于子问题最优解组合成原问题最优解的组合方式</p>

<p>贪心：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可，这里的最优是贪心意义上
的最优。此时不需要知道一个节点的所有子树情况，于是构不成一棵完整的树
动态规划：动态规划需要对每一个子树求最优解，直至下面的每一个叶子的值，最后得到一棵完整的树，在所有子树都得到最优解后，将他们组合成答案
结果正确性</p>

<p>贪心不能保证求得的最后解是最佳的，复杂度低
动态规划本质是穷举法，可以保证结果是最佳的，复杂度高</p>

<h1 id="线性动态规划简介">线性动态规划简介</h1>
<p>线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。
这里问题规模为 i 的含义是考虑前 i 个元素 [0..i] 时问题的解。
状态定义：<code class="language-plaintext highlighter-rouge">dp[n] := [0..n] 上问题的解</code>
状态转移：<code class="language-plaintext highlighter-rouge">dp[n] = f(dp[n-1], ..., dp[0])</code></p>

<p>按照问题的输入格式，线性动态规划解决的问题主要是单串，双串，矩阵上的问题</p>

:ET