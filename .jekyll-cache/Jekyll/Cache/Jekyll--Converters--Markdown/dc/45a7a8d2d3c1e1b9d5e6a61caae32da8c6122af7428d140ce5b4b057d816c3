I"`}<h2 id="grpc-简单使用">gRPC 简单使用</h2>

<h3 id="protobuf">Protobuf</h3>

<p>Protobuf 是谷歌推出的一宗轻便高效的结构和的数据存储格式，把结构和的数据序列化。常用以存储数据、作为网络通信的数据载体。具有多种编程语言的 API、跨平台和可扩展的特性。比 JSON 、XML 更小解析速度更快、更易于上手。</p>

<h3 id="命令使用">命令使用</h3>

<p>写一个 Proto 文件</p>
<div class="language-proto highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto3"</span><span class="p">;</span>

<span class="k">option</span> <span class="na">java_package</span> <span class="o">=</span> <span class="s">"com.example.grpc"</span><span class="p">;</span>
<span class="k">option</span> <span class="na">java_multiple_files</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="k">option</span> <span class="na">java_outer_classname</span> <span class="o">=</span> <span class="s">"HelloWorldProto"</span><span class="p">;</span>

<span class="kd">message</span> <span class="nc">Greeting</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">HelloResp</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">reply</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">service</span> <span class="n">HelloWorld</span> <span class="p">{</span>
    <span class="k">rpc</span> <span class="n">sayFuchGrpc</span> <span class="p">(</span><span class="n">Greeting</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">HelloResp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>生成 protobuf 类，但是并没有生成 RPC 调用关系，所以还需要继续使用一个命令</p>

<p><code class="language-plaintext highlighter-rouge">protoc --java_out=./ --proto_path=./ helloworld.proto</code></p>

<p>生成 RPC 类，需要使用 <a href="https://repo1.maven.org/maven2/io/grpc/protoc-gen-grpc-java/">protoc-gen-grpc-java</a> ，可以下载适合自己得版本，这里使用得是：<code class="language-plaintext highlighter-rouge">protoc-gen-grpc-java-1.36.0-windows-x86_64.exe</code>
使用命令：</p>

<p><code class="language-plaintext highlighter-rouge">protoc --plugin=protoc-gen-grpc-java="D:/Software/protobuf-3.12.4/protoc-gen-grpc-java-1.36.0-windows-x86_64.exe" --grpc-java_out=./src hello_world.proto</code></p>

<p>将生成：<em>HelloWorldGrpc.java</em> 文件</p>

<p>服务端编写代码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">io.grpc.Server</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.grpc.ServerBuilder</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreeterServer</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">50051</span><span class="o">;</span>
        <span class="nc">Server</span> <span class="n">server</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">server</span> <span class="o">=</span> <span class="nc">ServerBuilder</span><span class="o">.</span><span class="na">forPort</span><span class="o">(</span><span class="n">port</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">addService</span><span class="o">(</span><span class="k">new</span> <span class="nc">GreeterImpl</span><span class="o">())</span>
                    <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">start</span><span class="o">();</span>
            <span class="n">server</span><span class="o">.</span><span class="na">awaitTermination</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="n">server</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"server shutdown"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>客户端编写代码:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">io.grpc.ManagedChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.grpc.ManagedChannelBuilder</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreeterClient</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ManagedChannel</span> <span class="n">channel</span> <span class="o">=</span> <span class="nc">ManagedChannelBuilder</span><span class="o">.</span><span class="na">forAddress</span><span class="o">(</span><span class="s">"127.0.0.1"</span><span class="o">,</span><span class="mi">50051</span><span class="o">).</span><span class="na">usePlaintext</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
        <span class="nc">HelloServiceGrpc</span><span class="o">.</span><span class="na">HelloServiceBlockingStub</span> <span class="n">stub</span>  <span class="o">=</span> <span class="nc">HelloServiceGrpc</span><span class="o">.</span><span class="na">newBlockingStub</span><span class="o">(</span><span class="n">channel</span><span class="o">);</span>
        <span class="nc">HelloResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">stub</span><span class="o">.</span><span class="na">sayFuchGrp</span><span class="o">(</span><span class="nc">HelloRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">setName</span><span class="o">(</span><span class="s">"123456 up shan play triger"</span><span class="o">).</span><span class="na">build</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="n">channel</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>成功输出：
	reply: “123456 up shan play triger:hahahhhaa”</p>

<h2 id="原理剖析">原理剖析</h2>

<p>Client 与 Server ，均通过 Netty Channel 作为数据通信，序列化、反序列化使用 Protobuf，每个请求都将被封装成 HTTP2 得 Stream，在生命周期内，Channel 得应用应该属于长连接，并不需要重复去创建，直至关闭 Channel。目的就是为了<strong>连接复用</strong>提高效率。</p>

<p><em>默认情况下 ServerProvider 使用 Netty 作为服务提供者,即使用 NettyServerBuilder</em></p>

<p>跟踪代码将会看到 <code class="language-plaintext highlighter-rouge">io.grpc.netty.NettyServer</code></p>

<ol>
  <li>创建 <code class="language-plaintext highlighter-rouge">ServerBootstrap</code> ,设定 <code class="language-plaintext highlighter-rouge">BossGroup</code> 和 <code class="language-plaintext highlighter-rouge">WorkerGroup</code> 线程池</li>
  <li>添加 <code class="language-plaintext highlighter-rouge">ChannelFactory</code> ,使用的是 <code class="language-plaintext highlighter-rouge">new ReflectiveChannelFactory&lt;&gt;(epollServerChannelType())</code></li>
  <li>注册 <code class="language-plaintext highlighter-rouge">childHandler</code> ，用来处理客户端连接中的请求帧</li>
  <li>bind 到指定的 <code class="language-plaintext highlighter-rouge">port</code> ，即内部初始化 <code class="language-plaintext highlighter-rouge">ServerSocketChannel</code> 等，开始侦听和接受客户端连接</li>
  <li><code class="language-plaintext highlighter-rouge">BossGroup</code> 中的线程用于 accept 客户端连接，并转发给 <code class="language-plaintext highlighter-rouge">WorkerGroup</code> 中的线程，如果没有指定就会默认 static 共享对下，线程池大小默认为 1</li>
  <li><code class="language-plaintext highlighter-rouge">workerGroup</code> 中的特定线程用于初始化客户端连接，初始化 <code class="language-plaintext highlighter-rouge">pipeline</code> 和 <code class="language-plaintext highlighter-rouge">handler</code> ，并将其注册到 <code class="language-plaintext highlighter-rouge">worker</code> 线程的 <code class="language-plaintext highlighter-rouge">selector</code> 上。每个 <code class="language-plaintext highlighter-rouge">worker</code> 线程独占一个 <code class="language-plaintext highlighter-rouge">selector</code>。默认大小 coreSize*2</li>
  <li><code class="language-plaintext highlighter-rouge">selector</code> 上发送读写时间后，获取时间所属的连接句柄，然后指定 <code class="language-plaintext highlighter-rouge">handler（inbound）</code> ，同时拆分 <code class="language-plaintext highlighter-rouge">package</code> 。<code class="language-plaintext highlighter-rouge">handler</code> 执行完毕后，数据写入有 <code class="language-plaintext highlighter-rouge">outbound handler</code> 处理通过连接发出。</li>
  <li><code class="language-plaintext highlighter-rouge">channelType</code>：默认为 <code class="language-plaintext highlighter-rouge">NioServerSocketChannel</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">followControlWindow</code>：流量控制的窗口大小，单位：字节，默认值为 1M HTTP2 中的 <code class="language-plaintext highlighter-rouge">Flow Control</code> 特性</li>
  <li><code class="language-plaintext highlighter-rouge">maxConcurrentCallPerConnection</code>：每个 connection 允许的最大并发请求书，默认值为 Integer.MAX_VALUE；标识此连接的未响应的 streams 个数的上限</li>
  <li><code class="language-plaintext highlighter-rouge">maxMessageSize</code> ：每次调用允许发送的最大数据量，默认为 100M</li>
  <li><code class="language-plaintext highlighter-rouge">maxHeaderListSize</code>：每次调用允许发送的 header 的最大条数据，默认 8192</li>
  <li><code class="language-plaintext highlighter-rouge">protocolNegotiator</code>：协议协商工具类，用于支持 SSL、TLS 工具类。默认情况下：PlaintextProtocolNegotiator 使用的仍然是 HTTP 协议</li>
</ol>

<p><strong><em>注意：每个 <code class="language-plaintext highlighter-rouge">worker</code> 线程上的数据请求时是队列形式</em></strong>
<strong><em>Channel 是 NIO 的基本构造，代表的一个实体，可以看作传入或者传出的数据载体。因此可以被打开或者关闭、连接或者断开</em></strong></p>

<h2 id="addservice-的作用">addService 的作用</h2>

<p>addService 使用的是代理模式，每个 <code class="language-plaintext highlighter-rouge">gRPC</code> 生成的 Service 都有 <code class="language-plaintext highlighter-rouge">bindService</code> 方法。<code class="language-plaintext highlighter-rouge">gRPC</code>  通过硬编码的方式遍历这个 <code class="language-plaintext highlighter-rouge">service</code> 列表，将每个方法的调用过程都与<code class="language-plaintext highlighter-rouge">“被代理实例”</code>绑定。<code class="language-plaintext highlighter-rouge">bingService</code> 方法的最终目的是创建一个 <code class="language-plaintext highlighter-rouge">ServerServiceDefinition</code> 对象，内部创建了一个 <code class="language-plaintext highlighter-rouge">Map</code> ，<code class="language-plaintext highlighter-rouge">KEY</code> 就是 <code class="language-plaintext highlighter-rouge">Service</code>  方法的全名 <code class="language-plaintext highlighter-rouge">{package}.{service}.{method}</code>，value 就是这个方法的 gRPC 封装类。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">...</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">HelloServiceImplBase</span> <span class="n">serviceImpl</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">methodId</span><span class="o">;</span>

    <span class="nc">MethodHandlers</span><span class="o">(</span><span class="nc">HelloServiceImplBase</span> <span class="n">serviceImpl</span><span class="o">,</span> <span class="kt">int</span> <span class="n">methodId</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">serviceImpl</span> <span class="o">=</span> <span class="n">serviceImpl</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">methodId</span> <span class="o">=</span> <span class="n">methodId</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">...</span>
    <span class="nd">@Override</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Req</span> <span class="n">request</span><span class="o">,</span> <span class="n">io</span><span class="o">.</span><span class="na">grpc</span><span class="o">.</span><span class="na">stub</span><span class="o">.</span><span class="na">StreamObserver</span><span class="o">&lt;</span><span class="nc">Resp</span><span class="o">&gt;</span> <span class="n">responseObserver</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">switch</span> <span class="o">(</span><span class="n">methodId</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nl">METHODID_SAY_FUCH_GRP:</span>
          <span class="n">serviceImpl</span><span class="o">.</span><span class="na">sayFuchGrp</span><span class="o">((</span><span class="nc">HelloRequest</span><span class="o">)</span> <span class="n">request</span><span class="o">,</span>
              <span class="o">(</span><span class="n">io</span><span class="o">.</span><span class="na">grpc</span><span class="o">.</span><span class="na">stub</span><span class="o">.</span><span class="na">StreamObserver</span><span class="o">&lt;</span><span class="nc">HelloResponse</span><span class="o">&gt;)</span> <span class="n">responseObserver</span><span class="o">);</span>
          <span class="k">break</span><span class="o">;</span>
        <span class="k">default</span><span class="o">:</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">...</span>

    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kd">final</span> <span class="n">io</span><span class="o">.</span><span class="na">grpc</span><span class="o">.</span><span class="na">ServerServiceDefinition</span> <span class="nf">bindService</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">io</span><span class="o">.</span><span class="na">grpc</span><span class="o">.</span><span class="na">ServerServiceDefinition</span><span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="n">getServiceDescriptor</span><span class="o">())</span>
          <span class="o">.</span><span class="na">addMethod</span><span class="o">(</span>
            <span class="n">getSayFuchGrpMethod</span><span class="o">(),</span>
            <span class="n">io</span><span class="o">.</span><span class="na">grpc</span><span class="o">.</span><span class="na">stub</span><span class="o">.</span><span class="na">ServerCalls</span><span class="o">.</span><span class="na">asyncUnaryCall</span><span class="o">(</span>
              <span class="k">new</span> <span class="nc">MethodHandlers</span><span class="o">&lt;</span>
                <span class="nc">HelloRequest</span><span class="o">,</span>
                <span class="nc">HelloResponse</span><span class="o">&gt;(</span>
                  <span class="k">this</span><span class="o">,</span> <span class="no">METHODID_SAY_FUCH_GRP</span><span class="o">)))</span>
          <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">addService</code> 方法可以添加多个 <code class="language-plaintext highlighter-rouge">Service</code>，代表 Netty Server 可以添加多个 <code class="language-plaintext highlighter-rouge">Service</code>。<code class="language-plaintext highlighter-rouge">addService</code> 会把 service 保存在内部的一个 map 中，key 为 serviceName ，value 就是上述 bindService 生成的对象。</p>

<p>既然对象都已经生成存储到 Map 中，那么 <code class="language-plaintext highlighter-rouge">gRPC</code> 服务端是如何解析 RPC 过程的？client 在调用的收会将调用的 <code class="language-plaintext highlighter-rouge">service</code> 名词 + <code class="language-plaintext highlighter-rouge">method</code> 信息保存在一个 <code class="language-plaintext highlighter-rouge">GRPC 保留</code> 的 header 中，那么服务端在接收到 stream （PS：h2c 中每个 stream 相当于一个请求）之后，通过获取这个特定 Header 信息，就可以知道这个 stream 要调用的相应的方法，然后就使用到来上诉的 service ，然后找个相应的方法，直接代理调用。然后返回执行结果。</p>

<h2 id="client-使用">Client 使用</h2>

<p>Client 使用 <code class="language-plaintext highlighter-rouge">ManagedChannelBuilder</code> 的 <code class="language-plaintext highlighter-rouge">provider</code>机制来决定创建哪种类型的客户端的 <code class="language-plaintext highlighter-rouge">Channel</code>（<code class="language-plaintext highlighter-rouge">NettyChannelBuilder</code> 和 <code class="language-plaintext highlighter-rouge">OkHttpChannelBuilder</code>）。</p>

<p>通常情况下 Channel 是可以复用的，所以为了提高 Client 端的并发能力，我们可以创建连接池即多个 <code class="language-plaintext highlighter-rouge">ManagedChannel</code>，每次请求时选择其中一个 Channel 即可。</p>

<p><code class="language-plaintext highlighter-rouge">ManagedChannel</code> 是客户端最核心的 class，代表这逻辑上的 <code class="language-plaintext highlighter-rouge">channel</code>，底层持有一个物理的 <code class="language-plaintext highlighter-rouge">transport</code>，并负责维护当检测到其处于 <code class="language-plaintext highlighter-rouge">terminated</code> 的时候会重新创建。</p>

<p>每个 Client SDK 都生成了 2 中 stub：BlockingStub 和 FutureStub； BlockingStub 内部仍然使用的是 Future 机制，只是内部封装了<strong>阻塞等待</strong>的过程：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="nc">ReqT</span><span class="o">,</span> <span class="nc">RespT</span><span class="o">&gt;</span> <span class="nc">RespT</span> <span class="nf">blockingUnaryCall</span><span class="o">(</span>
      <span class="nc">Channel</span> <span class="n">channel</span><span class="o">,</span> <span class="nc">MethodDescriptor</span><span class="o">&lt;</span><span class="nc">ReqT</span><span class="o">,</span> <span class="nc">RespT</span><span class="o">&gt;</span> <span class="n">method</span><span class="o">,</span> <span class="nc">CallOptions</span> <span class="n">callOptions</span><span class="o">,</span> <span class="nc">ReqT</span> <span class="n">req</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ThreadlessExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadlessExecutor</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="n">interrupt</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">ClientCall</span><span class="o">&lt;</span><span class="nc">ReqT</span><span class="o">,</span> <span class="nc">RespT</span><span class="o">&gt;</span> <span class="n">call</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="na">newCall</span><span class="o">(</span><span class="n">method</span><span class="o">,</span>
        <span class="n">callOptions</span><span class="o">.</span><span class="na">withOption</span><span class="o">(</span><span class="nc">ClientCalls</span><span class="o">.</span><span class="na">STUB_TYPE_OPTION</span><span class="o">,</span> <span class="nc">StubType</span><span class="o">.</span><span class="na">BLOCKING</span><span class="o">)</span>
            <span class="o">.</span><span class="na">withExecutor</span><span class="o">(</span><span class="n">executor</span><span class="o">));</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="nc">ListenableFuture</span><span class="o">&lt;</span><span class="nc">RespT</span><span class="o">&gt;</span> <span class="n">responseFuture</span> <span class="o">=</span> <span class="n">futureUnaryCall</span><span class="o">(</span><span class="n">call</span><span class="o">,</span> <span class="n">req</span><span class="o">);</span>
		<span class="o">...</span>
      <span class="k">return</span> <span class="nf">getUnchecked</span><span class="o">(</span><span class="n">responseFuture</span><span class="o">);</span>
  <span class="o">}</span>


  <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="no">V</span> <span class="nf">getUnchecked</span><span class="o">(</span><span class="nc">Future</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
      <span class="k">throw</span> <span class="nc">Status</span><span class="o">.</span><span class="na">CANCELLED</span>
          <span class="o">.</span><span class="na">withDescription</span><span class="o">(</span><span class="s">"Thread interrupted"</span><span class="o">)</span>
          <span class="o">.</span><span class="na">withCause</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
          <span class="o">.</span><span class="na">asRuntimeException</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="nf">toStatusRuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCause</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>目前每次发起请求时都是通过 <code class="language-plaintext highlighter-rouge">channel</code> 创建新的 <code class="language-plaintext highlighter-rouge">Stub</code>，这会导致创建大量的 <code class="language-plaintext highlighter-rouge">Stub</code> 对象，当然 <code class="language-plaintext highlighter-rouge">Stub</code> 对象也是可以复用的，直到 Stub 状态异常。每个 Stub 都配置 deadline 时间，那么如果此 Stub 被使用的时长超过这个阈值，将会抛出 <strong><em>io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED</em></strong> 异常。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">static</span> <span class="n">io</span><span class="o">.</span><span class="na">grpc</span><span class="o">.</span><span class="na">Channel</span> <span class="nf">resetChannel</span><span class="o">(</span><span class="n">io</span><span class="o">.</span><span class="na">grpc</span><span class="o">.</span><span class="na">ManagedChannel</span> <span class="n">channel</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">channel</span><span class="o">.</span><span class="na">isShutdown</span><span class="o">()</span> <span class="o">||</span> <span class="n">channel</span><span class="o">.</span><span class="na">isTerminated</span><span class="o">()){</span>
      <span class="k">return</span> <span class="nc">ManagedChannelBuilder</span><span class="o">.</span><span class="na">forAddress</span><span class="o">(</span><span class="no">HOST</span><span class="o">,</span> <span class="no">PORT</span><span class="o">).</span><span class="na">usePlaintext</span><span class="o">(</span><span class="kc">true</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">channel</span><span class="o">;</span>
  <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ManagedChannel</span> <span class="n">channel</span> <span class="o">=</span> <span class="nc">ManagedChannelBuilder</span><span class="o">.</span><span class="na">forAddress</span><span class="o">(</span><span class="s">"127.0.0.1"</span><span class="o">,</span><span class="mi">50051</span><span class="o">).</span><span class="na">usePlaintext</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
        <span class="n">resetChannel</span><span class="o">(</span><span class="n">channel</span><span class="o">)</span>
        <span class="nc">HelloServiceGrpc</span><span class="o">.</span><span class="na">HelloServiceBlockingStub</span> <span class="n">stub</span>  <span class="o">=</span> <span class="nc">HelloServiceGrpc</span><span class="o">.</span><span class="na">newBlockingStub</span><span class="o">(</span><span class="n">channel</span><span class="o">);</span>
        <span class="nc">HelloResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">stub</span><span class="o">.</span><span class="na">sayFuchGrp</span><span class="o">(</span><span class="nc">HelloRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">setName</span><span class="o">(</span><span class="s">"123456 up shan play triger"</span><span class="o">).</span><span class="na">build</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="n">channel</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>对于批量调用的场景，建议使用 FutureStub，对于普通的业务类型 RPC，我们使用 BlockingStub。每个 RPC 方法的调用一开始都会创建一个 <strong>ClientCall</strong>，其内部封装了调用的方法、配置等。此后将会创建 Stream 对象，每个 Stream 对象都持有唯一的 streamId，它是 Transport 用于区分 Response 的凭证。最终所有调用的参数都封装在 Stream 中。在大多数的 RPC 调用中，请求参数报文都是分多次发送，所以 ClientCall 在创建时就已经绑定线程，所以数据发送总是哦他难过一个线程进行的所以不会有乱序的现象。同样在等待 Response 时，底层的 Netty 将会对 Response 报文进行解包，并根据 streamId <strong>分拣</strong> Response，同时唤醒相应的 ClientCalls 阻塞。</p>

<p><strong>注意：如果出现网络异常将会重置 Channel、StreamId</strong></p>

<h1 id="参考文档">参考文档</h1>
<p><a href="http://www.iigrowing.cn/grpc_shi_shen_me.html">gRPC 是什么</a>
<a href="https://blog.csdn.net/u010129119/article/details/79361949#1-%E7%AE%80%E4%BB%8B">HTTP/2 协议规范</a>
<a href="https://www.jianshu.com/p/e57ca4fec26f">HTTP2 详解</a>
<a href="https://segmentfault.com/u/yongshun/articles">永顺 专栏</a></p>

:ET