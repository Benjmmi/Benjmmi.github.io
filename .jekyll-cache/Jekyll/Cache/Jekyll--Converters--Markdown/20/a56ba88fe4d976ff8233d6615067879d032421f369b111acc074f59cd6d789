I"|<h1 id="工具链">工具链</h1>

<hr />

<p>本节介绍 BPF 相关的用户态工具、内省设施（introspection facilities）和内核控制选项。 注意，围绕 BPF 的工具和基础设施还在快速发展当中，因此本文提供的内容可能只覆 盖了其中一部分。</p>

<h3 id="ubuntu">Ubuntu</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> make gcc libssl-dev bc libelf-dev libcap-dev <span class="se">\</span>
  clang gcc-multilib llvm libncurses5-dev git pkg-config libmnl-dev bison flex <span class="se">\</span>
  graphviz
</code></pre></div></div>

<h1 id="22-llvm">2.2 LLVM</h1>

<p>写作本文时，LLVM 是唯一提供 BPF 后端的编译器套件。gcc 目前还不支持。</p>

<p>主流的发行版在对 LLVM 打包的时候就默认启用了 BPF 后端，因此，在大部分发行版上安 装 clang 和 llvm 就可以将 C 代码编译为 BPF 对象文件了。</p>

<p>典型的工作流是：</p>

<ol>
  <li>用 C 编写 BPF 程序</li>
  <li>用 LLVM 将 C 程序编译成对象文件（ELF）</li>
  <li>用户空间 BPF ELF 加载器（例如 iproute2）解析对象文件</li>
  <li>加载器通过 bpf() 系统调用将解析后的对象文件注入内核</li>
  <li>内核验证 BPF 指令，然后对其执行即时编译（JIT），返回程序的一个新文件描述符</li>
  <li>利用文件描述符 attach 到内核子系统（例如网络子系统）</li>
</ol>

<p>某些子系统还支持将 BPF 程序 offload 到硬件（例如网卡）。</p>

<h2 id="221-bpf-target目标平台">2.2.1 BPF Target（目标平台）</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>llc <span class="nt">--version</span>
LLVM <span class="o">(</span>http://llvm.org/<span class="o">)</span>:
LLVM version 3.8.1
Optimized build.
Default target: x86_64-unknown-linux-gnu
Host CPU: skylake

Registered Targets:
  <span class="o">[</span>...]
  bpf        - BPF <span class="o">(</span>host endian<span class="o">)</span>
  bpfeb      - BPF <span class="o">(</span>big endian<span class="o">)</span>
  bpfel      - BPF <span class="o">(</span>little endian<span class="o">)</span>
  <span class="o">[</span>...]
</code></pre></div></div>

<p><strong>默认情况下，bpf target 使用编译时所在的 CPU 的大小端格式</strong> ，即，如果 CPU 是小 端，BPF 程序就会用小端表示；如果 CPU 是大端，BPF 程序就是大端。这也和 BPF 的运 行时行为相匹配，这样的行为比较通用，而且大小端格式一致可以避免一些因为格式导致的 架构劣势。</p>

<p>BPF 程序可以在大端节点上编译，在小端节点上运行，或者相反，因此对于 <strong>交叉编译</strong> ， 引入了两个新目标 <code class="language-plaintext highlighter-rouge">bpfeb</code> 和 <code class="language-plaintext highlighter-rouge">bpfel</code>。注意前端也需要以相应的大小端方式运行。</p>

<p>在不存在大小端混用的场景下，建议使用 bpf target。例如，在 x86_64 平台上（小端 ），指定 bpf 和 bpfel 会产生相同的结果，因此触发编译的脚本不需要感知到大小端 。</p>

<p>下面是一个最小的完整 XDP 程序，实现丢弃包的功能（xdp-example.c）：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/bpf.h&gt;</span><span class="cp">
</span>
<span class="cp">#ifndef __section
# define __section(NAME)                  \
   __attribute__((section(NAME), used))
#endif
</span>
<span class="n">__section</span><span class="p">(</span><span class="s">"prog"</span><span class="p">)</span>
<span class="kt">int</span> <span class="nf">xdp_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdp_md</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">XDP_DROP</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">__license</span><span class="p">[]</span> <span class="n">__section</span><span class="p">(</span><span class="s">"license"</span><span class="p">)</span> <span class="o">=</span> <span class="s">"GPL"</span><span class="p">;</span>
</code></pre></div></div>

<p>用下面的命令编译并加载到内核：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-O2</span> <span class="nt">-Wall</span> <span class="nt">-target</span> bpf <span class="nt">-c</span> xdp-example.c <span class="nt">-o</span> xdp-example.o
<span class="nv">$ </span>ip <span class="nb">link set </span>dev em1 xdp obj xdp-example.o
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 注意
以上命令将一个 XDP 程序 attach 到一个网络设备，需要是 Linux 4.11 内核中支持 XDP 的设备，或者 4.12+ 版本的内核。
</code></pre></div></div>

<p>LLVM（&gt;= 3.9） 使用正式的 BPF 机器值（machine value），即 EM_BPF（十进制 247 ，十六进制 0xf7），来生成对象文件。在这个例子中，程序是用 bpf target 在 x86_64 平台上编译的，因此下面显示的大小端标识是 LSB (和 MSB 相反)：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>file xdp-example.o
xdp-example.o: ELF 64-bit LSB relocatable, <span class="k">*</span>unknown <span class="nb">arch </span>0xf7<span class="k">*</span> version 1 <span class="o">(</span>SYSV<span class="o">)</span>, not stripped
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">readelf -a xdp-example.o</code> 能够打印 ELF 文件的更详细信息，有时在检查生成的 section header、relocation entries 和符号表时会比较有用。</p>

<hr />

<h1 id="222-调试信息dwarfbtf">2.2.2 调试信息（<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a>、BTF）</h1>

<p>若是要 debug，clang 可以生成下面这样的汇编器输出：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-O2</span> <span class="nt">-S</span> <span class="nt">-Wall</span> <span class="nt">-target</span> bpf <span class="nt">-c</span> xdp-example.c <span class="nt">-o</span> xdp-example.S
<span class="nv">$ </span><span class="nb">cat </span>xdp-example.S
    .text
    .section    prog,<span class="s2">"ax"</span>,@progbits
    .globl      xdp_drop
    .p2align    3
xdp_drop:                             <span class="c"># @xdp_drop</span>
<span class="c"># BB#0:</span>
    r0 <span class="o">=</span> 1
    <span class="nb">exit</span>

    .section    license,<span class="s2">"aw"</span>,@progbits
    .globl    __license               <span class="c"># @__license</span>
__license:
    .asciz    <span class="s2">"GPL"</span>
</code></pre></div></div>

<p>LLVM 从 6.0 开始，还包括了汇编解析器（assembler parser）的支持。你可以直接使用 BPF 汇编指令编程，然后使用 llvm-mc 将其汇编成一个目标文件。例如，你可以将前面 的 xdp-example.S 重新变回对象文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>llvm-mc <span class="nt">-triple</span> bpf <span class="nt">-filetype</span><span class="o">=</span>obj <span class="nt">-o</span> xdp-example.o xdp-example.S
</code></pre></div></div>

<h1 id="dwarf-格式和-llvm-objdump"><a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 格式和 llvm-objdump</h1>

<p>另外，较新版本（&gt;= 4.0）的 LLVM 还可以将调试信息以 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a> 格式存储到对象文件中。 只要在编译时加上 -g：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-O2</span> <span class="nt">-g</span> <span class="nt">-Wall</span> <span class="nt">-target</span> bpf <span class="nt">-c</span> xdp-example.c <span class="nt">-o</span> xdp-example.o
<span class="nv">$ </span>llvm-objdump <span class="nt">-S</span> <span class="nt">-no-show-raw-insn</span> xdp-example.o

xdp-example.o:        file format ELF64-BPF

Disassembly of section prog:
xdp_drop:
<span class="p">;</span> <span class="o">{</span>
    0:        r0 <span class="o">=</span> 1
<span class="p">;</span> <span class="k">return </span>XDP_DROP<span class="p">;</span>
    1:        <span class="nb">exit</span>
</code></pre></div></div>
<p>llvm-objdump 工具能够用编译的 C 源码对汇编输出添加注解（annotate ）。这里 的例子过于简单，没有几行 C 代码；但注意上面的 0 和 1 行号，这些行号直接对 应到内核的校验器日志（见下面的输出）。这意味着假如 BPF 程序被校验器拒绝了， llvm-objdump能帮助你将 BPF 指令关联到原始的 C 代码，对于分析来说非常有用。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ip <span class="nb">link set </span>dev em1 xdp obj xdp-example.o verb

Prog section <span class="s1">'prog'</span> loaded <span class="o">(</span>5<span class="o">)!</span>
 - Type:         6
 - Instructions: 2 <span class="o">(</span>0 over limit<span class="o">)</span>
 - License:      GPL

Verifier analysis:

0: <span class="o">(</span>b7<span class="o">)</span> r0 <span class="o">=</span> 1
1: <span class="o">(</span>95<span class="o">)</span> <span class="nb">exit
</span>processed 2 insns
</code></pre></div></div>

<p>从上面的校验器分析可以看出，llvm-objdump 的输出和内核中的 BPF 汇编是相同的。</p>

<p>去掉 -no-show-raw-insn 选项还可以以十六进制格式在每行汇编代码前面打印原始的 struct bpf_insn：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>llvm-objdump <span class="nt">-S</span> xdp-example.o

xdp-example.o:        file format ELF64-BPF

Disassembly of section prog:
xdp_drop:
<span class="p">;</span> <span class="o">{</span>
   0:       b7 00 00 00 01 00 00 00     r0 <span class="o">=</span> 1
<span class="p">;</span> <span class="k">return </span>foo<span class="o">()</span><span class="p">;</span>
   1:       95 00 00 00 00 00 00 00     <span class="nb">exit</span>
</code></pre></div></div>

<h3 id="llvm-ir">LLVM IR</h3>

<p>对于 LLVM IR 调试，BPF 的编译过程可以分为两个步骤：首先生成一个二进制 LLVM IR 临 时文件 xdp-example.bc，然后将其传递给 <code class="language-plaintext highlighter-rouge">llc</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-O2</span> <span class="nt">-Wall</span> <span class="nt">-target</span> bpf <span class="nt">-emit-llvm</span> <span class="nt">-c</span> xdp-example.c <span class="nt">-o</span> xdp-example.bc
<span class="nv">$ </span>llc xdp-example.bc <span class="nt">-march</span><span class="o">=</span>bpf <span class="nt">-filetype</span><span class="o">=</span>obj <span class="nt">-o</span> xdp-example.o
</code></pre></div></div>

<p>生成的 LLVM IR 还可以 dump 成人类可读的格式：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-O2</span> <span class="nt">-Wall</span> <span class="nt">-emit-llvm</span> <span class="nt">-S</span> <span class="nt">-c</span> xdp-example.c <span class="nt">-o</span> -
</code></pre></div></div>

<h2 id="btf">BTF</h2>

<p>LLVM 能将调试信息（例如对程序使用的数据的描述）attach 到 BPF 对象文件。默认情况 下使用 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 格式。</p>

<p>BPF 使用了一个高度简化的版本，称为 <strong>BTF</strong> (BPF Type Format)。生成的 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 可以 转换成 BTF 格式，然后通过 BPF 对象加载器加载到内核。内核验证 BTF 数据的正确性， 并跟踪 BTF 数据中包含的数据类型。</p>

<p>这样的话，就可以用键和值对 BPF map 打一些注解（annotation）存储到 BTF 数据中，这 样下次 dump map 时，除了 map 内的数据外还会打印出相关的类型信息。这对内省（ introspection）、调试和格式良好的打印都很有帮助。注意，BTF 是一种通用的调试数据 格式，因此任何从 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 转换成的 BTF 数据都可以被加载（例如，内核 vmlinux <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 数 据可以转换成 BTF 然后加载）。后者对于未来 BPF 的跟踪尤其有用。</p>

<p>将 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 格式的调试信息转换成 BTF 格式需要用到 <code class="language-plaintext highlighter-rouge">elfutils</code> (&gt;= 0.173) 工具。 如果没有这个工具，那需要在 <code class="language-plaintext highlighter-rouge">llc</code> 编译时打开 <code class="language-plaintext highlighter-rouge">-mattr=[dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction)ris</code> 选项：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>llc <span class="nt">-march</span><span class="o">=</span>bpf <span class="nt">-mattr</span><span class="o">=</span><span class="nb">help</span> |&amp; <span class="nb">grep</span> <span class="o">[</span>dwarf]<span class="o">(</span>http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction<span class="o">)</span>ris
<span class="o">[</span>dwarf]<span class="o">(</span>http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction<span class="o">)</span>ris - Disable MCAsmInfo <span class="o">[</span>Dwarf]<span class="o">(</span>http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction<span class="o">)</span>UsesRelocationsAcrossSections.
<span class="o">[</span>...]
</code></pre></div></div>

<p>使用 -mattr=<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris 是因为 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris (<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a> relocation in section) 选项禁 用了 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 和 ELF 的符号表之间的 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> cross-section 重定位，因为 libdw 不支持 BPF 重定位。不打开这个选项的话，pahole 这类工具将无法正确地从对象中 dump 结构。</p>

<p>elfutils (&gt;= 0.173) 实现了合适的 BPF 重定位，因此没有打开 -mattr=<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris 选 项也能正常工作。它可以从对象文件中的 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 或 BTF 信息 dump 结构。目前 pahole 使用 LLVM 生成的 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 信息，但未来它可能会使用 BTF 信息。</p>

<h2 id="pahole-注pahole-一种代码审计工具">pahole (注：pahole 一种代码审计工具)</h2>

<p>将 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 转换成 BTF 格式需要使用较新的 pahole 版本（&gt;= 1.12），然后指定 -J 选项。 检查所用的 pahole 版本是否支持 BTF（注意，pahole 会用到 llvm-objcopy，因此 也要检查后者是否已安装）：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pahole <span class="nt">--help</span> | <span class="nb">grep </span>BTF
<span class="nt">-J</span>, <span class="nt">--btf_encode</span>           Encode as BTF
</code></pre></div></div>

<p>生成调试信息还需要前端的支持，在 clang 编译时指定 -g 选项，生成源码级别的调 试信息。注意，不管 llc 是否指定了 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris 选项，-g 都是需要指定的。生成目 标文件的完整示例：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-O2</span> <span class="nt">-g</span> <span class="nt">-Wall</span> <span class="nt">-target</span> bpf <span class="nt">-emit-llvm</span> <span class="nt">-c</span> xdp-example.c <span class="nt">-o</span> xdp-example.bc
<span class="nv">$ </span>llc xdp-example.bc <span class="nt">-march</span><span class="o">=</span>bpf <span class="nt">-mattr</span><span class="o">=[</span>dwarf]<span class="o">(</span>http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction<span class="o">)</span>ris <span class="nt">-filetype</span><span class="o">=</span>obj <span class="nt">-o</span> xdp-example.o
</code></pre></div></div>

<p>或者，只使用 clang 这一个工具来编译带调试信息的 BPF 程序（同样，如果有合适的 elfutils 版本，<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris 选项可以省略）：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-target</span> bpf <span class="nt">-O2</span> <span class="nt">-g</span> <span class="nt">-c</span> <span class="nt">-Xclang</span> <span class="nt">-target-feature</span> <span class="nt">-Xclang</span> +[dwarf]<span class="o">(</span>http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction<span class="o">)</span>ris <span class="nt">-c</span> xdp-example.c <span class="nt">-o</span> xdp-example.o
</code></pre></div></div>

<p>基于 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 信息 dump BPF 程序的数据结构：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pahole xdp-example.o
struct xdp_md <span class="o">{</span>
        __u32                      data<span class="p">;</span>                 /<span class="k">*</span>     0     4 <span class="k">*</span>/
        __u32                      data_end<span class="p">;</span>             /<span class="k">*</span>     4     4 <span class="k">*</span>/
        __u32                      data_meta<span class="p">;</span>            /<span class="k">*</span>     8     4 <span class="k">*</span>/

        /<span class="k">*</span> size: 12, cachelines: 1, members: 3 <span class="k">*</span>/
        /<span class="k">*</span> last cacheline: 12 bytes <span class="k">*</span>/
<span class="o">}</span><span class="p">;</span>
</code></pre></div></div>

<p>在对象文件中，<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 数据将仍然伴随着新加入的 BTF 数据一起保留。完整的 clang 和 pahole 示例：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-target</span> bpf <span class="nt">-O2</span> <span class="nt">-Wall</span> <span class="nt">-g</span> <span class="nt">-c</span> <span class="nt">-Xclang</span> <span class="nt">-target-feature</span> <span class="nt">-Xclang</span> +[dwarf]<span class="o">(</span>http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction<span class="o">)</span>ris <span class="nt">-c</span> xdp-example.c <span class="nt">-o</span> xdp-example.o
<span class="nv">$ </span>pahole <span class="nt">-J</span> xdp-example.o
</code></pre></div></div>

<h2 id="readelf">readelf</h2>

<p>通过 readelf 工具可以看到多了一个 .BTF section：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>readelf <span class="nt">-a</span> xdp-example.o
<span class="o">[</span>...]
  <span class="o">[</span>18] .BTF              PROGBITS         0000000000000000  00000671
<span class="o">[</span>...]
</code></pre></div></div>
<p>BPF 加载器（例如 iproute2）会检测和加载 BTF section，因此给 BPF map 注释（ annotate）类型信息。</p>

<h3 id="223-bpf-指令集">2.2.3 BPF 指令集</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>根据不同的 CPU 生成不同的汇编指令，用于编译和执行
</code></pre></div></div>

<p>LLVM 默认用 BPF 基础指令集（base instruction set）来生成代码，以确保这些生成的对
象文件也能够被稍老的 LTS 内核（例如 4.9+）加载。</p>

<p>但是，LLVM 提供了一个 BPF 后端选项 <code class="language-plaintext highlighter-rouge">-mcpu</code>，可以指定不同版本的 BPF 指令集，即
BPF 基础指令集之上的指令集扩展（instruction set extensions），以生成更高效和体积
更小的代码。</p>

<p>可用的 <code class="language-plaintext highlighter-rouge">-mcpu</code> 类型：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>llc <span class="nt">-march</span> bpf <span class="nt">-mcpu</span><span class="o">=</span><span class="nb">help
</span>Available CPUs <span class="k">for </span>this target:

  generic - Select the generic processor.
  probe   - Select the probe processor.
  v1      - Select the v1 processor.
  v2      - Select the v2 processor.
<span class="o">[</span>...]
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">generic</code> processor 是默认的 processor，也是 BPF <code class="language-plaintext highlighter-rouge">v1</code> 基础指令集。</li>
  <li><code class="language-plaintext highlighter-rouge">v1</code> 和 <code class="language-plaintext highlighter-rouge">v2</code> processor 通常在交叉编译 BPF 的环境下比较有用，即编译 BPF 的平台
和最终执行 BPF 的平台不同（因此 BPF 内核特性可能也会不同）。</li>
</ul>

<p><strong>推荐使用 <code class="language-plaintext highlighter-rouge">-mcpu=probe</code> ，这也是 Cilium 内部在使用的类型</strong>。使用这种类型时，
LLVM BPF 后端会向内核询问可用的 BPF 指令集扩展，如果找到可用的，就会使用相应的指
令集来编译 BPF 程序。</p>

<p>使用 <code class="language-plaintext highlighter-rouge">llc</code> 和 <code class="language-plaintext highlighter-rouge">-mcpu=probe</code> 的完整示例：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-O2</span> <span class="nt">-Wall</span> <span class="nt">-target</span> bpf <span class="nt">-emit-llvm</span> <span class="nt">-c</span> xdp-example.c <span class="nt">-o</span> xdp-example.bc
<span class="nv">$ </span>llc xdp-example.bc <span class="nt">-march</span><span class="o">=</span>bpf <span class="nt">-mcpu</span><span class="o">=</span>probe <span class="nt">-filetype</span><span class="o">=</span>obj <span class="nt">-o</span> xdp-example.o
</code></pre></div></div>

<p><a name="ch_2.2.4"></a></p>

<h3 id="224-指令和寄存器位宽6432-位">2.2.4 指令和寄存器位宽（64/32 位）</h3>

<p>通常来说，LLVM IR 生成是架构无关的。但使用 <code class="language-plaintext highlighter-rouge">clang</code> 编译时是否指定 <code class="language-plaintext highlighter-rouge">-target bpf</code>
是有几点小区别的，取决于不同的平台架构（<code class="language-plaintext highlighter-rouge">x86_64</code>、<code class="language-plaintext highlighter-rouge">arm64</code> 或其他），<code class="language-plaintext highlighter-rouge">-target</code> 的
默认配置可能不同。</p>

<p>引用内核文档 <code class="language-plaintext highlighter-rouge">Documentation/bpf/bpf_devel_QA.txt</code>：</p>

<ul>
  <li>
    <p>BPF 程序可以嵌套 include 头文件，只要头文件中都是文件作用域的内联汇编代码（
file scope inline assembly codes）。大部分情况下默认 target 都可以处理这种情况，
但如果 BPF 后端汇编器无法理解这些汇编代码，那 <code class="language-plaintext highlighter-rouge">bpf</code> target 会失败。</p>
  </li>
  <li>
    <p>如果编译时没有指定 <code class="language-plaintext highlighter-rouge">-g</code>，那额外的 elf sections（例如 <code class="language-plaintext highlighter-rouge">.eh_frame</code>
和 <code class="language-plaintext highlighter-rouge">.rela.eh_frame</code>）可能会以默认 target 格式出现在对象文件中，但不会是 <code class="language-plaintext highlighter-rouge">bpf</code>
target。</p>
  </li>
  <li>
    <p>默认 target 可能会将一个 C <code class="language-plaintext highlighter-rouge">switch</code> 声明转换为一个 <code class="language-plaintext highlighter-rouge">switch</code> 表的查找和跳转操作。
由于 switch 表位于全局的只读 section，因此 BPF 程序的加载会失败。 <code class="language-plaintext highlighter-rouge">bpf</code> target
不支持 switch 表优化。clang 的 <code class="language-plaintext highlighter-rouge">-fno-jump-tables</code> 选项可以禁止生成 switch 表。</p>
  </li>
  <li>
    <p>如果 clang 指定了 <code class="language-plaintext highlighter-rouge">-target bpf</code>，那指针或 <code class="language-plaintext highlighter-rouge">long</code>/<code class="language-plaintext highlighter-rouge">unsigned long</code> 类型将永远
是 64 位的，不管底层的 clang 可执行文件或默认的 target（或内核）是否是 32
位。但如果使用的是 native clang target，那 clang 就会根据底层的架构约定（
architecture’s conventions）来编译这些类型，这意味着对于 32 位的架构，BPF 上下
文中的指针或 <code class="language-plaintext highlighter-rouge">long</code>/<code class="language-plaintext highlighter-rouge">unsigned long</code> 类型会是 32 位的，但此时的 BPF LLVM 后端仍
然工作在 64 位模式。</p>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">native</code> target 主要用于跟踪（tracing）内核中的 <code class="language-plaintext highlighter-rouge">struct pt_regs</code>，这个结构体对
CPU 寄存器进行映射，或者是跟踪其他一些能感知 CPU 寄存器位宽（CPU’s register
width）的内核结构体。除此之外的其他场景，例如网络场景，都建议使用 <code class="language-plaintext highlighter-rouge">clang -target
bpf</code>。</p>

<p>另外，LLVM 从 7.0 开始支持 32 位子寄存器和 BPF ALU32 指令。另外，新加入了一个代
码生成属性 <code class="language-plaintext highlighter-rouge">alu32</code>。当指定这个参数时，LLVM 会尝试尽可能地使用 32 位子寄存器，例
如当涉及到 32 位操作时。32 位子寄存器及相应的 ALU 指令组成了 ALU32 指令。例如，
对于下面的示例代码：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>32-bit-example.c
void cal<span class="o">(</span>unsigned int <span class="k">*</span>a, unsigned int <span class="k">*</span>b, unsigned int <span class="k">*</span>c<span class="o">)</span>
<span class="o">{</span>
  unsigned int <span class="nb">sum</span> <span class="o">=</span> <span class="k">*</span>a + <span class="k">*</span>b<span class="p">;</span>
  <span class="k">*</span>c <span class="o">=</span> <span class="nb">sum</span><span class="p">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用默认的代码生成选项，产生的汇编代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ clang -target bpf -emit-llvm -S 32-bit-example.c
$ llc -march=bpf 32-bit-example.ll
$ cat 32-bit-example.s
cal:
  r1 = *(u32 *)(r1 + 0)
  r2 = *(u32 *)(r2 + 0)
  r2 += r1
  *(u32 *)(r3 + 0) = r2
  exit
</code></pre></div></div>

<p>可以看到默认使用的是 <code class="language-plaintext highlighter-rouge">r</code> 系列寄存器，这些都是 64 位寄存器，这意味着其中的加法都
是 64 位加法。现在，如果指定 <code class="language-plaintext highlighter-rouge">-mattr=+alu32</code> 强制要求使用 32 位，生成的汇编代码
如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ llc -march=bpf -mattr=+alu32 32-bit-example.ll
$ cat 32-bit-example.s
cal:
  w1 = *(u32 *)(r1 + 0)
  w2 = *(u32 *)(r2 + 0)
  w2 += w1
  *(u32 *)(r3 + 0) = w2
  exit
</code></pre></div></div>

<p>可以看到这次使用的是 <code class="language-plaintext highlighter-rouge">w</code> 系列寄存器，这些是 32 位子寄存器。</p>

<p>使用 32 位子寄存器可能会减小（最终生成的代码中）<strong>类型扩展指令</strong>（type extension
instruction）的数量。另外，它对 32 位架构的内核 eBPF JIT 编译器也有所帮助，因为
原来这些编译器都是用 32 位模拟 64 位 eBPF 寄存器，其中使用了很多 32 位指令来操作
高 32 bit。即使写 32 位子寄存器的操作仍然需要对高 32 位清零，但只要确保从 32 位
子寄存器的读操作只会读取低 32 位，那只要 JIT 编译器已经知道某个寄存器的定义只有
子寄存器读操作，那对高 32 位的操作指令就可以避免。</p>

<h1 id="文档连接">文档连接</h1>
<p><a href="https://www.dazhuanlan.com/2019/12/10/5dee76b007da0/">Linux BPF 3.2、BPF and XDP Reference Guide</a>
<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">[译] Cilium：BPF 和 XDP 参考指南（2019）</a>
<a href="https://docs.cilium.io/en/stable/bpf/">BPF and XDP Reference Guide</a>
<a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">BPF 辅助函数</a>
<a href="https://man7.org/linux/man-pages/man2/bpf.2.html">BPF man 文档</a></p>
:ET