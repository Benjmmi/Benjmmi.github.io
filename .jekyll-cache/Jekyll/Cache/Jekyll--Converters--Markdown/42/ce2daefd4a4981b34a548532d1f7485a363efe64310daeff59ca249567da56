I"p'<p>参考文档：
<a href="https://blog.csdn.net/XscKernel/article/details/8186679">深入Linux网络核心堆栈–netfilter详解(整理)</a>
<a href="https://github.com/liexusong/linux-source-code-analyze/blob/master/lvs-principle-and-source-analysis-part2.md">LVS原理与实现 - 实现篇</a>
<a href="http://www.linuxvirtualserver.org/zh/index.html">Linux服务器集群系统</a>
<a href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs">Linux 源码</a>
<a href="https://www.cnblogs.com/hadis-yuki/p/5529737.html">Netfilter机制</a></p>

<p><strong>此文章较长</strong></p>

<h1 id="介绍">介绍</h1>

<p>Netfilter是Linux 2.4内核的一个子系统，Netfiler使得诸如数据包过滤、网络地址转换(NAT)
以及网络连接跟踪等技巧成为可能，这些功能仅通过使用内核网络代码提供的各式各样的hook既可以完成。
这些hook位于内核代码中，要么是静态链接的，要么是以动态加载的模块的形式存在。</p>

<p>Linux Virtual Server(LVS) 针对高可伸缩、高可用网络服务的需求，给出了基于IP层和基于内容请求分发的负载
平衡调度解决方法，并在Linux内核中实现了这些方法，将一组服务器构成一个实现可伸缩的、高可用网络服务的虚拟
服务器。由于负载调度技术是在Linux内核中实现的，我们称之为Linux虚拟服务器（Linux Virtual Server）。</p>

<p>LVS 项目的目标 ：使用集群技术和Linux操作系统实现一个高性能、高可用的服务器，
它具有很好的可伸缩性（Scalability）、可靠性（Reliability）和可管理性（Manageability）</p>

<p>在LVS框架中，提供了含有IP负载均衡技术的<code class="language-plaintext highlighter-rouge">IP虚拟服务器软件IPVS</code>。</p>

<h1 id="netfilter">Netfilter</h1>
<p>Netfilter中定义了五个关于IPv4的hook，对这些符号的声明可以在 <a href="https://elixir.bootlin.com/linux/v5.11.2/source/include/uapi/linux/netfilter_ipv4.h#L18">netfilter_ipv4.h</a> 中找到，可用的 IP HOOK 如下：</p>

<blockquote>
  <p>#define NF_IP_PRE_ROUTING   0   在进行完整性检查之后，可以截获接收的所有报文，包括目的地址是自己的报文和需要转发的报文；目的IP地址转换在此点
#define NF_IP_LOCAL_IN      1   路由决策后，可以截获目的地址是自己的报文，INPUT 包过滤在这里进行
#define NF_IP_FORWARD       2   截获所有转发的报文，FORWARD 在这里进行过滤
#define NF_IP_LOCAL_OUT     3   可以截获自身发出的所有报文(不包括转发)，OUTPUT 过滤在这里进行
#define NF_IP_POST_ROUTING  4   可以截获发送的所有报文，包括自身发出的报文和转发的报文</p>
</blockquote>

<p>在hook函数完成了对数据包所需的任何的操作之后，它们必须返回下列预定义的Netfilter返回值中的一个：</p>

<blockquote>
  <p>#define NF_DROP     0     丢弃数据包，不在继续
#define NF_ACCEPT   1     正常传输报文
#define NF_STOLEN   2     Netfilter 模块接管该报文，不再继续传输
#define NF_QUEUE    3     对该数据报进行排队，通常用于将数据报提交给用户空间进程处理
#define NF_REPEAT   4     再次调用该钩子函数
#define NF_STOP     5     继续正常传输报文</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Note</code>：NF_ACCEPT和NF_STOP都表示报文通过了检查，可以正常向下流通。</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">NF_ACCEPT</code> 表示报文通过了某个 <code class="language-plaintext highlighter-rouge">HOOK</code> 函数的处理，下一个 <code class="language-plaintext highlighter-rouge">HOOK</code> 函数可以接着处理了
<code class="language-plaintext highlighter-rouge">NF_STOP</code> 表示报文通过了某个 <code class="language-plaintext highlighter-rouge">HOOK</code> 函数的处理，后面的 <code class="language-plaintext highlighter-rouge">HOOK</code> 函数你们就不要处理了</p>
</blockquote>

<p>场景解释：假设有两个 <code class="language-plaintext highlighter-rouge">hook</code> 分别是 <code class="language-plaintext highlighter-rouge">hook1</code>、<code class="language-plaintext highlighter-rouge">hook2</code>，<code class="language-plaintext highlighter-rouge">hook1</code> &gt; <code class="language-plaintext highlighter-rouge">hook2</code> 优先级。
<code class="language-plaintext highlighter-rouge">hook1</code> 设定的处理结果是<code class="language-plaintext highlighter-rouge">NF_STOP</code>，那么报文就会有 <code class="language-plaintext highlighter-rouge">hook1</code> 提交给应用程序或者其他处理，因为<code class="language-plaintext highlighter-rouge">hook1</code>放行了，根本不会给<code class="language-plaintext highlighter-rouge">hook2</code>处理的机会。数据包依然有效</p>

<p>处理代码体现：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/nf_queue.c#L237</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">nf_iterate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nf_hook_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
             <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_entries</span> <span class="o">*</span><span class="n">hooks</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_entry</span> <span class="o">*</span><span class="n">hook</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">verdict</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">index</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">num_hook_entries</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">hook</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hooks</span><span class="o">-&gt;</span><span class="n">hooks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="nl">repeat:</span>
    <span class="n">verdict</span> <span class="o">=</span> <span class="n">nf_hook_entry_hookfn</span><span class="p">(</span><span class="n">hook</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span> <span class="c1">// 调用 hook 函数</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">verdict</span> <span class="o">!=</span> <span class="n">NF_ACCEPT</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">verdict</span> <span class="o">!=</span> <span class="n">NF_REPEAT</span><span class="p">)</span> <span class="c1">// 不是重试直接返回</span>
        <span class="k">return</span> <span class="n">verdict</span><span class="p">;</span>
      <span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>   <span class="c1">// 重试</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="注册注销-hook">注册/注销 hook</h2>

<p>注册一个hook函数是围绕nf_hook_ops数据结构,数据结构的定义如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v5.11.2/source/include/linux/netfilter.h#L77</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">nf_hookfn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
             <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
             <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_state</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="p">{</span>
  <span class="n">nf_hookfn</span>   <span class="o">*</span><span class="n">hook</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
  <span class="kt">void</span>      <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
  <span class="n">u_int8_t</span>    <span class="n">pf</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">hooknum</span><span class="p">;</span>
  <span class="kt">int</span>     <span class="n">priority</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nf_hook_state</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">;</span>
  <span class="n">u_int8_t</span> <span class="n">pf</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<blockquote>
  <p>priv：私有数据 
skb：正在处理的报文
state：将相关参数都将存储到state中
hook：hook 函数
dev：设备
pf：协议族
hooknum：hook 触发点的编号
priority：优先级
net_device *in：用于描述数据包到达的接口
net_device *out：用于描述数据包离开的接口</p>
</blockquote>

<p>参数 <code class="language-plaintext highlighter-rouge">in</code> 只用于<code class="language-plaintext highlighter-rouge">NF_IP_PRE_ROUTING</code>和<code class="language-plaintext highlighter-rouge">NF_IP_LOCAL_IN</code>，参数<code class="language-plaintext highlighter-rouge">out</code>只用于<code class="language-plaintext highlighter-rouge">NF_IP_LOCAL_OUT</code>和<code class="language-plaintext highlighter-rouge">NF_IP_POST_ROUTING</code></p>

<p>注册一个Netfilter <code class="language-plaintext highlighter-rouge">hook</code> 需要调用 <code class="language-plaintext highlighter-rouge">nf_register_net_hook()</code> 函数，以及用到一个 <code class="language-plaintext highlighter-rouge">nf_hook_ops</code> 数据结构。
<code class="language-plaintext highlighter-rouge">nf_register_net_hook()</code>函数以一个 <code class="language-plaintext highlighter-rouge">nf_hook_ops</code> 数据结构的地址作为参数并且返回一个整型的值。 代码如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/core.c#L557</span>
<span class="kt">int</span> <span class="nf">nf_register_net_hooks</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">nf_register_net_hook</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 注册 hook 函数</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span> <span class="c1">// 注册失败</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 注销 hook 函数</span>
    <span class="n">nf_unregister_net_hooks</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="hook-触发">hook 触发</h2>

<p>因为制作 hook 触发需要将程序加载到内核中，所以先了解下 linux 内核模块化，加载和卸载。</p>

<p>创建两个个源代码文件：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// hds.c</span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="c1"> // 任何模块都必须包含，定义了可动态加载到内核的模块所需要的必要信息</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="c1"> // 必须包含，包含了宏__init(指定初始化函数)和__exit(指定清除函数)</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="c1"> //里面包含常用的内核API，例如内核打印函数printk()</span><span class="cp">
</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hds_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="c1">//__init将函数hds_init()标记为初始化函数，在模块被装载到内核时调用hds_init()</span>
<span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">"Hello Kernell</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">hds_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="c1">//清除函数,在模块被卸载之前调用</span>
<span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">"GoodBye Kernel</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">hds_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">hds_exit</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"jony"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"for fun"</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Makefile
obj-m:<span class="o">=</span>hds.o <span class="c">#根据make的自动推导原则，make会自动将源程序hds.c编译成目标程序hds.o</span>
            <span class="c">#所有在配置文件中标记为-m的模块将被编译成可动态加载进内核的模块。即后缀为.ko的文件</span>
CURRENT_PATH:<span class="o">=</span><span class="si">$(</span>shell <span class="nb">pwd</span><span class="si">)</span>        <span class="c">#参数化，将模块源码路径保存在CURRENT_PATH中</span>
LINUX_KERNEL:<span class="o">=</span><span class="si">$(</span>shell <span class="nb">uname</span> <span class="nt">-r</span><span class="si">)</span>   <span class="c">#参数化，将当前内核版本保存在LINUX_KERNEL中</span>
LINUX_KERNEL_PATH:<span class="o">=</span>/usr/src/linux-headers-<span class="si">$(</span>LINUX_KERNEL<span class="si">)</span>      <span class="c">#参数化，将内核源代码的绝对路径保存在LINUX_KERNEL_PATH中</span>

all:
        make <span class="nt">-C</span> <span class="si">$(</span>LINUX_KERNEL_PATH<span class="si">)</span> <span class="nv">M</span><span class="o">=</span><span class="si">$(</span>CURRENT_PATH<span class="si">)</span> modules    <span class="c">#编译模块</span>
clean:
        make <span class="nt">-C</span> <span class="si">$(</span>LINUX_KERNEL_PATH<span class="si">)</span> <span class="nv">M</span><span class="o">=</span><span class="si">$(</span>CURRENT_PATH<span class="si">)</span> clean  <span class="c">#清理</span>
</code></pre></div></div>

<p>两个文件创建完成后，执行编译加载命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>make    <span class="c"># 执行编译</span>
<span class="nv">$ </span><span class="nb">sudo </span>insmod hds.ko  <span class="c"># 模块加载到内核</span>
<span class="nv">$ </span>lsmod |grep hds   <span class="c"># 查看是否加载成功</span>
<span class="nv">$ </span>dmesg   <span class="c"># 查看内核输出</span>
<span class="nv">$ </span><span class="nb">sudo </span>rmmod hds <span class="c"># 卸载内核模块</span>
</code></pre></div></div>
<p><strong>制作 HOOK</strong></p>

<p>制作一个轻量级防火墙，根据 <code class="language-plaintext highlighter-rouge">net_device</code> 中的 <code class="language-plaintext highlighter-rouge">name</code> 字段来制作防火墙。比如当 <code class="language-plaintext highlighter-rouge">in-&gt;name</code> 等于 <code class="language-plaintext highlighter-rouge">eth0</code> 的时候我们
就返回 <code class="language-plaintext highlighter-rouge">NF_DROP</code> ，数据包会自动销毁。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// drop_if_lo.c</span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/version.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/skbuff.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/netfilter.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/netfilter_ipv4.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/netdevice.h&gt;</span><span class="cp">
</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="n">nf_drop</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">if_name</span> <span class="o">=</span> <span class="s">"eth0"</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">hook_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
                <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">out</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="n">if_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
                <span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
                <span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">drop_if_lo_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">"drop_if_lo_init"</span><span class="p">);</span>
        <span class="n">nf_drop</span><span class="p">.</span><span class="n">hook</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hook_func</span><span class="p">;</span>
        <span class="n">nf_drop</span><span class="p">.</span><span class="n">pf</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>
        <span class="n">nf_drop</span><span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span> <span class="n">NF_INET_LOCAL_OUT</span><span class="p">;</span>
        <span class="n">nf_drop</span><span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">NF_IP_PRI_FIRST</span><span class="p">;</span>

        <span class="n">nf_register_net_hook</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nf_drop</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">drop_if_lo_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">"drop if lo exit</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">nf_unregister_net_hook</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nf_drop</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">module_init</span><span class="p">(</span><span class="n">drop_if_lo_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">drop_if_lo_exit</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"jony"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"drop if eth0"</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//Makefile
obj-m:<span class="o">=</span>drop_if_lo.o

CURRENT_PATH:<span class="o">=</span><span class="si">$(</span>shell <span class="nb">pwd</span><span class="si">)</span>
LINUX_KERNEL:<span class="o">=</span><span class="si">$(</span>shell <span class="nb">uname</span> <span class="nt">-r</span><span class="si">)</span>
LINUX_KERNEL_PATH:<span class="o">=</span>/usr/src/linux-headers-<span class="si">$(</span>LINUX_KERNEL<span class="si">)</span>

all:
        make <span class="nt">-C</span> <span class="si">$(</span>LINUX_KERNEL_PATH<span class="si">)</span> <span class="nv">M</span><span class="o">=</span><span class="si">$(</span>CURRENT_PATH<span class="si">)</span> modules
clean:
        make <span class="nt">-C</span> <span class="si">$(</span>LINUX_KERNEL_PATH<span class="si">)</span> <span class="nv">M</span><span class="o">=</span><span class="si">$(</span>CURRENT_PATH<span class="si">)</span> clean

</code></pre></div></div>

<p>问题：理想状态是只会删除 eth0 的数据包，不会删除其他网卡的数据包，但是实际情况是任何数据包都被删除了。查下原因本地访问会自动转为 lo 设备。</p>

<p>总结：Netfilter 基本上特点大概都了解了一遍，基本上 Netfilter 原理大致都了解，也可以通过编写内核模块来编写 Netfilter 插件，加载到内核中执行。</p>

<blockquote>
  <p><strong><code class="language-plaintext highlighter-rouge">Note：在linux内核中默认情况下，会有一个默认的网络命名空间，其名为init_net</code></strong></p>
</blockquote>

<h1 id="ipvs">IPVS</h1>

<p>学完 Netfilter 之后，在看 IPVS 基本已经没有秘密，IPVS 也是在基于 Netfilter 编写的一款插件。
关于注册就不在考虑如何注册整个流程，只学习下几个核心功能。</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">[ip_vs_service](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L612)</code>：服务配置对象，主要用于保存 LVS 的配置信息，如 支持的 传输层协议、虚拟IP 和 端口 等。
<code class="language-plaintext highlighter-rouge">[ip_vs_dest](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L654)</code>：真实服务器对象，主要用于保存真实服务器 (Real-Server) 的配置，如 真实IP、端口 和 权重 等。
<code class="language-plaintext highlighter-rouge">[ip_vs_scheduler](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L696)</code>：调度器对象，主要通过使用不同的调度算法来选择合适的真实服务器对象。
<code class="language-plaintext highlighter-rouge">[ip_vs_conn](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L502)</code>：连接对象，主要为了维护相同的客户端与真实服务器之间的连接关系。这是由于 TCP 协议是面向连接的，所以同一个的客户端每次选择真实服务器的时候必须保存一致，否则会出现连接中断的情况，而连接对象就是为了维护这种关系。
<code class="language-plaintext highlighter-rouge">[ip_vs_xmit](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_conn.c#L512)</code>：数据包转发模式
<code class="language-plaintext highlighter-rouge">[ip_vs_app](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_xmit.c)</code>：应用层协议对象的一种实现</p>
</blockquote>

<p>来自 <a href="./lvs3.md">LVS  学习： 源码理解修改</a></p>

<h2 id="ip_vs_service">ip_vs_service</h2>

<blockquote>
  <p>注：Persistence(PE) 设置持久连接，这个模式可以使来自客户的多个请求被送到同一个真实服务器</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">ip_vs_service</code> 的创建通过 <code class="language-plaintext highlighter-rouge">ip_vs_add_service()</code> 函数来完成，真实代码如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_ctl.c#L1286</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ip_vs_add_service</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">,</span> <span class="c1">// 所属哪个命名空间</span>
  <span class="k">struct</span> <span class="n">ip_vs_service_user_kern</span> <span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="c1">// 用户通过命令行配置的规则信息</span>
      <span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">**</span><span class="n">svc_p</span>
      <span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">ip_vs_scheduler</span> <span class="o">*</span><span class="n">sched</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">ip_vs_pe</span> <span class="o">*</span><span class="n">pe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ret_hooks</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">sched_name</span><span class="p">,</span> <span class="s">"none"</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 根据调度器名称获取调度策略对象</span>
    <span class="n">sched</span> <span class="o">=</span> <span class="n">ip_vs_scheduler_get</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">sched_name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">pe_name</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">pe_name</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 根据持久化名称获取持久化管理方法</span>
    <span class="n">pe</span> <span class="o">=</span> <span class="n">ip_vs_pe_getbyname</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">pe_name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">num_services</span><span class="p">)</span> <span class="o">||</span>
      <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">num_services6</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">ip_vs_register_hooks</span><span class="p">(</span><span class="n">ipvs</span><span class="p">,</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">);</span>  <span class="c1">// 如果是首次创建 SVC，那么就将调度策略注册到 Netfilter</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
    <span class="n">ret_hooks</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">...</span>
  <span class="n">svc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span> <span class="c1">// 申请一个 ip_vs_service 对象</span>
  <span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">;</span> <span class="c1">// 3 层协议</span>
  <span class="n">svc</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span> <span class="c1">// 4 层协议</span>
  <span class="n">ip_vs_addr_copy</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span> <span class="c1">// svc IP</span>
  <span class="n">svc</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span> <span class="c1">// svc 端口</span>
  <span class="n">svc</span><span class="o">-&gt;</span><span class="n">fwmark</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">fwmark</span><span class="p">;</span> <span class="c1">// 防火墙标记，持久化对象</span>
  <span class="n">svc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span> <span class="c1">// 标志位</span>
  <span class="n">svc</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span> <span class="c1">// 超时时间</span>
  <span class="n">svc</span><span class="o">-&gt;</span><span class="n">netmask</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">netmask</span><span class="p">;</span> <span class="c1">// 网络掩码</span>
  <span class="n">svc</span><span class="o">-&gt;</span><span class="n">ipvs</span> <span class="o">=</span> <span class="n">ipvs</span><span class="p">;</span> 

  <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">destinations</span><span class="p">);</span>
  <span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">sched_lock</span><span class="p">);</span>
  <span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">sched</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">ip_vs_bind_scheduler</span><span class="p">(</span><span class="n">svc</span><span class="p">,</span> <span class="n">sched</span><span class="p">);</span> <span class="c1">// 绑定到指定的调度器</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
      <span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
    <span class="n">sched</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>  
  <span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">pe</span><span class="p">,</span> <span class="n">pe</span><span class="p">);</span>  <span class="c1">// 初始化持久化方式</span>
  <span class="n">pe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="n">ip_vs_svc_hash</span><span class="p">(</span><span class="n">svc</span><span class="p">);</span> <span class="c1">// 添加 ip_vs_service 到 hash 表</span>
  <span class="o">*</span><span class="n">svc_p</span> <span class="o">=</span> <span class="n">svc</span><span class="p">;</span> <span class="c1">// 返回 svc</span>
  <span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>    
<span class="p">}</span>
</code></pre></div></div>
<p>上面的代码主要完成一下几个工作：</p>

<ul>
  <li>通过调用 <code class="language-plaintext highlighter-rouge">ip_vs_scheduler_get</code> 函数来获取一个 <code class="language-plaintext highlighter-rouge">ip_vs_scheduler</code> 调度器</li>
  <li>申请 <code class="language-plaintext highlighter-rouge">ip_vs_service</code> 对象，并初始化。然后将上面获取到调度器，与当前 <code class="language-plaintext highlighter-rouge">svc</code> 绑定</li>
  <li>最终将 <code class="language-plaintext highlighter-rouge">ip_vs_service</code> 对象添加到全局 hash 表中。（思考：内存决定了 hash 表的上线，如果使用 LRU 是否可以进一步扩展至硬盘）</li>
</ul>

<h2 id="ip_vs_dest">ip_vs_dest</h2>

<p>真实服务器对象，主要用于创建保存真实服务器 (Real-Server) 的相关配置信息。
创建 <code class="language-plaintext highlighter-rouge">ip_vs_dest</code> 对象通过 <code class="language-plaintext highlighter-rouge">ip_vs_add_dest()</code> 创建，具体代码细节如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_ctl.c#L1038</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ip_vs_add_dest</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_dest_user_kern</span> <span class="o">*</span><span class="n">udest</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
  <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="n">daddr</span><span class="p">;</span>
  <span class="n">__be16</span> <span class="n">dport</span> <span class="o">=</span> <span class="n">udest</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
  <span class="c1">// 复制目标地址</span>
  <span class="n">ip_vs_addr_copy</span><span class="p">(</span><span class="n">udest</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">daddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
  <span class="c1">// 冲当前 svc 的hash 中获取 目标RS地址，检查是否存在，如果存在就直接返回</span>
  <span class="n">dest</span> <span class="o">=</span> <span class="n">ip_vs_lookup_dest</span><span class="p">(</span><span class="n">svc</span><span class="p">,</span> <span class="n">udest</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">dport</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dest</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 从删除但是没有回收的 hash 中查找 目标RS地址，如果存在就撤回删除</span>
  <span class="c1">// 为什么删除了却没有回收，因为需要保证 conn 被正确的关闭，因为如果 conn 还在被引用</span>
  <span class="c1">// 直接删除可能会引发不可预测的问题</span>
  <span class="n">dest</span> <span class="o">=</span> <span class="n">ip_vs_trash_get_dest</span><span class="p">(</span><span class="n">svc</span><span class="p">,</span> <span class="n">udest</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">dport</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dest</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 撤回删除状态</span>
    <span class="n">__ip_vs_update_dest</span><span class="p">(</span><span class="n">svc</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">udest</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 新建目标 rs 地址，映射到 hash 中</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">ip_vs_new_dest</span><span class="p">(</span><span class="n">svc</span><span class="p">,</span> <span class="n">udest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ip_vs_new_dest</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_dest_user_kern</span> <span class="o">*</span><span class="n">udest</span><span class="p">,</span>
         <span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">**</span><span class="n">dest_p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">atype</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="n">dest</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_dest</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="n">dest</span><span class="o">-&gt;</span><span class="n">af</span> <span class="o">=</span> <span class="n">udest</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">;</span> <span class="c1">// 地址族</span>
  <span class="n">dest</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span> <span class="c1">// 端口协议</span>
  <span class="n">dest</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span> <span class="c1">// 虚拟 IP 地址</span>
  <span class="n">dest</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span> <span class="c1">// 虚拟端口</span>
  <span class="n">dest</span><span class="o">-&gt;</span><span class="n">vfwmark</span> <span class="o">=</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">fwmark</span><span class="p">;</span> <span class="c1">// 虚拟网络掩码</span>
  <span class="n">ip_vs_addr_copy</span><span class="p">(</span><span class="n">udest</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span> <span class="c1">// 添加的 RS 地址</span>
  <span class="n">dest</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">udest</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span> <span class="c1">// 添加的 RS 端口</span>

  <span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">activeconns</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">inactconns</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">persistconns</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 初始化连接状态</span>
  <span class="n">refcount_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">d_list</span><span class="p">);</span>
  <span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">dst_lock</span><span class="p">);</span>
  <span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">__ip_vs_update_dest</span><span class="p">(</span><span class="n">svc</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">udest</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 更新 svc hash 桶中的 dest 地址</span>

  <span class="o">*</span><span class="n">dest_p</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>  
</code></pre></div></div>
<p>ip_vs_new_dest() 函数的实现也比较简单，与 svc 一样通过调用 kmalloc() 函数申请一个 ip_vs_dest ，然后根据用户配置的规则信息来初始化 ip_vs_dest 对象的各个字段。</p>

<h2 id="ip_vs_scheduler">ip_vs_scheduler</h2>

<p><code class="language-plaintext highlighter-rouge">ip_vs_scheduler</code> 用于从 <code class="language-plaintext highlighter-rouge">ip_vs_service</code> 对象的 <code class="language-plaintext highlighter-rouge">destinations</code> hash 桶中获取一个合适的 <code class="language-plaintext highlighter-rouge">ip_vs_dest</code> 对象，结构定义如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">ip_vs_scheduler</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">list_head</span>  <span class="n">n_list</span><span class="p">;</span>   <span class="cm">/* 调度策略链表 */</span>
  <span class="kt">char</span>      <span class="o">*</span><span class="n">name</span><span class="p">;</span>    <span class="cm">/* scheduler 名称 */</span>
  <span class="n">atomic_t</span>    <span class="n">refcnt</span><span class="p">;</span>   <span class="cm">/* 引用基数 */</span>
  <span class="k">struct</span> <span class="n">module</span>   <span class="o">*</span><span class="n">module</span><span class="p">;</span>  <span class="cm">/* THIS_MODULE/NULL */</span>

  <span class="cm">/* scheduler 初始化一个 svc */</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init_service</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">);</span>
  <span class="cm">/* scheduling 停止一个 svc */</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done_service</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">);</span>
  <span class="cm">/* 连接一个目标服务 */</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">add_dest</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">dest</span><span class="p">);</span>
  <span class="cm">/* 解除一个目标服务的连接 */</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">del_dest</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">dest</span><span class="p">);</span>
  <span class="cm">/* 更新一个目标服务 */</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">upd_dest</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">dest</span><span class="p">);</span>

  <span class="cm">/* 选择一个真实服务器的对象 */</span>
  <span class="k">struct</span> <span class="n">ip_vs_dest</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">schedule</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span>
               <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
               <span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>上述字段中，<code class="language-plaintext highlighter-rouge">schedule</code> 是指向一个函数的指针，用于从 <code class="language-plaintext highlighter-rouge">ip_vs_service</code> 对象的 <code class="language-plaintext highlighter-rouge">destinations</code> hash 桶中获取一个合适的 <code class="language-plaintext highlighter-rouge">ip_vs_dest</code> 对象。<code class="language-plaintext highlighter-rouge">ip_vs_scheduler</code> 定义如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">ip_vs_scheduler</span> <span class="n">ip_vs_rr_scheduler</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">name</span> <span class="o">=</span>     <span class="s">"rr"</span><span class="p">,</span>     <span class="cm">/* 策略名称 */</span>  
  <span class="p">.</span><span class="n">refcnt</span> <span class="o">=</span>   <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="c1">// 引用基数</span>
  <span class="p">.</span><span class="n">module</span> <span class="o">=</span>   <span class="n">THIS_MODULE</span><span class="p">,</span>
  <span class="p">.</span><span class="n">n_list</span> <span class="o">=</span>   <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">ip_vs_rr_scheduler</span><span class="p">.</span><span class="n">n_list</span><span class="p">),</span>
  <span class="p">.</span><span class="n">init_service</span> <span class="o">=</span>   <span class="n">ip_vs_rr_init_svc</span><span class="p">,</span> <span class="c1">// 调度策略，初始化 svc 方法 ip_vs_rr_init_svc</span>
  <span class="p">.</span><span class="n">add_dest</span> <span class="o">=</span>   <span class="nb">NULL</span><span class="p">,</span>
  <span class="p">.</span><span class="n">del_dest</span> <span class="o">=</span>   <span class="n">ip_vs_rr_del_dest</span><span class="p">,</span>  <span class="c1">// 删除一个目标服务</span>
  <span class="p">.</span><span class="n">schedule</span> <span class="o">=</span>   <span class="n">ip_vs_rr_schedule</span><span class="p">,</span> <span class="c1">// 调度策略</span>
<span class="p">};</span>
</code></pre></div></div>

<p>具体调度实现，可以查看该连接：<a href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_rr.c#L53">Round-Robin Scheduling</a></p>

<h2 id="ip_vs_conn">ip_vs_conn</h2>

<p><code class="language-plaintext highlighter-rouge">ip_vs_conn</code> 对象是用于维护 <code class="language-plaintext highlighter-rouge">访问来源</code> 和 <code class="language-plaintext highlighter-rouge">真实目标服务</code> 之间的联系，因为网络都是分包发送的，如果将每个包
都是使用调度策略，那么将会产生很多包失效的问题，<code class="language-plaintext highlighter-rouge">后端目标服务</code> 将会受到莫名其妙的网络包。</p>

<p>所以为了将来源包发送经过匹配发送到后端某一绑定实例，后端才会收到有用的数据。保持连接的方式有很多种，这里介绍
比较常用的 <code class="language-plaintext highlighter-rouge">s-hash</code>（来源 hash）。</p>

<p>先了解下 <code class="language-plaintext highlighter-rouge">ip_vs_conn</code> 的结构定义：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">c_list</span><span class="p">;</span>         <span class="cm">/* hashed list heads */</span>
  <span class="cm">/* Protocol, addresses and port numbers */</span>
  <span class="n">__be16</span>                  <span class="n">cport</span><span class="p">;</span> <span class="c1">// 来源端口</span>
  <span class="n">__be16</span>                  <span class="n">dport</span><span class="p">;</span> <span class="c1">// 目标端口</span>
  <span class="n">__be16</span>                  <span class="n">vport</span><span class="p">;</span> <span class="c1">// 虚拟端口</span>
  <span class="n">u16</span>     <span class="n">af</span><span class="p">;</span>   <span class="cm">/* 地址族 */</span>
  <span class="k">union</span> <span class="n">nf_inet_addr</span>      <span class="n">caddr</span><span class="p">;</span>          <span class="cm">/* 客户端 IP 地址 */</span>
  <span class="k">union</span> <span class="n">nf_inet_addr</span>      <span class="n">vaddr</span><span class="p">;</span>          <span class="cm">/* 虚拟 IP 地址 */</span>
  <span class="k">union</span> <span class="n">nf_inet_addr</span>      <span class="n">daddr</span><span class="p">;</span>          <span class="cm">/* 目标地址 */</span>
  <span class="k">volatile</span> <span class="n">__u32</span>          <span class="n">flags</span><span class="p">;</span>          <span class="cm">/* 状态 */</span>
  <span class="n">__u16</span>                   <span class="n">protocol</span><span class="p">;</span>       <span class="cm">/* 4 层协议 (TCP/UDP) */</span>
  <span class="n">__u16</span>     <span class="n">daf</span><span class="p">;</span>    <span class="cm">/* 目标地址族 */</span>
  <span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">;</span>
  <span class="cm">/* 统计和计时器 */</span>
  <span class="n">refcount_t</span>    <span class="n">refcnt</span><span class="p">;</span>   <span class="cm">/* 引用计数 */</span>
  <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>    <span class="cm">/* 定时器 */</span>
  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">timeout</span><span class="p">;</span>  <span class="cm">/* 超时时长 */</span>

  <span class="cm">/* Flags and state transition */</span>
  <span class="n">spinlock_t</span>              <span class="n">lock</span><span class="p">;</span>           <span class="cm">/* 锁定状态转换 */</span>
  <span class="k">volatile</span> <span class="n">__u16</span>          <span class="n">state</span><span class="p">;</span>          <span class="cm">/* state 信息 */</span>
  <span class="k">volatile</span> <span class="n">__u16</span>          <span class="n">old_state</span><span class="p">;</span>      
  <span class="n">__u32</span>     <span class="n">fwmark</span><span class="p">;</span>   <span class="cm">/* 来自skb的防火墙标志 */</span>
  <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">sync_endtime</span><span class="p">;</span> <span class="cm">/* jiffies + sent_retries */</span>

  <span class="cm">/* 管理字段 */</span>
  <span class="k">struct</span> <span class="n">ip_vs_conn</span>       <span class="o">*</span><span class="n">control</span><span class="p">;</span>       <span class="cm">/* Master control connection */</span>
  <span class="n">atomic_t</span>                <span class="n">n_control</span><span class="p">;</span>      <span class="cm">/* Number of controlled ones */</span>
  <span class="k">struct</span> <span class="n">ip_vs_dest</span>       <span class="o">*</span><span class="n">dest</span><span class="p">;</span>          <span class="cm">/* real server */</span>
  <span class="n">atomic_t</span>                <span class="n">in_pkts</span><span class="p">;</span>        <span class="cm">/* incoming packet counter */</span>

  <span class="cm">/* 发送方式，DR、NAT、Tunnel 都会使用不同的方式进行数据包的转发，
     会根据不同的转发方式，返回 netfilter 结果，如 NF_STOLEN、NF_ACCEPT */</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">packet_xmit</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
         <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">);</span>
  <span class="cm">/* 下面几个成员主要用于 NAT 模式
   */</span>
  <span class="k">struct</span> <span class="n">ip_vs_app</span>        <span class="o">*</span><span class="n">app</span><span class="p">;</span>           <span class="cm">/* bound ip_vs_app object */</span>
  <span class="kt">void</span>                    <span class="o">*</span><span class="n">app_data</span><span class="p">;</span>      <span class="cm">/* Application private data */</span>
  <span class="k">struct</span> <span class="n">ip_vs_seq</span>        <span class="n">in_seq</span><span class="p">;</span>         <span class="cm">/* incoming seq. struct */</span>
  <span class="k">struct</span> <span class="n">ip_vs_seq</span>        <span class="n">out_seq</span><span class="p">;</span>        <span class="cm">/* outgoing seq. struct */</span>

  <span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_pe</span> <span class="o">*</span><span class="n">pe</span><span class="p">;</span>
  <span class="kt">char</span>      <span class="o">*</span><span class="n">pe_data</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">pe_data_len</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">rcu_head</span>   <span class="n">rcu_head</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>具体转发模式的绑定使用 <code class="language-plaintext highlighter-rouge">ip_vs_bind_xmit</code> 函数，根据每个连接的不同，绑定转发模式：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ip_vs_bind_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">IP_VS_FWD_METHOD</span><span class="p">(</span><span class="n">cp</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">IP_VS_CONN_F_MASQ</span><span class="p">:</span>
    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">packet_xmit</span> <span class="o">=</span> <span class="n">ip_vs_nat_xmit</span><span class="p">;</span> <span class="c1">// NAT 模式</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">IP_VS_CONN_F_TUNNEL</span><span class="p">:</span>
      <span class="n">cp</span><span class="o">-&gt;</span><span class="n">packet_xmit</span> <span class="o">=</span> <span class="n">ip_vs_tunnel_xmit</span><span class="p">;</span> <span class="c1">// Tunnel 模式</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">IP_VS_CONN_F_DROUTE</span><span class="p">:</span>
    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">packet_xmit</span> <span class="o">=</span> <span class="n">ip_vs_dr_xmit</span><span class="p">;</span> <span class="c1">// DR 模式</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">IP_VS_CONN_F_LOCALNODE</span><span class="p">:</span>
    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">packet_xmit</span> <span class="o">=</span> <span class="n">ip_vs_null_xmit</span><span class="p">;</span>  <span class="c1">// Null 模式，用于本地地址</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">IP_VS_CONN_F_BYPASS</span><span class="p">:</span>
    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">packet_xmit</span> <span class="o">=</span> <span class="n">ip_vs_bypass_xmit</span><span class="p">;</span> <span class="c1">// 当目标 RS 不可用时，让数据包绕，可能只用缓存</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当一个 <code class="language-plaintext highlighter-rouge">来源方</code> 请求到达 <code class="language-plaintext highlighter-rouge">LVS</code> 服务器后，<code class="language-plaintext highlighter-rouge">LVS</code> 会首先根据指定元数据信息和 <code class="language-plaintext highlighter-rouge">CT</code> 策略，查找当前来源
是否已经有存在的连接，如果有将会通过存在的连接，将请求转发到后端 <code class="language-plaintext highlighter-rouge">RS</code>，如果没有那么就创建一个新的连接
并且将新建的连接保存。</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>客户端请求 -&gt; LVS -&gt; 是否已经存在连接 -是-&gt; 复用已存在的连接 -&gt; 发送到 RS -&gt; 结束
                                    |                     /|\
                                   \|/                     |
                                    否      -&gt;        新建连接并保存 
</code></pre></div></div>

<h2 id="ip_vs_xmit">ip_vs_xmit</h2>

<p>常用的将 <code class="language-plaintext highlighter-rouge">LVS</code> 接收到的来源数据包转发到 RS 服务器上的模式核心的三种：<code class="language-plaintext highlighter-rouge">[DR](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_xmit.c#L1435)</code>、<code class="language-plaintext highlighter-rouge">[NAT](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_xmit.c#L765)</code>、<code class="language-plaintext highlighter-rouge">[Tunnel](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_xmit.c#L1133)</code></p>

<h3 id="dr">DR</h3>
<p><code class="language-plaintext highlighter-rouge">[DR](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_xmit.c#L1435)</code> （Director）相对容易理解。核心点在目标 <code class="language-plaintext highlighter-rouge">MAC</code> 地址上，通过修改目标 <code class="language-plaintext highlighter-rouge">MAC</code> 地址可以完成这种方案。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">ip_vs_dr_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="o">*</span><span class="n">ipvsh</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">local</span><span class="p">;</span>
  <span class="c1">// 根据元数据信息查找目的服务的路由信息</span>
  <span class="n">local</span> <span class="o">=</span> <span class="n">__ip_vs_get_out_rt</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">ipvs</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">ip</span><span class="p">,</span>
           <span class="n">IP_VS_RT_MODE_LOCAL</span> <span class="o">|</span>
           <span class="n">IP_VS_RT_MODE_NON_LOCAL</span> <span class="o">|</span>
           <span class="n">IP_VS_RT_MODE_KNOWN_NH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ipvsh</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">local</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">tx_error</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ip_vs_send_or_cont</span><span class="p">(</span><span class="n">NFPROTO_IPV4</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">ip_send_check</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
  <span class="c1">// 不允许分片</span>
  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ignore_df</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// 直接将修改好的数据包发送出去</span>
  <span class="n">ip_vs_send_or_cont</span><span class="p">(</span><span class="n">NFPROTO_IPV4</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="ip_vs_app">ip_vs_app</h2>

<p><code class="language-plaintext highlighter-rouge">ip_vs_app</code> 是通过 LVS 实现了应用层协议的一个框架。为应用层提供了接口，对一些特殊的应用可以进行特殊的处理。
目前只支持应用层 <code class="language-plaintext highlighter-rouge">FTP</code> 协议。</p>

<p>具体详情查看：<a href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_ftp.c">ip_vs_ftp.c</a>、<a href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_app.c">ip_vs_app.c</a></p>

<h1 id="知识串联">知识串联</h1>

<p>通过整个分析来，LVS 核心的代码主要集中在:<a href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_conn.c">ip_vs_conn.c</a>、<a href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_core.c">ip_vs_core.c</a>、<a href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_ctl.c">ip_vs_ctl.c</a> 、<a href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_xmit.c">ip_vs_xmit.c</a>四个个代码文件。分别负责：连接相关、核心流程、对外接口、转发模式。</p>

:ET