---
title: Kubernetes-内部信息
date: 2021-09-27 11:47:05
categories: 
	- [gRPC]
tags:
  - microservices
  - Kubernetes
  - k8s
author: Jony
---

# 资源信息

Kubernetes 总体以资源为中心做系统，资源是 Kubernetes 中最重要的概念。
Kubernetes 将资源再次分组和版本化，形成 Group、Version、Resource。

- Group 被称为资源组，在 Kubernetes API Server 中也称其为 APIGroup。
- Version 被称为资源版本，在 Kubernetes API Server 中也可以被称为 APIVersions。
- Resource 被称为资源，在 Kubernetes API Server 中也可称其为 APIResource。
- Kind 被称为资源种类，描述 Resource 的种类，与 Resource 为同一个级别。

资源组、资源版本、资源、子资源的完整表现形式为 `<group>/<version>/<resource>/<subresource>`。常用的
 Deployment 资源的完整表现形式就是 `apps/v1/deployments/status`。

```golang
type TypeMeta struct {
  Kind string `json:"kind,omitempty" protobuf:"bytes,1,opt,name=kind"`
  APIVersion string `json:"apiVersion,omitempty" protobuf:"bytes,2,opt,name=apiVersion"`
}
```

`TypeMeta` 大部分的资源类型都继承了当前类型，`TypeMeta` 主要作用就定义类型的属性。

```golang
type ObjectMeta struct {
  // 资源对象的名称
  Name string `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
  // 如果Name为空，系统这为该对象生成一个唯一的名字
  GenerateName string `json:"generateName,omitempty" protobuf:"bytes,2,opt,name=generateName"`
  Namespace string `json:"namespace,omitempty" protobuf:"bytes,3,opt,name=namespace"`
  // 对象的URL，由系统生成
  SelfLink string `json:"selfLink,omitempty" protobuf:"bytes,4,opt,name=selfLink"`
  // 对象的唯一ID，由系统生成
  UID types.UID `json:"uid,omitempty" protobuf:"bytes,5,opt,name=uid,casttype=k8s.io/kubernetes/pkg/types.UID"`
  // 见下文
  ResourceVersion string `json:"resourceVersion,omitempty" protobuf:"bytes,6,opt,name=resourceVersion"`
  Generation int64 `json:"generation,omitempty" protobuf:"varint,7,opt,name=generation"`
  // 对象创建时间，由系统生成
  CreationTimestamp Time `json:"creationTimestamp,omitempty" protobuf:"bytes,8,opt,name=creationTimestamp"`
  // 对象删除时间，指针类型说明是可选的，当指针不为空的时候说明对象被删除了，也是由系统生成
  DeletionTimestamp *Time `json:"deletionTimestamp,omitempty" protobuf:"bytes,9,opt,name=deletionTimestamp"`
  // 对象被删除前允许优雅结束的时间，单位为秒
  DeletionGracePeriodSeconds *int64 `json:"deletionGracePeriodSeconds,omitempty" protobuf:"varint,10,opt,name=deletionGracePeriodSeconds"`
  // 对象标签，这个是我们经常用的，不用多解释了
  Labels map[string]string `json:"labels,omitempty" protobuf:"bytes,11,rep,name=labels"`
  // 批注，这个和标签很像，但是用法不同，比如可以用来做配置
  Annotations map[string]string `json:"annotations,omitempty" protobuf:"bytes,12,rep,name=annotations"`
  // 该对象依赖的对象类表，如果这些依赖对象全部被删除了，那么该对象也会被回收
  OwnerReferences []OwnerReference `json:"ownerReferences,omitempty" patchStrategy:"merge" patchMergeKey:"uid" protobuf:"bytes,13,rep,name=ownerReferences"`
  Finalizers []string `json:"finalizers,omitempty" patchStrategy:"merge" protobuf:"bytes,14,rep,name=finalizers"`
  ClusterName string `json:"clusterName,omitempty" protobuf:"bytes,15,opt,name=clusterName"`
  ManagedFields []ManagedFieldsEntry `json:"managedFields,omitempty" protobuf:"bytes,17,rep,name=managedFields"`
}
```
**`ResourceVersion`: 资源版本，版本可以理解为对象在时间轴上的一个时间节点，代表着对象最后一次更新的时刻。如果说`Name`
是在 `Namespace` 空间下唯一，那么ResourceVersion则是同名、同类型对象时间下唯一。因为同名对象在不同时间可能会更新、删
除再添加，在比较两个对象谁比较新的情况非常有用，比如Watch。**

同样 `ObjectMeta` 大部分 API 对象都继承了他，`ObjectMeta` 主要定了一些公共的属性，即所有对象都应该具备的属性。
使用过 `kubectl describe` 就可以看到熟悉的字段

> **总结：相同类型的所有对象的 TypeMeta 都是相同的，ObjectMeta 属于公共属性，相同类型对象之间可能是不同的**

`ObjectMeta` 展现的是单数形式，而对象资源总会复数形式出现，那么对于复数形式的元数据信息查找使用 `ListMeta`：

```golang
type ListMeta struct {
  SelfLink string `json:"selfLink,omitempty" protobuf:"bytes,1,opt,name=selfLink"`
  ResourceVersion string `json:"resourceVersion,omitempty" protobuf:"bytes,2,opt,name=resourceVersion"`
  // 下次获取时的起始位置，类似于 limit 分页标记
  Continue string `json:"continue,omitempty" protobuf:"bytes,3,opt,name=continue"`
  // 根据Continue 计算还剩多少对象
  RemainingItemCount *int64 `json:"remainingItemCount,omitempty" protobuf:"bytes,4,opt,name=remainingItemCount"`
}
```
> 总结：在metav1包中，为API单体对象和对象列表的公共属性(meta)做了抽象，分别为metav1.Object和 metav1.ListInterface
> metav1包为这两个抽象做了实现，他们分别为metav1.ObjectMeta和metav.listMeta
> API对象类型可以通过继承这些类实现抽象

根据代码显示 **TypeMeta** 实现了 `schema.ObjectKind` 接口，`schema.ObjectKind` 的主要作用就是对所有 API 对象类型的 `meta` 的抽象。
代码如下：

```golang
type ObjectKind interface {
  SetGroupVersionKind(kind GroupVersionKind)
  GroupVersionKind() GroupVersionKind
}
func (obj *TypeMeta) GroupVersionKind() schema.GroupVersionKind {
  return schema.FromAPIVersionAndKind(obj.APIVersion, obj.Kind)
}
func (obj *TypeMeta) GroupVersionKind() schema.GroupVersionKind {
  return schema.FromAPIVersionAndKind(obj.APIVersion, obj.Kind)
}
// 这个方法在 TypeMeta 实现 GroupVersionKind 的时候被调用
// 主要通过 ParseGroupVersion 实现从 apiVersino 获取 Group 和 Version 信息 
func FromAPIVersionAndKind(apiVersion, kind string) GroupVersionKind {
  if gv, err := ParseGroupVersion(apiVersion); err == nil {
    return GroupVersionKind{Group: gv.Group, Version: gv.Version, Kind: kind}
  }
  return GroupVersionKind{Kind: kind}
}
// GVK 比较好理解核心类型
type GroupVersionKind struct {
  Group   string
  Version string
  Kind    string
}
// 从 apiVersion 解析 Group 和 Version 信息
func ParseGroupVersion(gv string) (GroupVersion, error) {
  if (len(gv) == 0) || (gv == "/") {
    return GroupVersion{}, nil
  }
  // 统计 / 出现的次数
  switch strings.Count(gv, "/") {
  case 0:
    // 未出现说明Group就是空字符串，系统默认会把空字符串归为core
    return GroupVersion{"", gv}, nil
  case 1:
    // 出现一个 就以 Group/Version 的形式
    i := strings.Index(gv, "/")
    return GroupVersion{gv[:i], gv[i+1:]}, nil
  default:
    return GroupVersion{}, fmt.Errorf("unexpected GroupVersion string: %v", gv)
  }
}
```

总结：
1. `ObjectKind` 是所有API 对象类型的抽象
2. `TypeMeta` 是 `ObjectKind` 的一个实现。其 API 对象通过基础 TypeMeta 自动实现 `ObjectKind`


`schema.ObjecKind` 是所有`API对象类型`的抽象，[`metav1.Object`](pkg/apis/meta/v1/meta.go) 是所有 API 单体对象的公共属性，
如果有个方法需要访问 `API对象类型` 同时还要访问 API 单体对象的公共属性，代码如下：

```golang
type Unstructured struct {
  Object map[string]interface{}
}
// 来自于 schema.ObjecKind
func (u *Unstructured) GroupVersionKind() schema.GroupVersionKind {
  gv, err := schema.ParseGroupVersion(u.GetAPIVersion())
  if err != nil {
    return schema.GroupVersionKind{}
  }
  gvk := gv.WithKind(u.GetKind())
  return gvk
}
// 来自于 metav1.Object
func (u *Unstructured) GetNamespace() string {
  return getNestedString(u.Object, "metadata", "namespace")
}

```
访问方式：

```golang
func (resourceAccessor) GenerateName(obj runtime.Object) (string, error) {
  accessor, err := Accessor(obj)
  if err != nil {
    return "", err
  }
  return accessor.GetGenerateName(), nil
}
```

一般传入的类型都是面向所有 API 对象类型的抽象。`schema.ObjecKind` （`runtime.Object` 实现了 ObjectKind） 为了
访问公共属性通过 `Accessor` 方法类控制强制转换类型。代码如下：

```golang
func Accessor(obj interface{}) (metav1.Object, error) {
  // golang 获取 type 类型
  switch t := obj.(type) {
    //如果继承了metav1.ObjectMeta，也就自然实现了metav1.Object
  case metav1.Object:
    return t, nil
  case metav1.ObjectMetaAccessor:
    if m := t.GetObjectMeta(); m != nil {
      return m, nil
    }
    return nil, errNotObject
  default:
    return nil, errNotObject
  }
}
```


1. runtime.Object是所有API单体对象的根类(interface)；
1. schema.ObjectKind是对API对象类型的抽象(interface)；
1. metav1.Object是对API对象公共属性的抽象(interface)；
1. metav1.ListInterface是对API对象列表公共属性的抽象(interface)；
1. metav1.TypeMeta是schema.ObjectKind的一个实现，API对象类型继承之；
1. metav1.ObjectMeta是metav1.Object的一个实现，API对象类型继承之；
1. metav1.ListMeta是metav1.ListInterface的一个实现，API对象列表继承之；