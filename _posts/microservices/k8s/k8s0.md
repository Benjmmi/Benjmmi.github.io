---
title: Kubernetes-理论体系化的学习 k8s
date: 2021-04-01 17:29:11
categories: 
	- [gRPC]
tags:
  - microservices
  - Kubernetes
  - k8s
author: Jony
---

# 知根知底

Kubernetes，又称为 k8s 或者简称为 "kube" ，是一种可**自动实施** [Linux 容器](https://linuxcontainers.org/)操作的开源平台。原先的容器化过程需要很多手动部署和扩展操作。

如果体验不到，那可能是容器化过程在公司以及规模化了，如果个人搭建容器化的过程觉得还不算苦难，
但是如果需要管理亿级、十亿或者更高数量级容器时如何更高效的节省人力。所以 k8s 就是 `DevOps` 管理平台，可以提供所需的编排和管理功能，以便您针对这些工作负载大规模部署容器。

历史：Google 每周会启用超过 20 亿个容器——全都由内部平台 Borg 支撑。Borg 是 
`Kubernetes` 的前身，多年来开发 Borg 的经验教训成了影响 Kubernetes 中许多技术的主要因素。

## 常见术语

- **容器集（Pod）**： k8s 通过将容器分类组成的"容器集" ，Pod 是 Kubernetes 的原子对象
- **主机（Master）**：用于控制 Kubernetes 节点的计算机。所有任务分配都来自于此
- **节点（Node）**：负责执行请求和所分配任务的计算机。由 Kubernetes 主机负责对节点进行控制
- **复制控制器（Replication controller）**：用于控制应在集群某处运行的完全相同的容器集副本数量
- **服务（Service）**：将工作内容与容器集分离
- **Kubelet**：运行在节点上的服务，可读取容器清单（container manifest），确保指定的容器启动并运行。


# 设计准则

- **安全**：它应遵循最新的安全最佳实践
- **易于使用**：它应能通过一些简单的命令进行操作
- **可扩展**：不应偏向于某一个提供商，而是能通过配置文件进行自定义

K8s 架构图：
![架构图](https://www.redhat.com/cms/managed-files/kubernetes_diagram-v3-770x717_0.svg)

架构图显示了各个部分之间的关系：

## 控制平面

k8s 的神经中枢，主要负责处理重要的工作，以确保容器以足够的梳理和所需的资源运行。控制平面会
一直与**计算机器**保持连接。

- **kube-apiserver**: 对外提供 REST API 让外部请求与集群进行交互
- **kube-scheduler**: 统计各个节点的资源使用情况，计算 Pod 的资源需求并下发到适合的节点
- **kube-controller-manager**: 负责实际运行集群，用户查询调度程序确保正确数量的容器集运行
- **etcd**: 配置数据以及集群状态的信息存储在 Etcd 中

## 集群机器-节点

Pod 经过调度和编排后，最终由每个节点承载运行。

- **kubelet**:与控制平面通信的微型应用。kubelet 确保容器在容器集内运行。
- **kube-proxy**: 用于优化 kubernetes 网络服务的网络代理。
- **容器运行时引擎**: 比如 Docker、由 OCI 标准接口定义


## 其他

- **存储仓库**: 持久卷等存储资源
- **容器镜像仓库**:存储容器镜像的仓库

# k8s 创建 Pod 运行流程

1. 外方客户端通过向 API Server 发起请求
2. 请求到达 API Server 以后，经过鉴权和验证之后。解析为指定数据格式存储到 Etcd 中
3. 相关 Reflector 通过控制循环监听 Etcd 中的数据变化，将数据下发到每个 Controller 
   继续处理相关数据信息
4. Controller 处理完之后，Pod 数据还没有分配节点信息
5. Scheduler 是一个单独的控制平面，与 Controller 一样监听数据的变化符合要求之后进行调和
6. Scheduler 根据调度算法找出适合的 Node 节点信息，创建 Binding 对象指定 Node 信息
   对应到 Pod 的 ObjectReference 字段信息，将信息发送到 kube-apiserver 
7. API Server 将数据信息设置到指定的 Pod 对象下
8. 到目前为止，我们看到的所有东西（状态），还只是存在于 etcd 中的元数据
9. kubelet 通过监听 kube-apiserver 获取属于本节点的 Pod 列表
10. 然后与自己本地缓存的 Pod 列表对比，如果有 Pod 创建、删除、更新等操作，就开始同步状态信息
11. kubelet 负责后期的 CRI 和 CNI 相关的接口对接，创建符合用户预期的容器实例

# k8s 内部/外部流量处理流程 - kube-proxy

Pod 创建完成之后最终还要要对外提供访问服务，所以 **kube-proxy** 就是默认的流量承载器。虽然目前大多数使用的
是第三方符合 CNI 规范的






根据上面的流程我们大概知道了每个组件的分工和职责。其中核心点就是 Etcd 的数据耦合。总体操作都是每个组件
通过数据约定来约束自己的行为和操作。





# 参考来源
- [K8s 原理：Kubernetes 架构解析](https://www.redhat.com/zh/topics/containers/kubernetes-architecture)
- [Kubernetes是什么?](https://www.redhat.com/zh/topics/containers/what-is-kubernetes)
- [实现细节](https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/implementation-details/)
- [术语表](https://kubernetes.io/zh/docs/reference/glossary/?fundamental=true)

