---
layout: post
title: "flowable4"
keywords: ""
description: ""
tagline: ""
date: '2024-08-12 14:00:37 +0800'
category: linux
tags: linux
---
> {{ page.description }}


使用 ChatGPT 理解源码

# 前言
对于业务型的系统还是考虑其设计和应用,源码深入剖析远远没有必要,只需要点到为止即可。

`Flowable` 是 Fork 了 Activiti 的分支，基础结构基本一样，在功能特性上做了一些细微的调整。Flowable 支持 [BPMN](https://tkjohn.github.io/flowable-userguide/#bpmn20) SOP规范

# FLowable 现有异步执行器配置能力解析

代码来源: `org.flowable.job.service.impl.asyncexecutor.AsyncJobExecutorConfiguration`

```java
    /**
     * Whether the thread for acquiring async jobs will be started.
     * This can be used to boot up engine instances that still execute jobs originating from this instance itself,
     * but don't fetch new jobs themselves.
     */
    private boolean asyncJobAcquisitionEnabled = true;
    /**
     * Whether the thread for acquiring timer jobs will be started.
     */
    private boolean timerJobAcquisitionEnabled = true;
    /**
     * Whether the thread for resetting expired jobs will be started.
     */
    private boolean resetExpiredJobEnabled = true;
```

**asyncJobAcquisitionEnabled**:控制是否启动获取异步作业的线程(默认true)。
    
    主要功能：
        - 决定是否启动一个线程来获取和执行异步作业。如果设置为false，引擎实例将不会获取新的异步作业，但仍可以执行当前已被该实例获取的作业。

**timerJobAcquisitionEnabled**:控制是否启动获取定时器作业的线程(默认true)。
    
    主要功能：
        - 决定是否启动一个线程来获取和执行定时器作业。定时器作业是基于时间触发的作业，例如某个时间点需要执行的任务。

**resetExpiredJobEnabled**:控制是否启动重置过期作业的线程(默认true)。
    
    主要功能：
        - 该线程负责检查和重置那些被某个执行器锁定但未能及时执行的作业。作业可能因某种原因（如系统崩溃）未完成，此线程会将这些作业解锁，使它们可被其他执行器重新获取和执行。

```java
    /**
     * Whether to unlock jobs that are owned by this executor (have the same lockOwner) at startup or shutdown.
     */
    private boolean unlockOwnedJobs = true;
```    

**unlockOwnedJobs**:控制在启动或关闭时是否解锁当前执行器所拥有的作业(默认true)。
    
    主要功能：
        - 当执行器启动或关闭时，它可以选择解锁那些被它自身锁定的作业（即拥有相同lockOwner的作业）。这可以防止作业在执行器关闭后继续被锁定，无法被其他执行器获取。

```java
    /**
     * Whether runnable for acquiring  timer jobs should be enabled
     */
    private boolean timerRunnableNeeded = true; // default true for backwards compatibility (History Async executor came later)

    /**
     * The name of the thread in which async jobs will be acquired.
     */
    private String acquireRunnableThreadName;
    /**
     * The name of the thread in which expired jobs will be reset.
     */
    private String resetExpiredRunnableName;
```

**timerRunnableNeeded**:控制是否启用用于获取定时器作业的可运行任务（Runnable）(默认true)。
    
    主要功能：
       - 该配置决定是否需要启动一个独立的线程来定期获取并处理定时器作业。定时器作业是根据时间触发的作业，这些作业在满足特定时间条件时被引擎获取并执行。
       - 默认值为true，以确保向后兼容，因为历史异步执行器（History Async Executor）是在后期引入的。

**acquireRunnableThreadName**:设置获取异步作业的线程名称
    
    主要功能：
        - 该配置允许为负责获取异步作业的线程指定一个自定义名称，以便更容易地在监控和调试时识别该线程。

**resetExpiredRunnableName**:设置重置过期作业的线程名称。
   
    主要功能：
        - 该配置允许为负责重置过期作业的线程指定一个自定义名称，以便更容易地在监控和调试时识别该线程。
        - 过期作业是指那些已被锁定但未能及时执行的作业，重置过期作业的线程会定期检查并解锁这些作业，使其可再次被获取和执行。

```java
    /**
     * How large should the thread pool for moving timer jobs be.
     */
    private int moveTimerExecutorPoolSize = 4;
    /**
     * How many timer jobs should be acquired in one acquisition.
     */
    private int maxTimerJobsPerAcquisition = 512;
    /**
     * How many async / history jobs should be acquired in one acquisition.
     */
    private int maxAsyncJobsDuePerAcquisition = 512;
```

**moveTimerExecutorPoolSize**:设置用于处理定时器作业的线程池大小(默认4)。
    
    主要功能：
        - 该配置项决定用于处理定时器作业的线程池中线程的数量。线程池中的线程负责执行定时器作业，如处理到期的任务。
        - 通过调整该值，可以控制并发处理定时器作业的能力。增加线程池大小可以提高同时处理多个定时器作业的能力，但也会增加系统的资源消耗。

**maxTimerJobsPerAcquisition**:设置每次获取的定时器作业的最大数量(默认512)。
    
    主要功能：
        - 该配置项决定每次从数据库中获取的定时器作业的最大数量。当定时器作业执行线程从数据库中获取作业时，会按此数量限制获取的作业数量。
        - 通过调整该值，可以控制每次批量获取的定时器作业数量。增加获取量可以减少获取频率，提高处理效率，但可能会导致单次处理时间增加。

**maxAsyncJobsDuePerAcquisition**：设置每次获取的异步作业或历史作业的最大数量(默认512)。
    
    主要功能：
        - 该配置项决定每次从数据库中获取的异步作业或历史作业的最大数量。与定时器作业类似，异步作业执行线程会根据此值限制每次获取的作业数量。
        - 通过调整该值，可以控制每次批量获取的异步作业数量。增加获取量可以减少获取频率，提高处理效率，但可能会导致单次处理时间增加。

```java
    /**
     * The time the timer acquisition thread should wait before executing the next acquire logic.
     */
    private Duration defaultTimerJobAcquireWaitTime = Duration.ofSeconds(10);
    /**
     * The time the async job acquisition thread should wait before executing the next acquire logic.
     */
    private Duration defaultAsyncJobAcquireWaitTime = Duration.ofSeconds(10);
    /**
     * The time the acquisition thread should wait when the queue is full before executing the next acquire logic.
     */
    private Duration defaultQueueSizeFullWaitTime = Duration.ofSeconds(5);
```
**defaultTimerJobAcquireWaitTime**:设置定时器作业获取线程在每次执行获取逻辑之间的等待时间(默认10s)。
    
    主要功能：
        - 该配置项决定了定时器作业获取线程在完成一次作业获取后，等待多长时间再进行下一次获取操作。这有助于控制定时器作业的获取频率。
        - 如果设置较短的等待时间，线程将更频繁地尝试获取作业，从而可能提高作业的及时性处理，但会增加系统的负载。
        - 如果设置较长的等待时间，线程获取作业的频率降低，系统负载减少，但可能导致作业处理的延迟。

**defaultAsyncJobAcquireWaitTime**:设置异步作业获取线程在每次执行获取逻辑之间的等待时间(默认10s)
    
    主要功能：
        - 该配置项决定了异步作业获取线程在完成一次作业获取后，等待多长时间再进行下一次获取操作。这有助于控制异步作业的获取频率。
        - 通过调整此值，可以在作业处理及时性与系统负载之间取得平衡。

**defaultQueueSizeFullWaitTime**:设置当队列已满时，作业获取线程在执行下一次获取逻辑之前的等待时间。(默认5s)

    主要功能：
        - 当作业获取线程发现用于处理作业的队列已满时，它会等待一段时间再尝试获取新的作业。这可以防止系统在高负载下频繁尝试获取新作业，造成不必要的资源消耗。
        - 通过设置合理的等待时间，可以在作业处理能力饱和的情况下，平衡作业获取和系统资源的消耗。

```java
    /**
     * The value that should be used when locking async / timer jobs.
     * <p>
     * When a job is acquired, it is locked so other async executors can't lock and execute it.
     * While doing this, the 'name' of the lock owner is written into a column of the job.
     * <p>
     * By default, a random UUID will be generated when the executor is created.
     * <p>
     * It is important that each async executor instance in a cluster of Flowable engines has a different name!
     */
    private String lockOwner = UUID.randomUUID().toString();
```
**lockOwner**:

    - `lockOwner` 是一个标识符，用于指示哪个执行器实例已经锁定了某个异步作业或定时器作业。当一个作业被获取并准备执行时，Flowable会在作业记录中写入这个lockOwner，表示该作业已被某个执行器锁定。
锁定是为了确保在分布式环境中，一个作业不会被多个执行器同时执行。如果作业被锁定，其他执行器将无法获取并执行该作业，直到锁被释放。
    - 锁定是为了确保在分布式环境中，一个作业不会被多个执行器同时执行。如果作业被锁定，其他执行器将无法获取并执行该作业，直到锁被释放。

**默认行为**：

    - 默认情况下，当执行器实例被创建时，lockOwner 被设置为一个随机生成的UUID。这确保了每个执行器在默认情况下都会有一个唯一的标识符，从而避免不同实例之间的冲突。



```java
    /**
     * The amount of time a timer job is locked when acquired.
     * During this period of time, no other async executor will try to acquire and lock this job.
     */
    private Duration timerLockTime = Duration.ofHours(1);
    /**
     * The amount of time an async job is locked when acquired.
     * During this period of time, no other async executor will try to acquire and lock this job.
     */
    private Duration asyncJobLockTime = Duration.ofHours(1);
```
**timerLockTime**:设置定时器作业被获取并锁定后的锁定时间。默认1小时

    主要功能：
        - 当定时器作业被某个执行器获取并锁定后，该作业将在指定的timerLockTime时间内保持锁定状态。期间，其他执行器将无法获取和处理该作业。
        - 这确保了作业在锁定期间只被一个执行器处理，防止重复执行。

**asyncJobLockTime**:设置异步作业被获取并锁定后的锁定时间。默认1小时

    主要功能：
        - 当异步作业被某个执行器获取并锁定后，该作业将在指定的asyncJobLockTime时间内保持锁定状态。期间，其他执行器将无法获取和处理该作业。
        - 这确保了异步作业在处理过程中不会被多个执行器重复处理。

```java
    /**
     * Whether global acquire lock should be used.
     */
    protected boolean globalAcquireLockEnabled;
    /**
     * The prefix that the runnable should use for the global acquire lock.
     * Setting a different prefix allows differentiating different engines / executors without them competing for the same lock.
     */
    protected String globalAcquireLockPrefix = "";
```
**globalAcquireLockEnabled**:控制是否启用全局获取锁（Global Acquire Lock）。

    主要功能：
        - 当启用全局获取锁时，Flowable引擎会在作业获取过程中使用一个全局锁来防止多个引擎实例或执行器同时获取和处理相同的作业。
        - 这个锁可以确保在集群或多节点环境中，同一时刻只有一个实例能够获取作业，避免冲突和重复处理。

**globalAcquireLockPrefix**:为全局获取锁设置前缀。
    主要功能：
        - 设置全局获取锁的前缀，可以用于区分不同的引擎实例或执行器，使它们在获取作业时使用不同的锁。这对于同一集群中运行多个不同的Flowable引擎实例尤其有用。
        - 通过设置不同的前缀，多个引擎实例或执行器可以在不相互干扰的情况下各自独立地获取和处理作业。

```java
    /**
     * The amount of time the async job acquire thread should wait to acquire the global lock.
     */
    private Duration asyncJobsGlobalLockWaitTime = Duration.ofMinutes(1);
    /**
     * The poll rate of the async job acquire thread for checking if the global lock has been released.
     */
    private Duration asyncJobsGlobalLockPollRate = Duration.ofMillis(500);
    /**
     * The amount of time after the last global lock acquire time the lock will be forcefully acquired.
     * This means that if for some reason another node did not release the lock properly because it crashed
     * another node will be able to acquire the lock.
     */
    private Duration asyncJobsGlobalLockForceAcquireAfter = Duration.ofMinutes(10);
    /**
     * The amount of time the timer job acquire thread should wait to acquire the global lock.
     */
    private Duration timerLockWaitTime = Duration.ofMinutes(1);
    /**
     * The poll rate of the timer job acquire thread for checking if the global lock has been released.
     */
    private Duration timerLockPollRate = Duration.ofMillis(500);
    /**
     * The amount of time after the last global lock acquire time the lock will be forcefully acquired.
     * This means that if for some reason another node did not release the lock properly because it crashed
     * another node will be able to acquire the lock.
     */
    private Duration timerLockForceAcquireAfter = Duration.ofMinutes(10);
```        
**asyncJobsGlobalLockWaitTime**:设置异步作业获取线程在尝试获取全局锁时等待的时间。(默认5m)

    主要功能：
        - 当异步作业获取线程试图获取全局锁但该锁已被其他节点持有时，线程会等待此时间后再尝试获取锁。这有助于防止频繁的锁竞争，同时确保系统能够在适当的时间内获取锁。

**asyncJobsGlobalLockPollRate**:设置异步作业获取线程检查全局锁是否已释放的轮询频率。(默认500ms)

    主要功能：
        - 当异步作业获取线程处于等待状态时，它会以此频率检查全局锁是否已被释放。如果锁被释放，线程将尝试重新获取锁。

**asyncJobsGlobalLockForceAcquireAfter**:设置在上次全局锁获取后，强制重新获取锁的时间。(默认10m)

    主要功能：
        - 如果某个节点获取了全局锁，但由于崩溃或其他原因未能释放锁，这个配置项允许其他节点在指定时间后强制获取锁。这样可以防止锁被永久持有，确保系统的稳定性和可用性。

**timerLockWaitTime**:设置定时器作业获取线程在尝试获取全局锁时等待的时间。(默认1m)

    主要功能：
        - 类似于异步作业的锁定逻辑，当定时器作业获取线程试图获取全局锁但锁已被其他节点持有时，线程会等待此时间后再尝试获取锁。

**timerLockPollRate**:设置定时器作业获取线程检查全局锁是否已释放的轮询频率。(默认500ms)

    主要功能：
        - 当定时器作业获取线程等待全局锁释放时，它会以此频率进行检查，确保在锁释放后能及时获取锁。

**timerLockForceAcquireAfter**:设置在上次全局锁获取后，强制重新获取锁的时间。(默认10m)

    主要功能：
        - 允许在指定时间后强制获取定时器作业的全局锁，以防止锁因节点崩溃或其他问题而长期未释放。

```java
    /**
     * The time the reset expired jobs thread should wait before executing the next reset logic.
     * Expired jobs are jobs that were locked (a lock owner + time was written by some executor, but the job was never completed).
     * During such a check, jobs that are expired are again made available, meaning the lock owner and lock time will be removed.
     * Other executors will now be able to pick it up.
     * A job is deemed expired if the current time has passed the lock time.
     */
    private Duration resetExpiredJobsInterval = Duration.ofMinutes(1);
    /**
     * The amount of expired jobs that should be rest in one cycle.
     */
    private int resetExpiredJobsPageSize = 3;
```
**resetExpiredJobsInterval**:设置重置过期作业的线程在执行下一次重置逻辑前的等待时间。(默认1m)

    主要功能：
        - 该配置项决定了系统在重置过期作业前的等待时间，即每隔多长时间，Flowable引擎会检查是否有作业已经过期，并重置这些作业。
        - 过期作业是指那些已经被某个执行器锁定（即分配了lockOwner和lockTime），但在规定的锁定时间内没有完成的作业。这种作业需要被重新释放，以便其他执行器可以获取并重新执行它们。    

**resetExpiredJobsPageSize**:设置在一次重置周期中，重置过期作业的最大数量。(默认3)

    主要功能：
        - 该配置项决定了在每次执行重置逻辑时，最多可以重置的过期作业数量。通过限制一次性处理的作业数量，可以控制重置过程对系统资源的占用，避免系统负载过大。
        - 该值可以根据系统的实际需求和性能情况进行调整，以平衡作业重置速度和系统资源占用之间的关系。

# 图片
![](){:width="100%"}

---
参考：
- [](){:target='blank'}
- [](){:target='blank'}
