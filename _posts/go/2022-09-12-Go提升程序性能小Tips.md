---
layout: post
title: "Go提升程序性能小Tips"
keywords: ""
description: ""
tagline: ""
date: '2022-09-12 15:30:19'
category: golang
tags: golang,go,性能
---

# 小Tips

Golang 性能非常高，但是禁不住无节制的挥霍，所以在编代码后如果需要对性能的把控可以参考一些Coder 总结的规律:

1. 指针传递只占用了 4 字节(32位)或者 8 字节(64)位。所以在方法调用过程中如果遇到需要占用大量内存或者很多变量的情况下，采用指针传递可以减少内存占用和提高效率
2. `[N]int` 是数组,`[]int` 才是 `slice`，数组被分配在栈中生命周期比较短，`Slice > 32KB` 的才会被分配在堆中，显然 Stack 内存分配速度要大于堆分配
3. `strcut`、`string` 内存占用比较大的情况下使用指针，小则简单的栈存值即可
4. 变量的生命周期比较长的使用指针，减少栈增长和分配，提高内存使用率防止栈溢出。否则使用值传递，


所谓的逃逸分析最基本的情况就是：`如果一个函数返回对一个变量的引用，那么它就发生逃逸。`
所以判断一个变量是否发生逃逸在编译器编译的时候就已经确定了，不需要程序员去判断，但是可以根据代码经验判断出哪里会发生逃逸。
编译器判断方式：
1. 如果函数外部没有引用，则优先放到栈中；定义了一个很大的数组，需要申请的内存过大，超过了栈的存储能力（32KB）分配到堆上。
2. 如果函数外部存在引用，则必定放到堆中;


**数据区存储全局初始化数据区/静态数据区：**
该区包含了在程序中**明确被初始化的全局变量、已经初始化的静态变量**（包括全局静态变量和局部静态变量）和常量数据（如字符串常量


**未初始化数据区（bss）**
存入的是**全局未初始化变量和未初始化静态变量**。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（nil）。

**尽量不要将引用对象赋值给引用对象.**

为什么值类型不会逃逸而引用类型会逃逸呢？这是因为在  new(Obj) 对象的创建时,编译器先是分析 Obj 对象可能分配在堆上,同时成员变量 A 和 B 也为引用类型,为了保证不出现栈回收后,导致对象 Obj 的成员值也被回收,所以n A 和 B 需要逃逸.

但是,如果 A 和 B 为值类型,那么编译器虽然初步分析 Obj 会分配在堆上,但由于main主函数结束后,变量都会被回收,也就是说对象没有被其他引用,
那么就都会分配在栈上,所以 A 和 B 没有发生逃逸.


# 图片
![](){:width="100%"}

---
参考：
- [](){:target='blank'}
- [](){:target='blank'}
