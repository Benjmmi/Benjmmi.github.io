<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title> [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        



  <div class="article">
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/24/ebpf/2021-02-24-Program_Types/">
            6. Program_Types
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>XDP 负责宿主机到宿主机之间的负载均衡，进入的流量会被统一拦截和转发
TC 负责宿主机到容器之间的流量转发，进入、发出的流量会被统一拦截和转发

术语per-packet cost ：每包成本，处理一个网络数据包的成本hairpinning：发卡模式。hairpinskb: sock_buffer...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-24
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/24/ebpf/2021-02-24-iproute2/">
            5. iproute2
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>2.3 iproute2文档连接Linux BPF 3.2、BPF and XDP Reference Guide[译] Cilium：BPF 和 XDP 参考指南（2019）BPF and XDP Reference GuideBPF 辅助函数BPF man 文档
...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-24
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/24/ebpf/2021-02-24-C_Programs_For_eBPF/">
            4. C BPF 编程规范
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>C BPF 代码注意事项用 C 语言编写 BPF 程序不同于用 C 语言做应用开发，有一些陷阱需要注意。本节列出了 二者的一些不同之处。
1. 所有函数都需要内联（inlined）、不支持函数调用（对于老版本 LLVM）、不支持共享库调用BPF 不支持共享库（Shared libraries）。但是...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-24
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/24/ebpf/2021-02-24-ebpf-toolchain/">
            3. eBPF 工具链
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>工具链
本节介绍 BPF 相关的用户态工具、内省设施（introspection facilities）和内核控制选项。 注意，围绕 BPF 的工具和基础设施还在快速发展当中，因此本文提供的内容可能只覆 盖了其中一部分。
Ubuntu123$ sudo apt-get install -y make...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-24
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/22/ebpf/2021-02-22-eBPF-translate/">
            2. eBPF 翻译文档合集
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>注意：本文档部分针对的是希望深入了解BPF和XDP的开发人员和用户。尽管阅读本参考指南可能有助于拓宽你对Cilium的理解，但使用Cilium并不是必须的。请参考入门指南和概念以获得更高级别的介绍。

BPF是Linux内核中高度灵活和高效的类似虚拟机的构造，允许以安全的方式在各种挂起点执行字节码。...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-22
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/20/ebpf/2021-02-20-notebook/">
            eBPF 相关文档阅读笔记
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>BPF 是 Linux 内核中 一个高度灵活与高效的类虚拟机（virtual machine-like） 组件，它以一种安全的方式在许多 hook 点执行字节码（bytecode ）。很多 内核子系统 都已经使用了 BPF，比如常见的网络（networking）、跟踪（tracing）与安全 （se...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-20
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/08/ebpf/2021-02-08-index/">
            1. eBPF 基本了解和入门
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>eBPF 的 e 就是 extended 的缩写。所以 eBPF 就是，BPF 字节码过滤器的增强版。
学习建议方式

初学会用 bcc 工具
中级会用 bpftrace 开发
高级开发  bcc 工具，并贡献

Ubuntu 安装 bcc ：
1sudo apt-get install bpfcc...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-08
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/08/io_uring/ref-liburing/2021-02-08-submission/">
            Submission
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>介绍提交I&amp;#x2F;O请求的顺序通常是这样的:
12345678/* 获取一个 SQE */struct io_uring_sqe *sqe = io_uring_get_sqe(ring);/* 设置一个 readv 操作 */io_uring_prep_readv(sqe, file_fd, ...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-08
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/08/io_uring/ref-liburing/2021-02-08-setup_teardown/">
            设置和删除
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>本节将介绍一些函数，帮助您在程序中设置和删除io_uring。
struct io_uring
123456struct io_uring &amp;#123;    struct io_uring_sq sq;    struct io_uring_cq cq;    unsigned flags;   ...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-08
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/08/io_uring/ref-liburing/2021-02-08-supported_caps/">
            支持的功能
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>允许您检查支持的操作和功能的函数。
struct io_uring_probe
1234567struct io_uring_probe &amp;#123;    __u8 last_op;   /* last opcode supported */    __u8 ops_len;   /* lengt...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-08
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/08/io_uring/ref-liburing/2021-02-08-cqe/">
            CQE:完成队列条目
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>内核为每个提交的队列条目添加了一个完成队列事件(CQE)。CQE 包含作为 SQE 的一部分提交的操作的状态。作为内核处理 SQE 的结果，只有一个 CQE 添加到完成队列中。这两者之间存在一一对应的关系。
# 注意
这个结构是原始输入输出接口的一部分，在输入输出接口中定义。

12345struc...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-08
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/08/io_uring/ref-liburing/2021-02-08-sqe/">
            SQE:提交队列条目
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>提交队列条目(SQE)是用来告诉 io_uring 你想要做什么，比如读取一个文件，写一个文件，监听一个 socket 上的连接等等。
# 注意
这个结构是原始 io_uring 接口的一部分，在 io_uring.h 中定义。

struct io_uring_sqe123456789101112...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-08
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/08/io_uring/tutorial/2021-02-08-register_eventfd/">
            注册一个eventfd
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>关于 eventfd(2) 系统调用的细节不在讨论范围内。你可能需要查看 eventfd(2) man 页面来了解该系统调用的描述。 eventfd(2) 是一个 Linux 特有的同步机制。
io_uring 能够在事件完成时在eventfd实例上发布事件。该功能允许使用 poll(2) 或 ep...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-08
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/07/io_uring/tutorial/2021-02-07-sq_poll/">
            轮询提交队列
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>减少系统调用的次数是 io_uring 的一个主要目的。为此， io_uring 允许你提交I&amp;#x2F;O请求，而不需要进行一次系统调用。这是通过 io_uring 支持的一个特殊的提交队列轮询功能实现的。在这种模式下，当你的程序设置了轮询模式后， io_uring 就会启动一个特殊的内核线程，轮...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-07
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/07/io_uring/tutorial/2021-02-07-fixed_buffers/">
            固定缓冲区
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>使用固定缓冲区的思想是这样的:您提供一组用iovec结构体数组描述的缓冲区，并使用 [io_uring_register_buffers()](https://unixism.net/loti/ref-liburing/advanced_usage.html#c.io_uring_register_...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-07
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/07/io_uring/tutorial/2021-02-07-link_liburing/">
            请求链
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>在io_uring中，完成没有按照提交的问题所在的顺序到达。这在底层io_uring接口一章中讨论过。如果您想要强制某些操作按顺序进行，该怎么办?这可以通过将请求链实现。这里的示例向您展示了如何实现这一点。
1234567891011121314151617181920212223242526272...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-07
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/07/io_uring/tutorial/2021-02-07-probe_liburing/">
            探测支持功能
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>下面的程序演示了如何使用 io_uring_get_probe() 。它打印出是否支持某个操作。

A program to print details about supported and unsupported operations

12345678910111213141516171819...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-07
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/07/io_uring/tutorial/2021-02-07-webserver_liburing/">
            liburing 实现 web 服务器
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>liburing 实现 web 服务器我们在介绍中讨论过，因为 select(2)、 poll(2)和 epoll(7)报告对本地&amp;#x2F;常规文件的操作始终处于就绪状态，所以像 libuv (这个 NodeJS 底层实现)这样的库使用单独的线程池来处理文件 i&amp;#x2F;o。 io_uring ...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-07
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/07/io_uring/tutorial/2021-02-07-cp_liburing/">
            liburing 实现 cp 命令
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>liburing 实现 cp 命令在前面的小节中，我们看到了如何使用liburing提供的高级接口来构建相当于Unix cat的工具。然而，在这两个例子中，我们队列没有同时处理超过一个请求。 io_uring的目标之一是能够通过让用户同时排队几个操作来减少系统调用的数量，这样内核就可以一下子接收并处...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-07
            </span>
          
        </div>
      </div>
    
      <div class="article-item">
        <h2 class="article-item-header">
          <a href="/2021/02/07/io_uring/tutorial/2021-02-07-cat_liburing/">
            liburing 实现 cat 命令
          </a>
        </h2>
        <div class="article-item-content">
          
            <p>cat 使用 liburing 实现我们看到，用io_uring构建一个读取文件的程序这么简单的东西，可能并不那么简单。事实证明，与读取同步 i&amp;#x2F;o 文件的程序相比，它的代码更多。但是，如果你分析使用底层 io _ uring 接口的 cat 实用程序的代码，你会发现大部分代码都是重复代码...</p>
          
        </div>
        <div class="atricle-item-time">
          
            <span>
              2021-02-07
            </span>
          
        </div>
      </div>
    
  </div>



    <div class="pagenator">
    
    
        <a class="extend prev" href="page/5">上一页</a>
    

    
        
        
            <a class="extend page-item page-item-normal" href="/">1</a>
        
    
        
        
            <a class="extend page-item page-item-normal" href="page/2">2</a>
        
    
        
        
            <a class="extend page-item page-item-normal" href="page/3">3</a>
        
    
        
        
            <a class="extend page-item page-item-normal" href="page/4">4</a>
        
    
        
        
            <a class="extend page-item page-item-normal" href="page/5">5</a>
        
    
        
            <span class="extend page-item page-item-select">6</span>
        
        
    
        
        
            <a class="extend page-item page-item-normal" href="page/7">7</a>
        
    
    
    
    
        <a class="extend next" href="page/7">下一页</a>
    
</div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
