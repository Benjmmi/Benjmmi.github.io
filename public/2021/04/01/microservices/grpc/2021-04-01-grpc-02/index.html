<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>从微服务角度理解 gRPC [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">从微服务角度理解 gRPC</h1>
<article class="post markdown-style">
  <h1 id="GRPC"><a href="#GRPC" class="headerlink" title="GRPC"></a>GRPC</h1><p>grpc 本质上还是 RPC 框架，为了远程调用而产生的一个产物。所以尝试从微服务的角度是看 gRPC 。</p>
<p>微服务主要涉及：服务注册、服务发现、服务调用。主要的还是这三个功能，其他的熔断、限流的不过是在这三个基础上增加的新功能。</p>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>服务注册主要的功能就是将用户写的服务经过扫描存储到同一个地方，然后等待用户的请求时，将对应的服务取出来执行并返回结果。所以这里首先看的是如何扫描。</p>
<p>简单实现一个服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreeterImpl</span> <span class="keyword">extends</span> <span class="title class_">HelloServiceGrpc</span>.HelloServiceImplBase &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayFuchGrp</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloResponse&gt; responseObserver)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getName();</span><br><span class="line">        <span class="type">HelloResponse</span> <span class="variable">response</span> <span class="operator">=</span> HelloResponse.newBuilder().setReply(name + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;hahahhhaa&quot;</span>).build();</span><br><span class="line">        responseObserver.onNext(response);</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            server = ServerBuilder.forPort(port)</span><br><span class="line">                    .addService(<span class="keyword">new</span> <span class="title class_">GreeterImpl</span>())</span><br><span class="line">                    .build()</span><br><span class="line">                    .start();</span><br><span class="line">	&#125;                    </span><br></pre></td></tr></table></figure>


<p>从这里看可以发现是通过手动注册一个服务到 gRPC 的注册中心。看下 addService 的详细过程，因为主要看注册中心的功能管理，所以启动相关的分析直接忽略或者查看参考文档。通过 Debug 跟踪主要涉及三个 class 文件：<code>AbstractServerImplBuilder</code>、<code>ServerImplBuilder</code>、<code>InternalHandlerRegistry</code>，这三个文件基本已经涵盖了服务注册到注册中心的整个流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  AbstractServerImplBuilder</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> T <span class="title function_">addService</span><span class="params">(BindableService bindableService)</span> &#123;</span><br><span class="line">   delegate().addService(bindableService);</span><br><span class="line">   <span class="keyword">return</span> thisT();</span><br><span class="line"> &#125;</span><br><span class="line"> 	<span class="comment">// ServerImplBuilder</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> ServerImplBuilder <span class="title function_">addService</span><span class="params">(BindableService bindableService)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> addService(checkNotNull(bindableService, <span class="string">&quot;bindableService&quot;</span>).bindService());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> ServerImplBuilder <span class="title function_">addService</span><span class="params">(ServerServiceDefinition service)</span> &#123;</span><br><span class="line">   registryBuilder.addService(checkNotNull(service, <span class="string">&quot;service&quot;</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// InternalHandlerRegistry</span></span><br><span class="line">   Builder <span class="title function_">addService</span><span class="params">(ServerServiceDefinition service)</span> &#123;</span><br><span class="line">     System.out.println(getClass() + <span class="string">&quot;,将接口注册到注册中心&quot;</span>);</span><br><span class="line">     services.put(service.getServiceDescriptor().getName(), service);</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从代码上看与 Spring 类似最后都将实例化的服务存放到了一个 HashMap 中，<code>Key</code> 就是服务名，<code>Value</code> 就是已经构建好的实例。这里可能需要看下 bindService 触发的时候做了哪些工作，Debug 进去之后就会进入通过 <code>protoc</code> 生成的 RPC 文件中，所以这里的 BindableService 就是所有 RPC 类的父类，通过统一的抽象方法来生成一个实例，绑定所有服务接口。这里也间接的说明方法支持二级路径调用。通过代码分析得知注册中心其实就是一个 HashMap 容器，将所有服务注册到容器里面方便调用。</p>
<h2 id="服务发现和服务调用"><a href="#服务发现和服务调用" class="headerlink" title="服务发现和服务调用"></a>服务发现和服务调用</h2><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>服务注册并启动成功后就可以对外提供服务，外部响应的接口也就可以发起调用。调用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// 创建 ManagedChannelImpl</span></span><br><span class="line">     <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ManagedChannelBuilder.forAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>).usePlaintext().build();</span><br><span class="line"><span class="comment">// 创建客户端 Stub     </span></span><br><span class="line">     HelloServiceGrpc.<span class="type">HelloServiceBlockingStub</span> <span class="variable">stub</span>  <span class="operator">=</span> HelloServiceGrpc.newBlockingStub(channel);</span><br><span class="line">     <span class="type">HelloRequest</span> <span class="variable">request</span> <span class="operator">=</span> HelloRequest.newBuilder().setName(<span class="string">&quot;fadsfasfsafsafsafdsf&quot;</span>).build();</span><br><span class="line">     <span class="comment">// 发起 RPC 调用，获取响应</span></span><br><span class="line">     <span class="type">HelloResponse</span> <span class="variable">response</span> <span class="operator">=</span> stub.sayFuchGrp(request);</span><br><span class="line">     System.out.println(<span class="string">&quot;返回结果 ==========&gt;&quot;</span> +response.toString());</span><br><span class="line">     channel.shutdown();</span><br></pre></td></tr></table></figure>
<p>（忽略注释行）第一行代码就是连接远程服务，底层使用到了 Netty 的 Bootstrap。 第二第三行只是声明了调用方式和构建一个参数，真正的调用再第四行。所以主要分析第四行代码，看客户端如何连接服务端发起远程调用。</p>
<p><strong>ManagedChannel 提供了接口式的切面 ClientInterceptor，它可以拦截 RPC 客户端调用，注入扩展点，以及功能定制，方便框架的使用者对 gRPC 进行功能扩展。</strong></p>
<p>主要过程如下：</p>
<ol>
<li>客户端 Stub 调用 sayFuchGrp 发起 RPC 调用</li>
<li>通过 DnsNameResolver 进行域名解析，然后使用负载均衡策略，选择具体实例</li>
<li>如果和具体实例没有可用连接，则创建一个新的连接</li>
<li>对消息做序列化，然后通过 stream 发送给服务端</li>
<li>接收到服务端响应后做反序列化操作</li>
<li>回掉环境阻塞的客户都按线程，获取响应</li>
</ol>
<p>因为主要分析请求和寻址，所以主要分析步骤2、3、4。先来看下主要流程经过的类：HelloServiceGrpc、ClientCall、ForwardingManagedChannel、ManagedChannelImpl 。主要涉及的就是这三个类。<br>因为整体调用时异步，所以会涉及很多的上下文切换，但是核心的点还是很明显：1. 异步何时发起调用，2.异步如何获取返回结果。</p>
<h3 id="异步何时发起调用"><a href="#异步何时发起调用" class="headerlink" title="异步何时发起调用"></a>异步何时发起调用</h3><p>在 ManagedChannel 创建之后，ManagedChannel 会创建一个新的 ClientCall 实例。ClientCall 的用途是业务应用层的消息调度和处理，典型用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClientCall&lt;ReqT, RespT&gt; call = channel.newCall(method,callOptions);</span><br><span class="line">GrpcFuture&lt;RespT&gt; responseFuture = <span class="keyword">new</span> <span class="title class_">GrpcFuture</span>&lt;&gt;(call);</span><br><span class="line">startCall(call, responseListener);</span><br><span class="line">call.sendMessage(req);</span><br><span class="line">call.halfClose();</span><br><span class="line">call.request(<span class="number">1</span>);</span><br><span class="line"><span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> responseFuture.get();</span><br></pre></td></tr></table></figure>

<p>在创建 call 的时候传入了两个参数，分别是 method 和 callOptions，method 是 <code>MethodDescriptor</code> 的实例，由类名就可以知道是一个方法的描述，具体看下 <code>MethodDescriptor</code> 都有什么内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MethodDescriptor</span>&lt;ReqT, RespT&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MethodType type; <span class="comment">// 调用方式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String fullMethodName; <span class="comment">// 方法名称</span></span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> <span class="keyword">final</span> String serviceName; <span class="comment">// 服务名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Marshaller&lt;ReqT&gt; requestMarshaller; <span class="comment">//请求序列化方式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Marshaller&lt;RespT&gt; responseMarshaller; <span class="comment">//响应序列化方式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Object schemaDescriptor; <span class="comment">// 方法的模式描述符。方便服务器反射服务使用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> idempotent;  <span class="comment">// 返回此方法是否为幂等函数。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> safe; <span class="comment">// 返回此方法是否安全。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> sampledToLocalTracing; <span class="comment">// 是否可以将此方法的RPC采样</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicReferenceArray&lt;Object&gt; rawMethodNames = <span class="keyword">new</span> <span class="title class_">AtomicReferenceArray</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>根据字段可以判断 <code>MethodDescriptor</code> 主要存储一些调用时需要使用到的基本信息，callOptions 主要存放 RPC 调用调用时附加信息，例如超时、鉴权、长度限制和线程池等，选项可以从 <code>ClientCalls</code> 中获取常用的值。跟踪 newCall 最后调用的是新建一个 <code>PendingCall</code> 的实例。</p>
<p>当 Calls 实例化完成之后，就会调用 startCall 和 sendMessage 方法，startCall 后面单独分析。sendMessage 的调用主要是为了完成请求对象的序列化和 HTTP2 Frame 的初始化。sendMessage 会调用 如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (stream <span class="keyword">instanceof</span> RetriableStream) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    RetriableStream&lt;ReqT&gt; retriableStream = (RetriableStream&lt;ReqT&gt;) stream;</span><br><span class="line">    retriableStream.sendMessage(message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stream.writeMessage(method.streamRequest(message));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 知道 end_stream 为 true 才会调用 flush</span></span><br><span class="line"><span class="keyword">if</span> (!unaryRequest) &#123;</span><br><span class="line">  stream.flush();</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

<p>通过方法分析，发现在 sendMessage 之前 MethdoDescriptor 将 requestMessage 转成了 InputStream 类型，看下这 InputStream 类型的实现 ProtoInputStream 接收了两个参数：MessageLite 和 Parser。Parser 好解释就是之前说的 Request 序列化工具，MessageLite 看注释大概就是 Protocol Message 对象实现的抽象接口。在基础资源受限时使用 LITE_RUNTIME ，在基础资源比较大时使用 CODE_SIZE，以牺牲性能为代价更好的压缩。具体可能需要了解 protobuf 的实现了，这里大概就这个意思吧。</p>
<p>消息被转为 InputStream 类型之后就会进入 stream.writeMessage 方法继续往下跟踪会到跟踪到 <code>MessageFramer.writeKnownLengthUncompressed</code> 这里大概的意思就是写出没有经过序列化已知长度和为压缩的数据，会再次将数据转存存放到一个 ByteBuffer 中，最后 ByteBuffer 中的数据格式如下：</p>
<p><img src="/Benjamin.Yim/assets/images/grpc/grpc_payload.png" alt="ByteBuffer 数据格式"></p>
<p>将数据转存写出完成后，会调用 Message.close 方法以此释放原有的资源，所以这里整个流程看下来 sendMessage 并非 <code>send Message</code> 只是将消息进行了序列化和格式化处理。然后接下来调用的时 halfClose 方法。halfClose -&gt; endOfMessages -&gt; close -&gt; commitToSink -&gt; deliverFrame -&gt; writeFrameInternal -&gt;  新建 SendGrpcFrameCommand 类，将 请求 Frame 封装成自定义的 SendGrpcFrameCommand 放入写队列中。</p>
<p>配合流程图查看：</p>
<p><img src="/Benjamin.Yim/assets/images/grpc/grpc-02-11.png" alt="ByteBuffer 数据格式"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeFrameInternal</span><span class="params">(WritableBuffer frame, <span class="type">boolean</span> endOfStream, <span class="type">boolean</span> flush, <span class="keyword">final</span> <span class="type">int</span> numMessages)</span> &#123;</span><br><span class="line">     Preconditions.checkArgument(numMessages &gt;= <span class="number">0</span>);</span><br><span class="line">     <span class="type">ByteBuf</span> <span class="variable">bytebuf</span> <span class="operator">=</span> frame == <span class="literal">null</span> ? EMPTY_BUFFER : ((NettyWritableBuffer) frame).bytebuf().touch();</span><br><span class="line">     <span class="keyword">final</span> <span class="type">int</span> <span class="variable">numBytes</span> <span class="operator">=</span> bytebuf.readableBytes();</span><br><span class="line">     <span class="keyword">if</span> (numBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       onSendingBytes(numBytes);</span><br><span class="line">       writeQueue.enqueue(<span class="keyword">new</span> <span class="title class_">SendGrpcFrameCommand</span>(transportState(), bytebuf, endOfStream), flush)</span><br><span class="line">           .addListener(...);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       writeQueue.enqueue(</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">SendGrpcFrameCommand</span>(transportState(), bytebuf, endOfStream), flush);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>然后由 WriteQueue 异步执行 flush 将 SendGrpcFrameCommand 写入到 Netty 的 Channel 中，调用 Channel 的 write 方法，别 NettyClientHandler 拦截到，由 NettyClientHandler 负责具体的发送操作。SendGrpcFrameCommand 的顶层实现了 WriteQueue.QueuedCommand 接口所以可以由 WriteQueue 统一调度。</p>
<p>这里可能会有疑问就是 SendGrpcFrameCommand 写出数据是如何被 NettyClientHandler 拦截到然后再执行真实发送接口的。上面提到是将 SendGrpcFrameCommand 写入到 Netty 的 Channel 是在哪写入的，后来又在什么地方调用的 write 方法的。看看 WriteQueue 构造方法就是在新建一个 WriteQueue 的时候就已经创建好了一个 Channel ，还记得之前说的 startCall 么，在调用 startCall 的时候如果没有连接会创建一个新的连接，这个时候创建的就是 Netty 连接自然就包含了 Channel 实例，所以这里创建 Channel 先终止，后面分析。然后继续查看 WriteQueue 异步执行之后就调用 write 方法这里才是正式调用写出接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">  channel.write(<span class="built_in">this</span>, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用 write 接口之后会被 NettyClientHandler 拦截到，也就是 Netty pipeline 的处理过程，在这里会调用 sendGrpcFrame 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendGrpcFrame</span><span class="params">(ChannelHandlerContext ctx, SendGrpcFrameCommand cmd, ChannelPromise promise)</span> &#123;</span><br><span class="line">    encoder().writeData(ctx, cmd.stream().id(), cmd.content(), <span class="number">0</span>, cmd.endStream(), promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 Http2ConnectionEncoder writeData 方法之后就进入了最终的写出数据的流程。</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>基本上服务注册与调用服务流程就这么多，但是中间有个环节没有分析那就是服务发现就是刚才没有分析的 startCall 流程。整个服务发现与创建连接的流程都在这里。接下来分析下 startCall 。</p>
<p>startCall 是在 newCall 之后被调用的但是并没有发起真正的调用，也就是说 startCall 可能在创建一个新的连接并做了很多初始化的操作。跟踪代码下来会发现主要有两个方法被调用：<code>(DelayedClientCall)call.start</code> 和 <code>responseListener.onStart</code> 。<code>(DelayedClientCall)call.start</code> 方法的注释：<strong>启动一个调用，使用responseListener处理响应消息。它必须在这个类的任何其他方法之前被调用，除了可以在任何时候被调用的cancel。</strong> 直接说明了这个方法是用来处理响应结果的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Listener&lt;RespT&gt; listener, <span class="keyword">final</span> Metadata headers)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">if</span> (!savedPassThrough) &#123;</span><br><span class="line">        listener = delayedListener = <span class="keyword">new</span> <span class="title class_">DelayedListener</span>&lt;&gt;(listener);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">          realCall.start(finalListener, headers);</span><br><span class="line">      ...</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>两个参数：listen 就是用来监听返回结果的回调，Metadata 则是gRPC 自定义的一个 Header。继续 debug 查看 <code>(ClientStreamProvider)realCall.start</code> 方法。</p>
<p><code>(UnaryStreamToFuture)responseListener.onStart</code> 方法最后会调用 <code>(ClientStreamProvider)realCall.request -&gt;(DelayedStream)stream.request</code> 方法。 </p>
<p>NettyClientHandler 调用 Http2ConnectionEncoder 的 writeData 方法，将 Frame 写入到 HTTP2 Stream 中完成请求的发送。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a target="_blank" rel="noopener" href="https://ilily.site/grpc-01/">gRPC 源码阅读系列</a></p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../../2021-04-01-miscro4/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../../k8s/2021-04-01-k8s1/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
