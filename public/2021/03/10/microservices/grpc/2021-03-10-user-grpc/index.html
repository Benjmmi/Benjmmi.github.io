<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>gRPC 学习 - 简单使用 [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">gRPC 学习 - 简单使用</h1>
<article class="post markdown-style">
  <h2 id="gRPC-简单使用"><a href="#gRPC-简单使用" class="headerlink" title="gRPC 简单使用"></a>gRPC 简单使用</h2><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>Protobuf 是谷歌推出的一宗轻便高效的结构和的数据存储格式，把结构和的数据序列化。常用以存储数据、作为网络通信的数据载体。具有多种编程语言的 API、跨平台和可扩展的特性。比 JSON 、XML 更小解析速度更快、更易于上手。</p>
<h3 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h3><p>写一个 Proto 文件</p>
<figure class="highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.example.grpc&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;HelloWorldProto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Greeting</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloResp</span> &#123;</span><br><span class="line">    <span class="type">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> sayFuchGrpc (Greeting) <span class="keyword">returns</span> (HelloResp)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成 protobuf 类，但是并没有生成 RPC 调用关系，所以还需要继续使用一个命令</p>
<p><code>protoc --java_out=./ --proto_path=./ helloworld.proto</code></p>
<p>生成 RPC 类，需要使用 <a target="_blank" rel="noopener" href="https://repo1.maven.org/maven2/io/grpc/protoc-gen-grpc-java/">protoc-gen-grpc-java</a> ，可以下载适合自己得版本，这里使用得是：<code>protoc-gen-grpc-java-1.36.0-windows-x86_64.exe</code><br>使用命令：</p>
<p><code>protoc --plugin=protoc-gen-grpc-java=&quot;D:/Software/protobuf-3.12.4/protoc-gen-grpc-java-1.36.0-windows-x86_64.exe&quot; --grpc-java_out=./src hello_world.proto</code></p>
<p>将生成：<em>HelloWorldGrpc.java</em> 文件</p>
<p>服务端编写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.grpc.Server;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ServerBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreeterServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">50051</span>;</span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerBuilder.forPort(port)</span><br><span class="line">                    .addService(<span class="keyword">new</span> <span class="title class_">GreeterImpl</span>())</span><br><span class="line">                    .build()</span><br><span class="line">                    .start();</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            server.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;server shutdown&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端编写代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannelBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreeterClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ManagedChannelBuilder.forAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">50051</span>).usePlaintext().build();</span><br><span class="line">        HelloServiceGrpc.<span class="type">HelloServiceBlockingStub</span> <span class="variable">stub</span>  <span class="operator">=</span> HelloServiceGrpc.newBlockingStub(channel);</span><br><span class="line">        <span class="type">HelloResponse</span> <span class="variable">response</span> <span class="operator">=</span> stub.sayFuchGrp(HelloRequest.newBuilder().setName(<span class="string">&quot;123456 up shan play triger&quot;</span>).build());</span><br><span class="line">        System.out.println(response.toString());</span><br><span class="line">        channel.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功输出：<br>	reply: “123456 up shan play triger:hahahhhaa”</p>
<h2 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h2><p>Client 与 Server ，均通过 Netty Channel 作为数据通信，序列化、反序列化使用 Protobuf，每个请求都将被封装成 HTTP2 得 Stream，在生命周期内，Channel 得应用应该属于长连接，并不需要重复去创建，直至关闭 Channel。目的就是为了<strong>连接复用</strong>提高效率。</p>
<p><em>默认情况下 ServerProvider 使用 Netty 作为服务提供者,即使用 NettyServerBuilder</em></p>
<p>跟踪代码将会看到 <code>io.grpc.netty.NettyServer</code> </p>
<ol>
<li>创建 <code>ServerBootstrap</code> ,设定 <code>BossGroup</code> 和 <code>WorkerGroup</code> 线程池</li>
<li>添加 <code>ChannelFactory</code> ,使用的是 <code>new ReflectiveChannelFactory&lt;&gt;(epollServerChannelType())</code></li>
<li>注册 <code>childHandler</code> ，用来处理客户端连接中的请求帧</li>
<li>bind 到指定的 <code>port</code> ，即内部初始化 <code>ServerSocketChannel</code> 等，开始侦听和接受客户端连接</li>
<li><code>BossGroup</code> 中的线程用于 accept 客户端连接，并转发给 <code>WorkerGroup</code> 中的线程，如果没有指定就会默认 static 共享对下，线程池大小默认为 1</li>
<li><code>workerGroup</code> 中的特定线程用于初始化客户端连接，初始化 <code>pipeline</code> 和 <code>handler</code> ，并将其注册到 <code>worker</code> 线程的 <code>selector</code> 上。每个 <code>worker</code> 线程独占一个 <code>selector</code>。默认大小 coreSize*2</li>
<li><code>selector</code> 上发送读写时间后，获取时间所属的连接句柄，然后指定 <code>handler（inbound）</code> ，同时拆分 <code>package</code> 。<code>handler</code> 执行完毕后，数据写入有 <code>outbound handler</code> 处理通过连接发出。</li>
<li><code>channelType</code>：默认为 <code>NioServerSocketChannel</code>。</li>
<li><code>followControlWindow</code>：流量控制的窗口大小，单位：字节，默认值为 1M HTTP2 中的 <code>Flow Control</code> 特性</li>
<li><code>maxConcurrentCallPerConnection</code>：每个 connection 允许的最大并发请求书，默认值为 Integer.MAX_VALUE；标识此连接的未响应的 streams 个数的上限</li>
<li><code>maxMessageSize</code> ：每次调用允许发送的最大数据量，默认为 100M</li>
<li><code>maxHeaderListSize</code>：每次调用允许发送的 header 的最大条数据，默认 8192</li>
<li><code>protocolNegotiator</code>：协议协商工具类，用于支持 SSL、TLS 工具类。默认情况下：PlaintextProtocolNegotiator 使用的仍然是 HTTP 协议</li>
</ol>
<p><em><strong>注意：每个 <code>worker</code> 线程上的数据请求时是队列形式</strong></em><br><em><strong>Channel 是 NIO 的基本构造，代表的一个实体，可以看作传入或者传出的数据载体。因此可以被打开或者关闭、连接或者断开</strong></em></p>
<h2 id="addService-的作用"><a href="#addService-的作用" class="headerlink" title="addService 的作用"></a>addService 的作用</h2><p>addService 使用的是代理模式，每个 <code>gRPC</code> 生成的 Service 都有 <code>bindService</code> 方法。<code>gRPC</code>  通过硬编码的方式遍历这个 <code>service</code> 列表，将每个方法的调用过程都与<code>“被代理实例”</code>绑定。<code>bingService</code> 方法的最终目的是创建一个 <code>ServerServiceDefinition</code> 对象，内部创建了一个 <code>Map</code> ，<code>KEY</code> 就是 <code>Service</code>  方法的全名 <code>{package}.{service}.{method}</code>，value 就是这个方法的 gRPC 封装类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HelloServiceImplBase serviceImpl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> methodId;</span><br><span class="line"></span><br><span class="line">    MethodHandlers(HelloServiceImplBase serviceImpl, <span class="type">int</span> methodId) &#123;</span><br><span class="line">      <span class="built_in">this</span>.serviceImpl = serviceImpl;</span><br><span class="line">      <span class="built_in">this</span>.methodId = methodId;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Req request, io.grpc.stub.StreamObserver&lt;Resp&gt; responseObserver)</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (methodId) &#123;</span><br><span class="line">        <span class="keyword">case</span> METHODID_SAY_FUCH_GRP:</span><br><span class="line">          serviceImpl.sayFuchGrp((HelloRequest) request,</span><br><span class="line">              (io.grpc.stub.StreamObserver&lt;HelloResponse&gt;) responseObserver);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">final</span> io.grpc.ServerServiceDefinition <span class="title function_">bindService</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> io.grpc.ServerServiceDefinition.builder(getServiceDescriptor())</span><br><span class="line">          .addMethod(</span><br><span class="line">            getSayFuchGrpMethod(),</span><br><span class="line">            io.grpc.stub.ServerCalls.asyncUnaryCall(</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">MethodHandlers</span>&lt;</span><br><span class="line">                HelloRequest,</span><br><span class="line">                HelloResponse&gt;(</span><br><span class="line">                  <span class="built_in">this</span>, METHODID_SAY_FUCH_GRP)))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">`addService` 方法可以添加多个 `Service`，代表 Netty Server 可以添加多个 `Service`。`addService` 会把 service 保存在内部的一个 map 中，key 为 serviceName ，value 就是上述 bindService 生成的对象。</span><br><span class="line"></span><br><span class="line">既然对象都已经生成存储到 Map 中，那么 `gRPC` 服务端是如何解析 RPC 过程的？client 在调用的收会将调用的 `service` 名词 + `method` 信息保存在一个 `GRPC 保留` 的 header 中，那么服务端在接收到 stream （PS：h2c 中每个 stream 相当于一个请求）之后，通过获取这个特定 Header 信息，就可以知道这个 stream 要调用的相应的方法，然后就使用到来上诉的 service ，然后找个相应的方法，直接代理调用。然后返回执行结果。</span><br><span class="line"></span><br><span class="line">## Client 使用</span><br><span class="line"></span><br><span class="line">Client 使用 `ManagedChannelBuilder` 的 `provider`机制来决定创建哪种类型的客户端的 `Channel`（`NettyChannelBuilder` 和 `OkHttpChannelBuilder`）。</span><br><span class="line"></span><br><span class="line">通常情况下 Channel 是可以复用的，所以为了提高 Client 端的并发能力，我们可以创建连接池即多个 `ManagedChannel`，每次请求时选择其中一个 Channel 即可。</span><br><span class="line"></span><br><span class="line">`ManagedChannel` 是客户端最核心的 class，代表这逻辑上的 `channel`，底层持有一个物理的 `transport`，并负责维护当检测到其处于 `terminated` 的时候会重新创建。</span><br><span class="line"></span><br><span class="line">每个 Client SDK 都生成了 <span class="number">2</span> 中 stub：BlockingStub 和 FutureStub； BlockingStub 内部仍然使用的是 Future 机制，只是内部封装了**阻塞等待**的过程：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;ReqT, RespT&gt; RespT <span class="title function_">blockingUnaryCall</span><span class="params">(</span></span><br><span class="line"><span class="params">      Channel channel, MethodDescriptor&lt;ReqT, RespT&gt; method, CallOptions callOptions, ReqT req)</span> &#123;</span><br><span class="line">    <span class="type">ThreadlessExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadlessExecutor</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupt</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    ClientCall&lt;ReqT, RespT&gt; call = channel.newCall(method,</span><br><span class="line">        callOptions.withOption(ClientCalls.STUB_TYPE_OPTION, StubType.BLOCKING)</span><br><span class="line">            .withExecutor(executor));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ListenableFuture&lt;RespT&gt; responseFuture = futureUnaryCall(call, req);</span><br><span class="line">		...</span><br><span class="line">      <span class="keyword">return</span> getUnchecked(responseFuture);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;V&gt; V <span class="title function_">getUnchecked</span><span class="params">(Future&lt;V&gt; future)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> future.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">      <span class="keyword">throw</span> Status.CANCELLED</span><br><span class="line">          .withDescription(<span class="string">&quot;Thread interrupted&quot;</span>)</span><br><span class="line">          .withCause(e)</span><br><span class="line">          .asRuntimeException();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> toStatusRuntimeException(e.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>目前每次发起请求时都是通过 <code>channel</code> 创建新的 <code>Stub</code>，这会导致创建大量的 <code>Stub</code> 对象，当然 <code>Stub</code> 对象也是可以复用的，直到 Stub 状态异常。每个 Stub 都配置 deadline 时间，那么如果此 Stub 被使用的时长超过这个阈值，将会抛出 <em><strong>io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED</strong></em> 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> io.grpc.Channel <span class="title function_">resetChannel</span><span class="params">(io.grpc.ManagedChannel channel)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (channel.isShutdown() || channel.isTerminated())&#123;</span><br><span class="line">    <span class="keyword">return</span> ManagedChannelBuilder.forAddress(HOST, PORT).usePlaintext(<span class="literal">true</span>).build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> channel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ManagedChannelBuilder.forAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">50051</span>).usePlaintext().build();</span><br><span class="line">      resetChannel(channel)</span><br><span class="line">      HelloServiceGrpc.<span class="type">HelloServiceBlockingStub</span> <span class="variable">stub</span>  <span class="operator">=</span> HelloServiceGrpc.newBlockingStub(channel);</span><br><span class="line">      <span class="type">HelloResponse</span> <span class="variable">response</span> <span class="operator">=</span> stub.sayFuchGrp(HelloRequest.newBuilder().setName(<span class="string">&quot;123456 up shan play triger&quot;</span>).build());</span><br><span class="line">      System.out.println(response.toString());</span><br><span class="line">      channel.shutdown();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>对于批量调用的场景，建议使用 FutureStub，对于普通的业务类型 RPC，我们使用 BlockingStub。每个 RPC 方法的调用一开始都会创建一个 <strong>ClientCall</strong>，其内部封装了调用的方法、配置等。此后将会创建 Stream 对象，每个 Stream 对象都持有唯一的 streamId，它是 Transport 用于区分 Response 的凭证。最终所有调用的参数都封装在 Stream 中。在大多数的 RPC 调用中，请求参数报文都是分多次发送，所以 ClientCall 在创建时就已经绑定线程，所以数据发送总是哦他难过一个线程进行的所以不会有乱序的现象。同样在等待 Response 时，底层的 Netty 将会对 Response 报文进行解包，并根据 streamId <strong>分拣</strong> Response，同时唤醒相应的 ClientCalls 阻塞。</p>
<p><strong>注意：如果出现网络异常将会重置 Channel、StreamId</strong></p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a target="_blank" rel="noopener" href="http://www.iigrowing.cn/grpc_shi_shen_me.html">gRPC 是什么</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010129119/article/details/79361949#1-%E7%AE%80%E4%BB%8B">HTTP&#x2F;2 协议规范</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e57ca4fec26f">HTTP2 详解</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/u/yongshun/articles">永顺 专栏</a></p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../../../go/2021-03-10-gc/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../../../../08/microservices/grpc/2021-03-08-index/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
