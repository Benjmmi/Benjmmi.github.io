<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>Netty 学习 - 深入理解 1 [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">Netty 学习 - 深入理解 1</h1>
<article class="post markdown-style">
  <h1 id="Netty-深入理解"><a href="#Netty-深入理解" class="headerlink" title="Netty 深入理解"></a>Netty 深入理解</h1><p>先考虑几个问题：</p>
<ol>
<li>Netty 启动的时候会做些什么操作</li>
<li>Netty 初始化的时候需要做些什么操作</li>
<li>流量怎么进入 Netty 的，Netty 对其怎么做出处理的</li>
<li>流量在Netty 内部如何流转的</li>
<li>Netty 如何做到高并发的</li>
<li>Netty 的线程模型是怎么样的</li>
<li>Netty 十万个为什么</li>
</ol>
<h2 id="Netty-启动"><a href="#Netty-启动" class="headerlink" title="Netty 启动"></a>Netty 启动</h2><p>简单了解 Netty 之后，Netty 是如何将这些组件组织起来并完成指定的工作的。即：学习 Bootstrap 和 ServerBootstrap<br>\             &lt;interface&gt;<br>\				Closeable<br>\                  |<br>\			AbstractBootstrap<br>\           &#x2F;            \<br>\    ServerBootstrap   Bootstrap</p>
<h2 id="服务端-ServerBootStrap"><a href="#服务端-ServerBootStrap" class="headerlink" title="服务端 ServerBootStrap"></a>服务端 ServerBootStrap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); <span class="comment">// 1. 创建 EventLoopGroup</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">EchoServerHandler</span> <span class="variable">serverHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>();  <span class="comment">// 2.创建 ServerBootstrap</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();  </span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)   <span class="comment">// 3. 指定所使用得 NIO 传输 Channel </span></span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">             .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO)) <span class="comment">// 4. 使用指定得端口设置套接字地址</span></span><br><span class="line">             .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;  <span class="comment">// 5. 添加一个 EchoServerHandler 到自 Channel 得 ChannelPipeline</span></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                     <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                     p.addLast(<span class="keyword">new</span> <span class="title class_">EchoServerOutboundHandler</span>()); <span class="comment">// 添加 OutBoundHandler</span></span><br><span class="line">                     p.addLast(serverHandler);   <span class="comment">// 添加 ServerHandler</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(PORT).sync();   <span class="comment">// 6. 异步绑定服务器，调用 sync 方法阻塞等待知道绑定完成</span></span><br><span class="line">            f.channel().closeFuture().sync();      <span class="comment">// 7. 获取 Channel 得 CloseFuture 并且阻塞档期线程直到它完成</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();  <span class="comment">// 8. 关闭 EventLoopGroup 资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 4 处设置了了一个 InetSocketAddres。服务器将绑定到这个地址以监听新的连接请求。<br>在 5 处，使用了 ChannelInitializer ，一个新的子 Channel 将会被创建，而 ChannelInitializer 将会把 EchoServerHandler 添加到 pipeline 中，这个 ChannelHandler 将会收到有关入站得消息得通知。</p>
<p>整个逻辑步骤回顾一下：</p>
<ul>
<li>EchoServerHandler 实现了业务逻辑</li>
<li>main() 方法引导了服务器<ul>
<li>创建一个 ServerBootStrap 得实例以引导进和绑定服务器</li>
<li>创建并分配一个 NioEventLoopGroup 实例以进行事件得处理，如接收新连接以及读写数据</li>
<li>指定服务器绑定得本地 InetSocketAddress</li>
<li>使用一个 EchoServerHandler 得实例初始化每一个新的 Channel</li>
<li>调用 ServerBootstrap.bind 方法绑定服务器</li>
</ul>
</li>
</ul>
<p>直接剖析下 ServerBootstrap 干了啥：</p>
<ul>
<li>EventLoopGroup 将会有单独文章解析，简单来说就是一个轮询，不停得探测 IO 事件并处理 IO 事件，执行其任务</li>
<li>ServerBootstrap 是一个服务端启动类</li>
<li>group(bossGroup, workerGroup)，分配两个线程，一个不停得accept外面得连接，然后丢给第二个。第二个用于处理连接</li>
<li>channel(NioServerSocketChannel.class) 标识服务都启动得是 NIO 相关得 Channel</li>
<li>handler 标识服务器启动时，需要经过哪些流程</li>
<li>childHandler 标识一条新的连接进来之后，该怎么处理</li>
<li>b.bind(PORT).sync() 真正得启动过程，并绑定端口</li>
<li>f.channel().closeFuture().sync() 等待服务器关闭</li>
<li>bossGroup.shutdownGracefully();workerGroup.shutdownGracefully(); 关闭两组线程</li>
</ul>
<h2 id="深入细节"><a href="#深入细节" class="headerlink" title="深入细节"></a>深入细节</h2><p>ServerBootstrap 一系列的参数配置是将需要得参数保存到 filed。那最终得启动入口在 bind 这个方法里执行，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress)</span> &#123;</span><br><span class="line">       validate();  <span class="comment">// 验证必要得参数</span></span><br><span class="line">       <span class="keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="string">&quot;localAddress&quot;</span>)); <span class="comment">// 真正绑定</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里我们专注于两个细节：initAndRegister 和 doBind0，其中 init 负责初始化，register 负责注册，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    channel = channelFactory.newChannel();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    init(channel);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initAndRegister 主要专注于几个事情：</p>
<ol>
<li>新建一个 channel 对象</li>
<li>初始化这个 channel</li>
<li>将这个 channe 注册到某个对象</li>
</ol>
<p>在哪具体看下每个步骤得细节：</p>
<h3 id="1-新建一个-channel-对象"><a href="#1-新建一个-channel-对象" class="headerlink" title="1. 新建一个 channel 对象"></a>1. 新建一个 channel 对象</h3><p><code>channelFactory.newChannel();</code> 最终会调用到 <code>ReflectiveChannelFactory.newChannel()</code>   方法，可以在初始化 ChannelFactory 得时候可以看出来默认设置了 <code>ReflectiveChannelFactory</code> 。 代码略有删减</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectiveChannelFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">implements</span> <span class="title class_">ChannelFactory</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; constructor;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> &#123;</span><br><span class="line">		 <span class="built_in">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">newChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChannelException</span>(<span class="string">&quot;Unable to create Channel from class &quot;</span> + constructor.getDeclaringClass(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以注意到，方法最终是通过反射来创建一个对象，而这个 class 就是我们在 ServerBootstrap 中传入得 <code>NioServerSocketChannel.class</code> 。</p>
<p>剩下来得重心放到 <code>NioServerSocketChannel.class</code> 得创建上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioServerSocketChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractNioMessageChannel</span></span><br><span class="line">                             <span class="keyword">implements</span> <span class="title class_">io</span>.netty.channel.socket.ServerSocketChannel &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ChannelMetadata</span> <span class="variable">METADATA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelMetadata</span>(<span class="literal">false</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SelectorProvider</span> <span class="variable">DEFAULT_SELECTOR_PROVIDER</span> <span class="operator">=</span> SelectorProvider.provider();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title function_">newSocket</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannelConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NioServerSocketChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">        config = <span class="keyword">new</span> <span class="title class_">NioServerSocketChannelConfig</span>(<span class="built_in">this</span>, javaChannel().socket());</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;                        </span><br></pre></td></tr></table></figure>

<p>可以看见通过 SelectorProvider.openServerSocketChannel 创建一条服务端得 Channel，然后通过创建一个 <code>NioServerSocketChannelConfig</code> 其顶层接口为 <code>ChannelConfig</code> ，所以 ChannelConfig 也可以是 Netty 里面得一大核心模块，暂时忽略。继续深入父类构造器，最终将看到如下两个抽象类的构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractChannel</span> <span class="keyword">extends</span> <span class="title class_">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">AbstractChannel</span><span class="params">(Channel parent)</span> &#123;</span><br><span class="line">	    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">	    id = newId();</span><br><span class="line">	    unsafe = newUnsafe();</span><br><span class="line">	    pipeline = newChannelPipeline();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractNioChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractChannel</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="type">int</span> readInterestOp)</span> &#123;</span><br><span class="line">	    <span class="built_in">super</span>(parent);</span><br><span class="line">	    <span class="built_in">this</span>.ch = ch;</span><br><span class="line">	    <span class="built_in">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">	    <span class="comment">//...</span></span><br><span class="line">	    ch.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">	    <span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里简单得将前面创建出来得 ServerSocketChannel 保存到成员遍历，然后调用 ch.configureBlocking(false) 设置该 Channel 为非阻塞模式。<br><code>readInterestOp</code>  就是前面每层传入的 SelectionKey.OP_ACCEPT 。然后看下顶层的设计，新建的三大组件：</p>
<p><code>newId</code> 为每个 Channel 赋值一个唯一的 ID。<code>newUnsafe</code> ，在官方的解释中是实际的传输，并且必须从 I&#x2F;O 线程调用并且最好不允许用户代码调用。最后一个 <code>newChannelPipeline</code> 最终调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> <span class="title class_">SucceededChannelFuture</span>(channel, <span class="literal">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> <span class="title class_">VoidChannelPromise</span>(channel, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> <span class="title class_">TailContext</span>(<span class="built_in">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> <span class="title class_">HeadContext</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Pipeline 的阅读将由单独的文章。这里见官方释意：处理和拦截 Channel 的出入站事件的 ChannelHandler 列表。<br>所以总结一下 ServerBootstrap 启动的操作基本就是：</p>
<ul>
<li>Channel</li>
<li>ChannelConfig</li>
<li>ChannelId</li>
<li>Unsafe</li>
<li>Pipeline</li>
<li>ChannelHandler</li>
</ul>
<p>基本上都是一些核心组件的创建，但是实际上配置还没有开始，所以继续</p>
<hr>
<h3 id="初始化这个-channel"><a href="#初始化这个-channel" class="headerlink" title="初始化这个 channel"></a>初始化这个 channel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    setChannelOptions(channel, newOptionsArray(), logger);</span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));</span><br><span class="line"></span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">EventLoopGroup</span> <span class="variable">currentChildGroup</span> <span class="operator">=</span> childGroup;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelHandler</span> <span class="variable">currentChildHandler</span> <span class="operator">=</span> childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);</span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">            <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerBootstrapAcceptor</span>(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法相对比较简单， <code>setChannelOptions</code> 、 <code>setAttributes</code> 这两方法只是简单的设置 KV 操作，但是具体设置什么 KV 这里还看不出来，所以只能先分析别的代码。加入新的连接处理器：<code>p.addLast(new ChannelInitializer&lt;Channel&gt;() {...</code><br>最后一步就是想 ServerChannel 加入了一个 ServerBootstrapAcceptor 。这是一个接入器，专门用于接受请求，把新的请求扔给某个 EventLoop。</p>
<h3 id="将这个-channe-注册到某个对象"><a href="#将这个-channe-注册到某个对象" class="headerlink" title="将这个 channe 注册到某个对象"></a>将这个 channe 注册到某个对象</h3><p>先看方法调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().(SingleThreadEventLoop)register(channel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SingleThreadEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventExecutor</span> <span class="keyword">implements</span> <span class="title class_">EventLoop</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">        promise.channel().unsafe().register(<span class="built_in">this</span>, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractUnsafe</span> <span class="keyword">implements</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line">    	....</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">        	register0(promise);</span><br><span class="line">        &#125;    	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				...</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">                doRegister();</span><br><span class="line">                neverRegistered = <span class="literal">false</span>;</span><br><span class="line">                registered = <span class="literal">true</span>;</span><br><span class="line">                pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">                safeSetSuccess(promise);</span><br><span class="line">                pipeline.fireChannelRegistered();</span><br><span class="line">                <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                        pipeline.fireChannelActive();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                        beginRead();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                closeForcibly();</span><br><span class="line">                closeFuture.setClosed();</span><br><span class="line">                safeSetFailure(promise, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>doRegister</code> 的操作：将 Channel 在 EventLoop 注册后作为注册过程的一部分被调用。<br>invokeHandlerAddedIfNeeded 就是调用其 pipeline 中注册的一个 ChannelHandler 的 handlerAdded 方法，fireChannelRegistered 的作用就是调用其 channelRegistered 方法。<br>然后继续调用 isActive 方法，isActive 方法中的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioServerSocketChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractNioMessageChannel</span></span><br><span class="line">                             <span class="keyword">implements</span> <span class="title class_">io</span>.netty.channel.socket.ServerSocketChannel &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isOpen() &amp;&amp; javaChannel().socket().isBound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBound</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bound || oldImpl;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>

<p>这里的 isBound 被调用的时候我们考虑下 bound 是在哪做的操作呢，让我们回到最初的方法。当用户使用 bind 方法的里面会有一个 doBound0 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBootstrap</span>&lt;B <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;B, C&gt;, C <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doBind0</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">        channel.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.setFailure(regFuture.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>在触发 channelRegistered 方法之前会调用这个方法，使得用户有机会在 channelRegistered 实现中设置管道。我们点击 bind 方法往下跟踪代码，经过层层调用最总讲来到 <code>AbstractChannel</code> 的 doBind 方法，这里的 doBind 实现将会很多种不同的实现。我们可以进入最常用的 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioServerSocketChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractNioMessageChannel</span></span><br><span class="line">                             <span class="keyword">implements</span> <span class="title class_">io</span>.netty.channel.socket.ServerSocketChannel &#123;</span><br><span class="line">    <span class="meta">@SuppressJava6Requirement(reason = &quot;Usage guarded by java version check&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">            javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>最后还是调用了 java 的 Socket 实现的 bind 方法，进行了真正的绑定。</p>
<p>这里我们还有一个感兴趣的事件就是当 Bound 激活以后再 <code>AbstractChannel</code> 的 <code>beginRead</code> 事件，官方注释：当 Channel 已经注册且 autoRead 已经设置，那么就可以开始读取，处理入站数据。问题来了，那 autoRead 在哪设置的，<code>beginRead</code> 有哪些操作。</p>
<h4 id="autoRead-设置"><a href="#autoRead-设置" class="headerlink" title="autoRead 设置"></a>autoRead 设置</h4><p>跟踪 isAutoRead 方法最终将会看到 <code>DefaultChannelConfig</code> 类种的实现： <code>autoRead = 1</code> 在默认的情况在就是为 1 ，所以主要的还是看 isBound ，什么情况下不为 <code>1</code> 可以在 ServerBootstrapAdapter 看出，当有异常信息时会设置为 0 ，并且 Delay 1秒后重新设置为 <code>1</code> 官方解释，为了防止打开文件描述过多导致的死循环。<br>也就是在主线程抛出异常的情况下，进行一个捕获然后重新启动程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelConfig</span> <span class="variable">config</span> <span class="operator">=</span> ctx.channel().config();</span><br><span class="line">    <span class="keyword">if</span> (config.isAutoRead()) &#123;</span><br><span class="line">        <span class="comment">// stop accept new connections for 1 second to allow the channel to recover</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/1328</span></span><br><span class="line">        config.setAutoRead(<span class="literal">false</span>);</span><br><span class="line">        ctx.channel().eventLoop().schedule(enableAutoReadTask, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// still let the exceptionCaught event flow through the pipeline to give the user</span></span><br><span class="line">    <span class="comment">// a chance to do something with it</span></span><br><span class="line">    ctx.fireExceptionCaught(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="beginRead-操作"><a href="#beginRead-操作" class="headerlink" title="beginRead 操作"></a>beginRead 操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractNioChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractChannel</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">selected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            	...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> <span class="built_in">this</span>.selectionKey;</span><br><span class="line">        <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readPending = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">            selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>这里的this.selectionKey就是我们在前面register步骤返回的对象，前面我们在register的时候，注册测ops是0。<code>readInterestOp</code> 就是前面 newChannel 的时候传入的 SelectionKey.OP_ACCEPT 。</p>
<p>所以基本数 Netty Server 启动的时候流程分为几大块：</p>
<ol>
<li>设置启动类参数，最重要的就是设置 Channel</li>
<li>创建 Server 对应的 Channel，创建各大组件</li>
<li>配置 option attr，register </li>
<li>调用 java 底层 socket 绑定事件</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://jeff-duan.github.io/downloads/resource/netty/Netty%20in%20Action-%E4%B8%AD%E6%96%87%E7%89%88.pdf">Netty 实战</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007282628">源码之下无秘密</a><br><a target="_blank" rel="noopener" href="https://netty.io/wiki/related-articles.html">Related articles</a></p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../2021-03-25-deep_learn_4/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../../../../20/microservices/grpc/2021-03-20-http2/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
