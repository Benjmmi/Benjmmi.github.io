<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>Cilium 源码阅读：如何制定和执行 L3 策略 续续 [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">Cilium 源码阅读：如何制定和执行 L3 策略 续续</h1>
<article class="post markdown-style">
  <h1 id="Cilium-源码阅读：如何制定和执行-L3-策略"><a href="#Cilium-源码阅读：如何制定和执行-L3-策略" class="headerlink" title="Cilium 源码阅读：如何制定和执行 L3 策略"></a>Cilium 源码阅读：如何制定和执行 L3 策略</h1><h2 id="macVlan"><a href="#macVlan" class="headerlink" title="macVlan"></a>macVlan</h2><p>所有的资料显示 ipvlan 都会与 macvlan 放在一起比较研究。也就是表示 macvlan 出生早于 ipvlan ，那么 ipvlan 应该弥补了很多 macvlan 的不足和不好解决的问题。</p>
<p>macvlan 就是允许在一个物理网卡上配置多个 mac 地址，这个有点反标准，一般一个网卡只有一个 mac 地址<br>而且是全球唯一的。但是现在虚拟机技术越来越牛逼，所以一些原始的标准只能作为部分标准择优而选。多个 macvlan 就是多个 interface 所以前面那么多说的接口都是网卡的意思。每个 interface 都有可以自己的 IP。</p>
<p>macvlan 最大的有点就是性能好，效率高，但是这里思考到一个问题就是 BGP？多网口肯定需要 BGP 的支持。</p>
<p>macvlan 可以在一个 host 的网络接口上虚拟出多个网络接口也可以有自己的 MAC 和 IP 地址</p>
<p>macvlan 模式</p>
<ul>
<li>可以在一个实体网卡上设定多个 mac 地址</li>
<li>设定的 mac 地址称为子接口（<code>sub interface</code>）；实体网卡称为父接口（<code>parent interface</code>）</li>
<li><code>parent interface</code> 可以是一个物理接口 （eth0）、802.1q、eth0.10、bonding 接口</li>
<li>所有 interface 都可以设定 IP</li>
<li><code>sub interface</code> 无法直接与 <code>parent interface</code> 通信</li>
<li>vm 或者 container 要与 host 通信，还要额外建一个 sub interface 给 host</li>
<li>sub interface 通常以 mac0@eth0 的形式来命名</li>
</ul>
<p>MACVlan 工作模式</p>
<ul>
<li>Bridge： 属于同一个 parent interface 的 macvlan 接口挂到同一个 bridge 上，可以互通（二层工作）</li>
<li>VPEA（Virtual Ethernet Port Aggregator）：所有接口的流量都需要到外部交换器走一圈才能到达其他接口（交换机）</li>
<li>Private：接口只接收发送给自己 MAC 地址的报文 （交换机）</li>
<li>Passthru：父接口和响应的 MacVlan 接口捆绑在一起，这种模式每个父接口只能和一个 MacVlan 接口捆绑。并且 MacVlan 虚拟网卡接口基础 父接口的 Mac 地址。</li>
</ul>
<h2 id="ipvlan"><a href="#ipvlan" class="headerlink" title="ipvlan"></a>ipvlan</h2><p>ipvlan 也是从一个主机接口虚拟出多个虚拟网络接口。一个重要的区别就是所有的虚拟接口都有相同的 macv 地址，而拥有不同的 ip 地址。</p>
<p>ipvlan 工作模式</p>
<p>L2：与 macvlan 的 bridge 模式工作原理很类似，父接口作为交换机来转发子接口的数据。同一个网路的子接口可以通过父接口来转<br>发数据。（理解：桥接模式需要中转站，这个站点就是宿主机本身，有网络划分。如果流量要出去也只能走中转站）<br>L3：Ipvlan 类似路由器功能，在各个虚拟网络和主机网络之间进行不同网络报文的路由转发工作。只要父接口相同，及时各个容器或者<br>虚拟机不在同一个网络，也可以互相 ping 通对方。因为 ipvlan 可以在中间做转发。（理解：同上但是无网络划分）</p>
<p>同理：需要了解 IProuter2 ，读懂了应该会系统的了解整个虚拟网络。</p>
<p>所以 cilium_net、cilium_host、cilium_vxlan </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> V=lxc807633bfedea &amp;&amp;  tc filter show dev <span class="variable">$V</span> ingress &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;========&quot;</span> &amp;&amp;tc filter show dev <span class="variable">$V</span> egress </span><br><span class="line">filter protocol all pref 1 bpf </span><br><span class="line">filter protocol all pref 1 bpf handle 0x1 bpf_lxc.o:[from-container] direct-action </span><br><span class="line">========</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">export</span> V=lxc_health &amp;&amp;  tc filter show dev <span class="variable">$V</span> ingress &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;========&quot;</span> &amp;&amp;tc filter show dev <span class="variable">$V</span> egress </span><br><span class="line">filter protocol all pref 1 bpf </span><br><span class="line">filter protocol all pref 1 bpf handle 0x1 bpf_lxc.o:[from-container] direct-action </span><br><span class="line">========</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">export</span> V=cilium_vxlan &amp;&amp;  tc filter show dev <span class="variable">$V</span> ingress &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;========&quot;</span> &amp;&amp;tc filter show dev <span class="variable">$V</span> egress </span><br><span class="line">filter protocol all pref 1 bpf </span><br><span class="line">filter protocol all pref 1 bpf handle 0x1 bpf_overlay.o:[from-overlay] direct-action </span><br><span class="line">========</span><br><span class="line">filter protocol all pref 1 bpf </span><br><span class="line">filter protocol all pref 1 bpf handle 0x1 bpf_overlay.o:[to-overlay] direct-action </span><br><span class="line"></span><br><span class="line">$ <span class="built_in">export</span> V=cilium_host &amp;&amp;  tc filter show dev <span class="variable">$V</span> ingress &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;========&quot;</span> &amp;&amp;tc filter show dev <span class="variable">$V</span> egress </span><br><span class="line">filter protocol all pref 1 bpf </span><br><span class="line">filter protocol all pref 1 bpf handle 0x1 bpf_host.o:[to-host] direct-action </span><br><span class="line">========</span><br><span class="line">filter protocol all pref 1 bpf </span><br><span class="line">filter protocol all pref 1 bpf handle 0x1 bpf_host.o:[from-host] direct-action </span><br><span class="line"></span><br><span class="line">$ <span class="built_in">export</span> V=cilium_net &amp;&amp;  tc filter show dev <span class="variable">$V</span> ingress &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;========&quot;</span> &amp;&amp;tc filter show dev <span class="variable">$V</span> egress </span><br><span class="line">filter protocol all pref 1 bpf </span><br><span class="line">filter protocol all pref 1 bpf handle 0x1 bpf_host_cilium_net.o:[to-host] direct-action </span><br><span class="line">========</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">export</span> V=docker0 &amp;&amp;  tc filter show dev <span class="variable">$V</span> ingress &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;========&quot;</span> &amp;&amp;tc filter show dev <span class="variable">$V</span> egress </span><br><span class="line">========</span><br></pre></td></tr></table></figure>

<p>所以这三者应该是中转的组件，逐个剖析每个函数的作用：几千行代码。</p>
<p>Map 共有</p>
<p>| 名称                   |         作用域       |       作用                              |<br>| Connection Tracking   | node or endpoint    |       连接跟踪表                         |<br>| NAT                   |  node               |        NAT映射表                        |<br>| Neighbor Table        | node                |           |<br>| Endpoints             | node                |        本地端点Map                      |<br>| IP cache              | node                |     管理IP&#x2F;CIDR&lt;-&gt;身份的IPCache映射      |<br>| Load Balancer         | node                |          负载平衡配置                    |<br>| Policy                | endpoint            |       管理与策略相关的BPF映射             |<br>| Proxy Map             | node                |           代理配置                       |<br>| Tunnel                | node                |        隧道端点Map                       |<br>| IPv4 Fragmentation    | node                |           |<br>| Session Affinity      | node                |           |<br>| IP Masq               | node                |      ip-masq-agent CIDRs               |<br>| Service Source Ranges | node                |           |</p>
<p>继续了解代码：bpf 如何执行策略的</p>
<p>调用 regenerateBPF 方法的入口在这，所以需要向上反推，什么情况下才会触发 <code>RegenerateIfAlive</code> 方法，看方法名的意思是如果存在存活节点才执行，<br>思考：如果没有存活节点会不会触发？如果删除节点会不会触发？epsToRegen 内容是什么怎么的来的？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">epsToRegen.ForEachGo(&amp;enqueueWaitGroup, <span class="function"><span class="keyword">func</span><span class="params">(ep policy.Endpoint)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> e := ep.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *endpoint.Endpoint:</span><br><span class="line">      <span class="comment">// Do not wait for the returned channel as we want this to be</span></span><br><span class="line">      <span class="comment">// ASync 不要等待返回的通道，因为我们希望这是异步的</span></span><br><span class="line">      e.RegenerateIfAlive(regenMetadata)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      log.Errorf(<span class="string">&quot;BUG: endpoint not type of *endpoint.Endpoint, received &#x27;%s&#x27; instead&quot;</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>debug 从 policyAdd 跳转至 PolicyReactionEvent 发现 endpointsToRegen 在 policyAdd 的时候为空，跳转之后就不为空了，说明 RegenerateIfAlive 不是从<br>policyAdd 跳转过来的。那么就将目标转到 putPolicy 上。</p>
<p>入参如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;endpointSelector&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;matchLabels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;any:id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;app1&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ingress&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;fromEndpoints&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;matchLabels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;any:id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;app2&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;toPorts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;ports&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;80&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TCP&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;l3-rule&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><del>规则整合完整后就会触发 UpdateRulesEndpointsCaches 就需要更新 Endpoint 筛选出来，放到 Set 中，然后从原有的 Set 中删除。目的就是将需要</del><br>~~更新的 Endpoint 和 不需要更新的 Endpoint 区分开来，但是每次更新都需要修改 Revision。 ~~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~匹配完成后会触发 PolicyReactionEvent#reactToRuleUpdates 方法。将需要修改的 Endpoint 重新生成。进入 RegenerateIfAlive  方法：~~</span><br></pre></td></tr></table></figure>
<p><del>1. 判断当前 Endpoint 是否处于 Alive</del><br><del>2. 切换上下文至 EndpointRegenerationEvent 执行</del><br><del>3. 开始处理 Regeneration 事件</del><br><del>4. 这里为了防止出现死锁，所以在 Endpoint 重新生成 BPF 时对 Endpoint 加锁。</del><br><del>5. 获取当前 Endpoint State 文件夹路径，一般时 <code>/var/run/cilium/state/{EnpointId}</code></del><br><del>6. 创建一个临时目录，tmpDir</del><br><del>7. 如果对应的 Map 不存在就创建已给 Map -&gt; 子步骤需要详解</del><br><del>8. 过滤成一组基于SelectorCache的具体 Map 条目。这些条目随后可以被引入数据路径。</del><br><del>9. 跟新 BPF Map  IPcache  ，查看下 ipcache 用来干啥的</del></p>
<p>一直 debug 到核心位置，发现注释上面已经写了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Allow pushes an entry into the PolicyMap to allow traffic in the given  `trafficDirection` for identity `id` with destination port `dport` over  protocol `proto`.</span><br><span class="line"></span><br><span class="line"> It is assumed that `dport` and `proxyPort` are in host byte-order.</span><br><span class="line"></span><br><span class="line"> Allow向PolicyMap推送一个条目，允许身份为`id`，目的端口为`dport`，协议为`proto`的流量进入给定的`trafficDirection`。</span><br><span class="line"></span><br><span class="line"> 假设`dport`和`proxyPort`是按主机字节顺序排列的。</span><br><span class="line"> ## trafficDirection 流量方向</span><br></pre></td></tr></table></figure>

<p>只能说这个设计有点出乎意料，上层程序对数据的处理到精简化，给到底层 eBPF 基础架构。绕了很大一圈。</p>
<p>原理简单描述： 将现有的实例信息转至为一个 <strong>实例 -&gt; ID</strong> 存储到 ipcache 中。策略存储更为简单。<br>PoliyMap 存储<br><strong>key: ptr(id,dport,proto,trafficDirect)</strong><br><strong>value:proxyPort</strong><br>解释下key 的内容：<code>id -&gt; 来源实例的 ID 也就是通过 ipcache 获取的id</code>，<code>dport:目标端口</code>,<code>proto:通信协议</code></p>
<p>结构如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PolicyKey <span class="keyword">struct</span> &#123;</span><br><span class="line">	Identity         <span class="type">uint32</span> <span class="string">`align:&quot;sec_label&quot;`</span>  <span class="comment">// =&gt; 36895</span></span><br><span class="line">	DestPort         <span class="type">uint16</span> <span class="string">`align:&quot;dport&quot;`</span> <span class="comment">// In network byte-order   =&gt; 80</span></span><br><span class="line">	Nexthdr          <span class="type">uint8</span>  <span class="string">`align:&quot;protocol&quot;`</span>   <span class="comment">// TCP </span></span><br><span class="line">	TrafficDirection <span class="type">uint8</span>  <span class="string">`align:&quot;egress&quot;`</span>     <span class="comment">// =&gt;  0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PolicyEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	ProxyPort <span class="type">uint16</span> <span class="string">`align:&quot;proxy_port&quot;`</span> <span class="comment">// In network byte-order</span></span><br><span class="line">	Pad0      <span class="type">uint16</span> <span class="string">`align:&quot;pad0&quot;`</span></span><br><span class="line">	Pad1      <span class="type">uint16</span> <span class="string">`align:&quot;pad1&quot;`</span></span><br><span class="line">	Pad2      <span class="type">uint16</span> <span class="string">`align:&quot;pad2&quot;`</span></span><br><span class="line">	Packets   <span class="type">uint64</span> <span class="string">`align:&quot;packets&quot;`</span></span><br><span class="line">	Bytes     <span class="type">uint64</span> <span class="string">`align:&quot;bytes&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释到这了：来源实例的 ID 一开始只是假设，但是后来确实坐实了。比如这里的 36895 通过查看 ipcache 就可以找到对应的实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cilium map get  cilium_ipcache</span><br><span class="line">Key                             Value             State   Error</span><br><span class="line">f00d::a0f:0:0:2fd8/128          4 0 0.0.0.0       <span class="built_in">sync</span>    </span><br><span class="line">10.0.2.15/32                    1 0 0.0.0.0       <span class="built_in">sync</span>    </span><br><span class="line">fe80::3cac:d1ff:fe3d:fe30/128   1 0 0.0.0.0       <span class="built_in">sync</span>    </span><br><span class="line">10.11.90.17/32                  36895 0 0.0.0.0   <span class="built_in">sync</span>  </span><br><span class="line"></span><br><span class="line">docker run -d --name app1 --net cilium-net -l <span class="string">&quot;id=app1&quot;</span> cilium/demo-httpd   10.11.71.148</span><br><span class="line">&#123;10.11.255.104  32327f7b4cf9  f00d::a0f:0:0:36a    32327f7b4cf9  6e:b0:7d:4e:6b:e5   cilium0@if19&#125;</span><br><span class="line">docker run -d --name app2 --net cilium-net -l <span class="string">&quot;id=app2&quot;</span> nginx   </span><br><span class="line">&#123;10.11.90.17  a94c744974c4  f00d::a0f:0:0:36a    a94c744974c4  1a:6d:c6:85:08:4d  cilium0@if49&#125;</span><br></pre></td></tr></table></figure>

<p>而对应的实例就是这个 IP。<br>也就是说 app2 实例来访问 app1 实例的时候，eBPF 从二层截取到数据流，获取到来源IP，目标端口号，然后从 ipCache 中获取标识信息，<br>判断是否允许访问目标端口。</p>
<p>既然是多重判断那么就需要找出  ipcache 的结构体。还要找出如何将信息添加到 ipcache ，底层的逻辑结构推断出来了，那么 ipcache 属于辅助填充条件<br>找出的思路，就是想上反推，思考的地方有两点，就是在添加策略的时候，将条件推到 ipcahe 是同步的还是异步的，首先可以确定的一点就是推送到 ipcache<br>是先决条件，应该是在实例生成的时候推送到  ipcache 。所以应该冲添加实例的入口下手进行程序逻辑判断。<br>那就回到 createEndpoint 方法，但是找了半天也没有找到更新 ipcache 的接口调用，索性就直接冲调用接口底层打了一个端点：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pkg/maps/ipcache/ipcache.<span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKey</span><span class="params">(ip net.IP, mask net.IPMask)</span></span> Key &#123;  </span><br><span class="line">	result := Key&#123;&#125;</span><br><span class="line"></span><br><span class="line">	ones, _ := mask.Size()   <span class="comment">// break</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猜测是异步的，没想到异步的这么彻底，也就是说可以完整的用在生产环境。通过订阅 consul 的某个键来完成。也就是说在某个阶段将 IP 传送到 consul 中。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cilium/state/ip/v1/default/10.11.227.54&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;IP&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.11.227.54&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;Mask&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;HostIP&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.2.15&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;Key&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;Metadata&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cilium-global:default:runtime1:3459&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>处理上面这端数据的调用链如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkg/ipcache/kvstore.go#Watch  =&gt; IPIdentityCache.Upsert // 监听 kvstore.EventTypeCreate 创建事件</span><br><span class="line">	pkg/ipcache/ipcache.go#Upsert =&gt;  listener.OnIPIdentityCacheChange</span><br><span class="line">	    pkg/datapath/ipcache/listener.go#OnIPIdentityCacheChange  =&gt; l.bpfMap.Update</span><br></pre></td></tr></table></figure>


<p>那么问题来了什么地方丢过来的，而且这份 ID 也分配了，Metadata 也分配了，global 看着很熟悉，所以就回头看下 createEndpoint 吧。</p>
<p>调用链如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">daemon/cmd/endpoint.go#createEndpoint =&gt; ep.UpdateLabels</span><br><span class="line">	pkg/endpoint/endpoint.go#UpdateLabels  =&gt; e.runIdentityResolver</span><br><span class="line">	    pkg/endpoint/endpoint.go#runIdentityResolver =&gt;  e.identityLabelsChanged</span><br><span class="line">	         pkg/endpoint/endpoint.go#identityLabelsChanged  =&gt;   e.SetIdentity</span><br><span class="line">	               pkg/endpoint/policy.go#SetIdentity   =&gt;    e.runIPIdentitySync</span><br><span class="line">	                      pkg/endpoint/policy.go#runIPIdentitySync   =&gt;   ipcache.UpsertIPToKVStore</span><br></pre></td></tr></table></figure>

<p>现在两边应该就能串起来了，在创建实例的时候，首先调用 requestAddres 接口，然后调用 createEndpoint 接口，createEndpoint 会创建 Endpoint<br>虚拟网络等信息，并且设置全局唯一 ID。形成一个实例信息发送到 consul 中。然后 watch 监听到 consul 有新的值就会启动 ipcache 的流程将基本信息<br>存储到 ipcache 中。</p>
<p>那 ipcache 具体存储什么呢？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Key <span class="keyword">struct</span> &#123;</span><br><span class="line">	Prefixlen <span class="type">uint32</span> <span class="string">`align:&quot;lpm_key&quot;`</span>   <span class="comment">//  64</span></span><br><span class="line">	Pad1      <span class="type">uint16</span> <span class="string">`align:&quot;pad1&quot;`</span></span><br><span class="line">	Pad2      <span class="type">uint8</span>  <span class="string">`align:&quot;pad2&quot;`</span></span><br><span class="line">	Family    <span class="type">uint8</span>  <span class="string">`align:&quot;family&quot;`</span>    <span class="comment">// 1</span></span><br><span class="line">	<span class="comment">// represents both IPv6 and IPv4 (in the lowest four bytes)</span></span><br><span class="line">	IP types.IPv6 <span class="string">`align:&quot;$union0&quot;`</span>    <span class="comment">// 10.11.41.206</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RemoteEndpointInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	SecurityIdentity <span class="type">uint32</span>     <span class="string">`align:&quot;sec_label&quot;`</span>    <span class="comment">// 62820</span></span><br><span class="line">	TunnelEndpoint   types.IPv4 <span class="string">`align:&quot;tunnel_endpoint&quot;`</span></span><br><span class="line">	Key              <span class="type">uint8</span>      <span class="string">`align:&quot;key&quot;`</span>   <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是存储的具体内容。</p>
<p>下面就需要具体分析 ipcache、lxc、filter 等代码了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">结构定义如下：</span><br><span class="line"></span><br><span class="line">```golang</span><br><span class="line">// 与 bpf/lib/common.h endpoint_key 结构体同步</span><br><span class="line">type EndpointKey struct &#123;</span><br><span class="line">	IP     types.IPv6 `align:&quot;$union0&quot;`</span><br><span class="line">	Family uint8      `align:&quot;family&quot;`  // 地址类型 IPv4 和 IPv6</span><br><span class="line">	Key    uint8      `align:&quot;key&quot;`     // 默认=0</span><br><span class="line">	Pad2   uint16     `align:&quot;pad5&quot;`</span><br><span class="line">&#125;</span><br><span class="line">// 与 &lt;bpf/lib/common.h&gt; endpoint_info 结构体同步</span><br><span class="line">type EndpointInfo struct &#123;</span><br><span class="line">	IfIndex uint32 `align:&quot;ifindex&quot;`</span><br><span class="line">	Unused  uint16 `align:&quot;unused&quot;`</span><br><span class="line">	LxcID   uint16 `align:&quot;lxc_id&quot;`</span><br><span class="line">	Flags   uint32 `align:&quot;flags&quot;`</span><br><span class="line">	// go alignment</span><br><span class="line">	_       uint32</span><br><span class="line">	MAC     MAC        `align:&quot;mac&quot;`</span><br><span class="line">	NodeMAC MAC        `align:&quot;node_mac&quot;`</span><br><span class="line">	Pad     pad4uint32 `align:&quot;pad&quot;`</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0 = ReservedIdentityHealth (4) -&gt; </span><br><span class="line">1 = ReservedEKSKubeDNS (103) -&gt; </span><br><span class="line">2 = ReservedIdentityInit (5) -&gt; </span><br><span class="line">3 = ReservedCiliumOperator (105) -&gt; </span><br><span class="line">4 = github.com/cilium/cilium/pkg/datapath/loader.templateSecurityID (2) -&gt; </span><br><span class="line">5 = ReservedCoreDNS (104) -&gt; </span><br><span class="line">6 = ReservedCiliumKVStore (101) -&gt; </span><br><span class="line">7 = ReservedIdentityUnmanaged (3) -&gt; </span><br><span class="line">8 = ReservedIdentityRemoteNode (6) -&gt; </span><br><span class="line">9 = ReservedKubeDNS (102) -&gt; </span><br><span class="line">10 = ReservedEKSCoreDNS (106) -&gt; </span><br><span class="line">11 = ReservedCiliumEtcdOperator (107) -&gt; </span><br><span class="line">12 = ReservedIdentityHost (1) -&gt; </span><br><span class="line">13 = ReservedETCDOperator (100) -&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0 = &#123;uint8&#125; 110 6e</span><br><span class="line">1 = &#123;uint8&#125; 176</span><br><span class="line">2 = &#123;uint8&#125; 125</span><br><span class="line">3 = &#123;uint8&#125; 78</span><br><span class="line">4 = &#123;uint8&#125; 107</span><br><span class="line">5 = &#123;uint8&#125; 229</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo Mac     6e:b0:7d:4e:6b:e5        10.11.255.104</span><br><span class="line">nginx Mac    1a:6d:c6:85:08:4d        </span><br><span class="line">enp0s3 Mac： 52:54:00:12:35:02</span><br><span class="line">docker0 Mac：02:42:ac:11:00:03</span><br><span class="line"></span><br><span class="line">docker run -d --name app1 --net cilium-net -l &quot;id=app1&quot; cilium/demo-httpd   10.11.71.148</span><br><span class="line">&#123;10.11.255.104  32327f7b4cf9  f00d::a0f:0:0:36a    32327f7b4cf9  6e:b0:7d:4e:6b:e5   cilium0@if19&#125;</span><br><span class="line">docker run -d --name app2 --net cilium-net -l &quot;id=app2&quot; nginx   </span><br><span class="line">&#123;10.11.90.17  a94c744974c4  f00d::a0f:0:0:36a    a94c744974c4  1a:6d:c6:85:08:4d  cilium0@if49&#125;</span><br></pre></td></tr></table></figure>





</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../../../28/ebpf/2021-06-28-libbpf2/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../../../16/ebpf/2021-06-16-cilium5.1/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
