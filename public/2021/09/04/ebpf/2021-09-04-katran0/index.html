<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>负载均衡 katran： 了解学习和思考 [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">负载均衡 katran： 了解学习和思考</h1>
<article class="post markdown-style">
  <h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><ul>
<li><p>NUMA: (Non-uniform memory access) 非统一内存访问架构,是一种为多处理器的电脑设计的内存架构，<br>内存访问时间取决于内存相对于处理器的位置。</p>
</li>
<li><p><code>RSS</code>: 接收端扩展（RSS）是网卡中的一个重要的优化，指在通过每个数据链路的数据包转发到单独的 CPU从而在<br>CPU 之间均有的分配负载。从而在 CPU 之前均衡的分配负载</p>
</li>
</ul>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Katran 是一项负载均衡技术，类似于 LVS 等软件，目前 LVS 已经成为 Linux 内核模块。</p>
<p>负载均衡是一种服务器和网络设备的集群技术。负载均衡将特定的业务（网络服务、网络流量等）分担给多个服务<br>器或者网络设备。从而提高了业务处理的能力，保证了业务的高可用性。常用的负载均衡有开源的 Nginx、<br>LVS、Haproxy。以及商业的硬件设备 F5、Netscale。</p>
<p>负载均衡设备对网络处理能力需要极高的要求，甚至于重写网络内核。负载均衡所带来的收益也是十分明显<br>网络的单机模式到集群模式处理减少成本、降低风险、提高系统稳定性，都能为公司带来非常高的价值。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_34763749/article/details/80529562">摘要:负载均衡的故事</a></p>
<p>Katran 完全重新设计了转发平民啊。应用了目前较新的技术：XDP 和 eBPF 技术，这两个技术的结合<br>使得负载均衡有了几个优点：极早数据包处理、内核中运行处理高效、复用内核功能节约开发成本、稳定性<br>高、可扩展性高、成本低廉但更稳定的 Maglev 哈希，更具有弹性的本地状态，对 <code>RSS</code> 友好的封装。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li><code>Katran</code> 只有 DR（Direct Server Response） 工作模式</li>
<li>基于 L3 协议，而不是 L2 协议，决定网 VIP 的数据包都要发送到 <code>Katran</code></li>
<li>不支持分段、无法自行对数据分段。（解决方案：增加 <code>MTU</code> 或 更改来自后端的 <code>TCPMSS</code>）</li>
<li><code>Katran</code> 不支持带有IP选项集的数据包。最大数据包大小不得超过 <code>3.5 KB</code></li>
<li>用于一体化负载均衡系统，即单一接口将用于“从用户到L4LB（入口）”的流量和“从L4LB到L7LB（出口）”的流量。</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>快：XDP 工作在 NIC 接受之后。也可以降低到 <code>驱动模式</code> 工作</li>
<li>性能随网卡RX队列的数量线性增长: katran 属于无锁工作模式，每个接收到的包都会调用 BPF 程序</li>
<li>RSS友好封装: katran使用ipip封装进行从L4 lb到L7 lb的数据包转发。</li>
<li>固定大小（启动时可配置大小）连接跟踪表，带有用于逐出旧条目的LRU策略。</li>
<li>优化的 Maglev Hash 表用于连接跟踪：它为我们提供了良好的故障恢复能力和出色的负载均衡功能。<br>  哈希已修改为能够支持后端(L7磅)服务器的不等权重</li>
<li>不需要在接收路径上进行忙循环：如果没有要服务的流量，负载均衡器几乎不会消耗任何CPU。</li>
<li>Katran(通常还有XDP)允许您在同一台服务器上运行任何应用程序，而不会造成任何性能<br>  损失(与其他一些“内核绕过”技术相比)</li>
</ol>
<h1 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h1><p><img src="/Benjamin.Yim/assets/images/epbf/katran_pktflow.png" alt="katran_pktflow.png"></p>
<ol>
<li>katran 接收包</li>
<li>验证访问目标 IP 是否存在本机配置的 VIP 中</li>
<li>检查是否已经存在会话记录</li>
<li>如果是一个新的会话，就使用 <code>5元组</code> 进行 hash 计算</li>
<li>根据 hash 值，选择一个真实的后端服务器</li>
<li>更新到会话记录，用于简单的查找下次会话</li>
<li>将保温封装到另一个 IP 报文中，发送到后端</li>
</ol>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>katran 宣传是工作在 DSR 模式下，但是使用了 <code>ip-in-ip</code> 对其进行了封装，还需要后端配置 <code>lo</code><br>优点想 <code>Tunnel</code> 模式。也是单臂模式，响应不服药负载均衡器。<code>可能是为了解决包过大的问题</code>。为了<br>达到高性能模式还绑定了单个 CPU 处理数据包，优点类似 <code>DPDK</code> 模式。总体性能需要压测之后才能全面<br>了解。</p>
<h2 id="需要思考"><a href="#需要思考" class="headerlink" title="需要思考"></a>需要思考</h2><p>XDP 需要使用的 MAP 内存是受限的，这个解决了么。如果大批量的数据虽然使用 LRU 但是对于链路跟踪<br>会不会产生数据丢失。如果支持 NAT 模式，整个会话记录和链路跟踪的处理方式。核心程序应该在 BPF 代码<br>前端语言只需要简单封装就可以。可否支持 UDP 和 L7 负载。共享模式需要解析。</p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../2021-09-04-katran1/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../../../../08/20/ebpf/2021-08-20-lvs4/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
