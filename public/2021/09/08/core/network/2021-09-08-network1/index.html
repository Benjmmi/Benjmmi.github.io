<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>Linux-内核网络 1 [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">Linux-内核网络 1</h1>
<article class="post markdown-style">
  <h1 id="Linux-内核网络-理论篇-设备模型"><a href="#Linux-内核网络-理论篇-设备模型" class="headerlink" title="Linux-内核网络-理论篇-设备模型"></a>Linux-内核网络-理论篇-设备模型</h1><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>设备模型诞生的初衷：为了<strong>解决</strong>越来越复杂的设备拓扑结构问题。<br>问题描述：最早的内核中没有独立的数据结构来让内核获得整体系统的配合信息。虽然一开始可以正常<br>的工作，但是随着拓扑结构越来越复杂，以及要支持更多的新特性内核就优点力不从心了，陷入无法维<br>护的情况。<br><strong>总结</strong>来说设备模型是为了内核更好的管理设备和让开发者更好的扩展新设备新功能</p>
<p>建立设备模型后内核系统具有了如下的优点：</p>
<ol>
<li>代码重复降到最低</li>
<li>提供了统一的引用计数机制</li>
<li>可以很方便的罗列出所有的设备，很方便的检查他们的状态、连接的总线</li>
<li>可以将系统中的所有设备以树形结构展示。包括了总线和内部连接</li>
<li>可以将设备和对应的驱动程序相互联系起来</li>
<li>可以将设备按照类型分类</li>
<li>可以从设备树的叶节点向根遍历</li>
</ol>
<p>案例：关闭电源，若是想正确的关闭电源肯定要建立一个优先级的顺序和结构，先依次向下遍历叶节点中<br>的子系统比如:<code>USB</code>、<code>PCI</code>。再逐个网上遍历父级系统，最终关闭根电源系统。（反思一下，如果这<br>些关闭方式都由各个子系统自己负责，那是多么混乱）</p>
<p>设备模型有几个简单的数据结构：<code>kobject</code>、<code>kset</code>、<code>ktype</code> 和 <code>子系统</code></p>
<h2 id="kobject"><a href="#kobject" class="headerlink" title="kobject"></a>kobject</h2><p><code>kobject</code> 是设备模型中最核心的也是最基本的数据结构。最初只负责<code>引用计数</code>的功能，但是随着系<br>统的更新 <code>kobject</code> 负责的任务越来越多。所以字段也增加了很多，数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name; <span class="comment">// kobject 的名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span> <span class="comment">// </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		*<span class="title">parent</span>;</span> <span class="comment">// kobject 的父对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span>		*<span class="title">kset</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>	*<span class="title">ktype</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span>	*<span class="title">sd</span>;</span> <span class="comment">// 指向 sysfs_dirent 结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span>		<span class="title">kref</span>;</span> <span class="comment">// 引用计数器</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">release</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>kobject</code> 如果单独使用的话好像并没有什么意义，所以 <code>kobject</code> 一般是嵌入到其他结构中。可以<br>认为通过 <code>kobject</code> 结构，让开发者使用面向对象的方式思考开发步骤，降低了开发难度。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">dev_t</span> dev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h2 id="ktype"><a href="#ktype" class="headerlink" title="ktype"></a>ktype</h2><p><code>ktype</code> 是 <code>kobject</code> 依赖的一个特殊类型。<code>ktype</code> 原型为 <code>kobj_type</code> 结构体，主要定义了<br><code>kobject</code> 普遍的特性。比如：释放、<code>sysfs</code> 文件操作、属性字段等。<br><code>ktype</code> 特点：同类型的 <code>kobject</code> 可以共享 <code>ktype</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*release)(<span class="keyword">struct</span> kobject *kobj); <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span> <span class="comment">// sysfs 文件读写时的特性</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span>	 <span class="comment">// kobject 相关的默认属性</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">default_groups</span>;</span> <span class="comment">// 属性分组</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *(*namespace)(<span class="keyword">struct</span> kobject *kobj);</span><br><span class="line">	<span class="type">void</span> (*get_ownership)(<span class="keyword">struct</span> kobject *kobj, <span class="type">kuid_t</span> *uid, <span class="type">kgid_t</span> *gid);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>release</code>:指针指向 <code>kobject</code> 的析构函数，当应用计数降为 <code>0</code> 的时候将自动调用<br><code>sysfs_ops</code>:指向 <code>sysfs_ops</code> 结构体。主要描述了读写 <code>sysfs</code> 文件读写时的特性<br><code>default_attrs</code>: 定义了 <code>kobject</code> 默认属性，会随着 <code>kobject</code> 导出到 <code>sysfs</code> 而导出</p>
<h2 id="kobject-使用"><a href="#kobject-使用" class="headerlink" title="kobject 使用"></a><code>kobject</code> 使用</h2><p>按照惯例都需要初始化，<code>kobject</code> 也不例外在初始化之前需要清空<code>kobject</code> ，如果没有整个清空<br>在使用的时候经常会发生一些奇奇怪怪的事情，然后调用 <code>kobject_init</code> 函数。</p>
<p><code>void kobject_init(struct kobject *kobj, struct kobj_type *ktype);</code></p>
<p>第一个参数就是需要初始的 <code>kobject</code> 对象，第二个参数就是 <code>ktype</code> ，调用步骤如下参考:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line">kobj = kzmalloc(<span class="keyword">sizeof</span>(*kobj), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(!kobj)</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">kobj-&gt;<span class="built_in">set</span> = mykset;</span><br><span class="line">kobject_init(kobj, myktyp);</span><br></pre></td></tr></table></figure>
<p>通过上述的步骤就可以获得一个初始化后的 <code>kobject</code> 当然现在为了方便使用已经将很多操作步骤<br>整合为一个函数了: <code>kobject_create</code> 。当调用这个函数时会自动返回一个 <code>kobject</code> 使用起<br>来相当便捷:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line">kobj = kobject_create();</span><br><span class="line"><span class="keyword">if</span>(!kobj)</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br></pre></td></tr></table></figure>
<p>然后在使用 <code>kobject</code> 的时候最起码要给 <code>kobject</code> 一个名字，使用如下函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kobject_set_name</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="type">const</span> <span class="type">char</span> *name, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kobject_set_name_vargs</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="type">const</span> <span class="type">char</span> *fmt,va_list vargs)</span>;</span><br></pre></td></tr></table></figure>

<p><code>kobject</code> 主要功能之一就是提供了统一的引用基数。初始化之后 <code>kobject</code> 的引用基数就会被<br>自动初始化为 <code>1</code> 。只要引用计数不为 <code>0</code>，那么 <code>kobject</code> 就会永远的保留在内存中。底层对引用<br>计数的操作函数有:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kobject *<span class="title function_">kobject_get</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kobject_put</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span>;</span><br></pre></td></tr></table></figure>
<p><code>kobject_get</code> 调用成功后会增加 <code>kobject</code> 引用计数，并返回指向 <code>kobject</code> 的指针，如果<br><code>kobject</code> 处于销毁状态那么就会调用失败，返回 <code>NULL</code> 。当引用被释放时调用 <code>kobject_put</code><br>减少引用计数，当计数为 <code>0</code> 的情况之下可能会自动调用 <code>release</code> 释放当前对象. 所以 <code>release</code><br>不可以为空，如果为空将会带来不可预知的后果。</p>
<h2 id="kset"><a href="#kset" class="headerlink" title="kset"></a>kset</h2><p><code>kset</code> 是 <code>kobject</code> 对象的集合体，可以把 <code>kset</code> 看做一个容器，可将所有相关的 <code>kobject</code> 对象<br>置于同一父级结构下。代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">spinlock_t</span> list_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p><code>list</code>: 连接该集合中所有的 <code>kobject</code> 对象<br><code>list_lock</code>:是保护这个链表中元素的自旋锁<br><code>kobj</code>:指向的 <code>kobject</code> 为 <code>kset</code> 基础类型.<br><code>uevent_ops</code>:用于处理集合中 <code>kobject</code> 对象的热插拔操作。<br><code>uevent</code> 就是 <code>user event</code> 的意思，提供与用户空间热插拔信息进行通信的机制<br><code>kset</code> 也有一个名字，它保存在内嵌的 <code>kobject</code> 中。如果要设置 <code>kset</code> 的名字方式如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kobject_set_name(&amp;my_set-&gt;kobj, <span class="string">&quot;myname&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>kset</code> 中也有一个指针指向 <code>ktype</code> ，用来描述它所包含的 <code>kobject</code> ，该类型的使用优先于 <code>kobject</code><br>的 <code>ktype</code> 。所以大多时候 <code>kobject</code> 中的 <code>ktype</code> 被设置为 <code>NULL</code></p>
<h2 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h2><p>子系统是对整个内核中一些高级部分的描述。子系统通常显示在 <code>sysfs</code> 分层结构的顶层。比如：<br><code>/sys/devices</code>、<code>/sys/block</code> 还有其他的子系统通过查看 <code>/sys/</code> 目录可见，因为子系统<br>相当稳定，基本不需要开发新的子系统，所以不在讲解</p>
<p>最终呈现的视图如下：</p>
<p><a href="/Benjamin.Yim/assets/source/images/core/17fig01.gif">!image</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[Linux 内核设计与实现]<br>[Linux 驱动设计]<br>[<a target="_blank" rel="noopener" href="http://www.iakovlev.org/index.html?p=1025%5D">http://www.iakovlev.org/index.html?p=1025]</a></p>
<p>git send-email –to <a href="mailto:&#107;&#117;&#98;&#97;&#64;&#107;&#x65;&#114;&#110;&#x65;&#x6c;&#x2e;&#x6f;&#114;&#x67;">kuba@kernel.org</a> –cc <a href="mailto:&#x65;&#100;&#117;&#x6d;&#x61;&#x7a;&#101;&#116;&#64;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#46;&#x63;&#111;&#109;">edumazet@google.com</a>,<a href="mailto:&#x64;&#97;&#118;&#x65;&#109;&#x40;&#x64;&#x61;&#118;&#x65;&#109;&#108;&#x6f;&#102;&#116;&#x2e;&#110;&#101;&#x74;">davem@davemloft.net</a>,<a href="mailto:&#121;&#x6f;&#115;&#104;&#x66;&#x75;&#106;&#105;&#64;&#x6c;&#105;&#110;&#x75;&#x78;&#45;&#105;&#x70;&#118;&#x36;&#46;&#111;&#114;&#x67;">yoshfuji@linux-ipv6.org</a>,<a href="mailto:&#x64;&#115;&#97;&#x68;&#x65;&#114;&#110;&#x40;&#x6b;&#x65;&#114;&#110;&#x65;&#x6c;&#46;&#111;&#x72;&#x67;">dsahern@kernel.org</a>,<a href="mailto:&#x6e;&#101;&#x74;&#100;&#101;&#118;&#x40;&#x76;&#x67;&#x65;&#x72;&#46;&#107;&#x65;&#114;&#110;&#101;&#x6c;&#46;&#111;&#114;&#103;">netdev@vger.kernel.org</a>,<a href="mailto:&#108;&#x69;&#110;&#x75;&#120;&#45;&#x6b;&#x65;&#114;&#x6e;&#x65;&#x6c;&#64;&#x76;&#x67;&#101;&#114;&#x2e;&#107;&#x65;&#x72;&#x6e;&#x65;&#108;&#46;&#111;&#114;&#x67;">linux-kernel@vger.kernel.org</a></p>
<p>Eric Dumazet <a href="mailto:&#x65;&#x64;&#117;&#x6d;&#x61;&#x7a;&#101;&#x74;&#x40;&#103;&#111;&#111;&#103;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;">edumazet@google.com</a> (maintainer:NETWORKING [TCP])<br>“David S. Miller” <a href="mailto:&#100;&#97;&#x76;&#x65;&#109;&#64;&#x64;&#x61;&#x76;&#101;&#x6d;&#x6c;&#111;&#102;&#116;&#46;&#x6e;&#101;&#x74;">davem@davemloft.net</a> (maintainer:NETWORKING [IPv4&#x2F;IPv6])<br>Hideaki YOSHIFUJI <a href="mailto:&#121;&#111;&#115;&#x68;&#x66;&#x75;&#106;&#105;&#64;&#108;&#105;&#x6e;&#117;&#120;&#x2d;&#x69;&#112;&#x76;&#x36;&#46;&#x6f;&#x72;&#103;">yoshfuji@linux-ipv6.org</a> (maintainer:NETWORKING [IPv4&#x2F;IPv6])<br>David Ahern <a href="mailto:&#100;&#115;&#x61;&#x68;&#x65;&#114;&#x6e;&#x40;&#x6b;&#101;&#114;&#x6e;&#101;&#108;&#46;&#111;&#x72;&#103;">dsahern@kernel.org</a> (maintainer:NETWORKING [IPv4&#x2F;IPv6])<br>Jakub Kicinski <a href="mailto:&#x6b;&#x75;&#98;&#x61;&#x40;&#x6b;&#x65;&#x72;&#110;&#x65;&#108;&#x2e;&#x6f;&#x72;&#103;">kuba@kernel.org</a> (maintainer:NETWORKING [GENERAL])<br><a href="mailto:&#110;&#101;&#x74;&#100;&#x65;&#118;&#x40;&#x76;&#x67;&#101;&#114;&#46;&#x6b;&#x65;&#x72;&#x6e;&#x65;&#x6c;&#x2e;&#x6f;&#x72;&#x67;">netdev@vger.kernel.org</a> (open list:NETWORKING [TCP])<br><a href="mailto:&#108;&#x69;&#x6e;&#x75;&#120;&#x2d;&#107;&#101;&#114;&#x6e;&#x65;&#108;&#64;&#x76;&#103;&#x65;&#114;&#46;&#107;&#x65;&#114;&#x6e;&#x65;&#108;&#46;&#111;&#x72;&#x67;">linux-kernel@vger.kernel.org</a> (open list)</p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../../../cncf/2021-09-08-kube-proxy1/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../2021-09-08-network4/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
