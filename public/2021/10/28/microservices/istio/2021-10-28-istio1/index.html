<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>Kubernetes - ISTIO [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">Kubernetes - ISTIO</h1>
<article class="post markdown-style">
  <h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>服务网格采用 sidecar 的运行模式，将 client-server 连接起来，形成格子的效果。<br>而这个 <code>sidecar</code> 系统就是 <code>envoy</code>。至于 <code>envoy</code> 需要如何运行就需要 <code>istio</code><br>之类的系统。<br>所以服务网格大致分为两个部分组成执行和命令下发，即：数据面（Envoy）和控制面板（Istio）<br>个人总结：istio 应该数据面向 API 编程，严格按照数据面API 的方式编程，包括启动、<br>更新、命令下发。</p>
<p>istio-pliot：监督资源的变化、VirtualService 修改、DestinationRule修改，翻译为对外协议。<br>资源包括：service、endpoint、pod、node</p>
<p>VirtualService: 用于定义指定流量行为、路由规则，告诉 Sidecar 如何发送虚拟服务的流量到适当的目标<br>DestinationRule：访问目标规则与 VirtualService 一起使用<br>ServiceEntry：将集群外部的服务注册到 Pilot 中，再统一由 ServiceController 进行管理<br>WorkloadEntry：用于描述将非 Kubernetes 工作负载的实例，如虚拟机或裸机服务器，加入服务网格<br>ServiceEntry 是服务的抽象描述类似于 app-key ，WorkloadEntry 是服务的具体实例类似于 app-key 下的具体实例<br><strong>ServiceEntry 可以通过 LabelSelector 筛选出自身对应的实例</strong></p>
<p>Pilot支持从Kubernetes、Consul等多种平台获取服务发现功能<br>用户通过VirtualService、DestinationRule等API制定服务间的流量治理规则</p>
<p>Pilot将发现的服务以及用户定义的服务间的调用规则进行融合并与底层Proxy的API进行适配后将规则下发</p>
<p>pilot-discovery  分为三层<br>上层 pilot-discovery  调用 kuberntes 来发现服务之间的关系，名称：Platform Adapter 层<br>中层 抽象模型，将获取的数据转换为istio 自己的数据模型。名称：Abstrace Model 层<br>下层 pilot-discovery  被 envoy 调用，数据通过 envoy API 暴露出去等待envoy去拉取这些规则。名称：Envoy API 层</p>
<p>pilot-discovery 三大模块：<br>Config Controller ：从不同来源接收路由规则</p>
<ul>
<li>Config Controller 比较核心的就是对接 Kubernetes，从 kube-apiserver 中 Watch 集<br>群中的 VirtualService、ServiceEntry、DestinationRules 等配置信息，有变化则生<br>成 PushRequest 推送至 EnvoyXdsServer 中的推送队列。<br><strong>除此之外，还支持对接 MCP(Mesh Configuration Protocol) 协议的 gRPC Server，需<br>要在 meshconfig 中配置 configSources .如 Nacos 的 MCP 服务等</strong><br><em>最后一种是基于内存的 Config Controller 实现，通过 Watch 一个文件目录，加载目录<br>中的 yaml 文件生成配置数据，主要用来测试。</em></li>
</ul>
<p>Service Controller：从不同注册中心获取注册实例</p>
<ul>
<li>原生支持 Kubernetes 注册在这些注册中心中的服务可以无痛接入 Mesh，</li>
</ul>
<p>另外一种比较特殊，就是ServiceEntryStore，它本质是储存在 Config Controller 中的<br>Istio 配置数据,但它描述的却是集群外部的服务信息,详情可阅读文档 ServiceEntry</p>
<p>XDSServer：核心的 xDS 协议推送服务，根据上面组件的数据生成 xDS 协议并下发</p>
<ul>
<li>XdsServer 对接所有集群中的边车代理，如 Envoy、MOSN 等，当配置或服务发生变化时主动推送，也会响应代理发送的请求，依据请求的信息下发相应的 xDS 配置。</li>
</ul>
<p>还有对外的接口 Rules API 用于,给管理员的接口，管理员通过这个接口设定一些规则</p>
<p>总结：自动发现的这些Clusters和Endpoints，外加管理员设置的规则，形成了Pilot的数据模型，其实就是 istio<br>定义的一系列数据结构，然后通过envoy API暴露出去，等待envoy去拉取这些规则</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">  configController  model.ConfigStoreCache</span><br><span class="line">  ConfigStores      []model.ConfigStoreCache</span><br><span class="line">  serviceEntryStore *serviceentry.ServiceEntryStore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ConfigStores 是一个列表，里面存储了各类 Istio 配置文件，包括 ServiceEntry 、WorkloadEntry 等<br>服务数据，也包括 VirtualService、DestinationRules、Sidecar 等流量控制、路由规则的配置数据<br>pilot-discovery 将这些 ConfigStores 聚合成一个 <strong>configController 统一进行管理，之后再从其中衍</strong><br><strong>生出 IstioConfigStore，将其作为 serviceEntryStore 的配置源。serviceEntryStore 其实就是</strong><br><strong>ServiceEntry Controller，响应 ServiceEntry 和 WorkloadEntry 这类服务信息的变化。</strong></p>
</blockquote>
<blockquote>
<p>XDSServer 比较核心，一切与 xDS 协议相关的接收、转换、下发操作都由它完成。<br>XDSServer 对接所有集群中的边车代理，如 Envoy、MOSN 等，当配置或服务发生变化<br>时主动推送，也会响应代理发送的请求，依据请求的信息下发相应的 xDS 配置。</p>
</blockquote>
<blockquote>
<p>PushContext 是 Pilot 在推送 xDS 前，生成配置期间保存相关信息的上下文的地方，在全量推送配置和<br>配置发生改变时重置</p>
</blockquote>
<blockquote>
<p>initMeshHandlers 为两个配置文件 mesh 和 meshNetworks 注册了两个 Handler ，当配置文件发生变化时触发全量 xDS 下发<br>下发到每个 Endpoint 好像还没有限流，不知道会不会引发什么并发性的问题</p>
</blockquote>
<blockquote>
<p>initRegistryEventHandlers 设置了三个事件处理器 serviceHandler 、 apigatewayHandler 和 configHandler<br>分别响应服务、实例和配置数据的更新事件.<br>可以看到当服务本身发生变化时，会触发 xDS 的全量下发，所有与该服务相关的代理都会收到推送。<br>十万个节点也全量推送么<br>configController ，它操作的对象主要是像 VirtualService 、 DestinationRules 这些 Istio 定义的配置，这些配置的变化也会触发 xDS 的全量下发<br>ServiceEntryStore 负责ServiceEntry 和 WorkloadEntry<br>RunAndWait 启动后所有 Informer 将开始缓存，并等待它们同步完成</p>
</blockquote>
<p><code>PushContext</code>：跟踪推送状态<br><code>aggregate</code>:ADS 控制器<br><code>DiscoveryServer</code>:从Pilot的内部网格数据结构中获取数据。<br><code>ConfigGenerator</code>:数据平面配置生成器实例。<br><code>Environment</code>:为Pilot提供了一个综合环境API<br><code>NetworksWatcher</code>:l3 层拓扑结构感知<br><code>MeshHandlers</code>:网格和网络处理程序<br><code>MeshConfig</code>:定义了Istio服务网格的设置</p>
<p>上层使用指定注册中心机制，将除了 k8s 之外的依赖支持 MCP 的组件接入到 istio 中。<br>如果外部组件支持 MCP 那么 istio 将会预期建立长连接获取其中的数据。以 Nacos 为例<br>只需要指定 Nacos 就可以从 Nacos 获取数据，支持 MCP 协议就是将数据模型抽象为了中<br>间层。</p>
<hr>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../../../../../11/17/microservices/istio/2021-11-17-istio3/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../../../../18/microservices/k8s/2021-10-18-k8s4/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
