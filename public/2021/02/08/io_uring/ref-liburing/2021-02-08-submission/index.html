<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>Submission [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">Submission</h1>
<article class="post markdown-style">
  <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>提交I&#x2F;O请求的顺序通常是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取一个 SQE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(ring);</span><br><span class="line"><span class="comment">/* 设置一个 readv 操作 */</span></span><br><span class="line">io_uring_prep_readv(sqe, file_fd, fi-&gt;iovecs, blocks, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 设置用户数据 */</span></span><br><span class="line">io_uring_sqe_set_data(sqe, fi);</span><br><span class="line"><span class="comment">/* 最后提交请i去 */</span></span><br><span class="line">io_uring_submit(ring);</span><br></pre></td></tr></table></figure>

<p>上面的代码使用的是：<a target="_blank" rel="noopener" href="https://unixism.net/loti/tutorial/cat_liburing.html#cat-liburing">cat 使用 liburing 实现</a></p>
<p>你调用 <strong>io_ring_get_sqe()</strong> 来获取一个提交队列条目或SQE，使用一个提交辅助器来处理你想要完成的I&#x2F;O类型，比如 <strong>io_uring_prep_readv()</strong> 或 <strong>io_uring_prep_accept()</strong>。调用 <strong>io_uring_set_sqe_data()</strong> 以获取指向唯一标识该请求的数据结构的指针(在完成端获得相同的用户数据)，最后调用io_uring_submit()提交请求。</p>
<p>TODO：您还可以设置轮询以避免调用 <strong><a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_submit">io_uring_submit()</a></strong> 系统调用。</p>
<hr>
<p>struct io_uring_sqe <strong>*io_uring_get_sqe</strong>(struct 【io_uring](<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring</a>) *ring)</p>
<blockquote>
<p>这个函数返回一个提交队列条目，可以用来提交一个I&#x2F;O操作。在调用<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_submit">io_uring_submit()</a>提交内核处理你的请求队列之前，你可以多次调用这个函数来提交I&#x2F;O请求队列。</p>
<p><strong>参数</strong></p>
<ul>
<li>ring:  <a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init">io_uring_queue_init()</a> 设置的 <a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">uring</a> 结构</li>
</ul>
<p>返回值： 一个指向 <strong>io_uring_sqe</strong> 的指针，表示一个空的SQE。如果提交队列已满，则返回NULL。</p>
<p>请看<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#submission-intro-snippet">提交介绍代码片段</a>的使用实例。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://unixism.net/loti/low_level.html#low-level">io_uring 底层接口编程</a></li>
<li><a target="_blank" rel="noopener" href="https://unixism.net/loti/tutorial/cp_liburing.html#cp-liburing">cp 使用 liburing 实现</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_sqe_set_data</strong>(<em>struct</em> io_uring_sqe *sqe, void *data)<br>	这是一个内联方便函数，用于设置传入的SQE实例的用户数据字段。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>SQE：要为其设置用户数据的SQE实例。</li>
<li>data：一个指向用户数据的指针</li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_sqe_set_flags</strong>(<em>struct</em> io_uring_sqe *sqe, unsigned flags)<br>	这是一个内联方便函数，用于设置传入的SQE实例的 flags 字段。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe: 要为其设置用户数据的SQE实例。</li>
<li>flags:你要设置的标志。这是个 bitmap 字段，请参见<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#io-uring-enter">io_uring_enter</a>参考页面，了解各种SQE标志及其含义。</li>
</ul>
</blockquote>
<hr>
<p>int <strong>io_uring_submit</strong>(struct io_uring *ring)<br>	将通过io_uring_get_sqe()获取的SQE提交给内核。当你多次调用io_uring_get_sqe()来设置多个I&#x2F;O请求后，你可以调用一次。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>ring：<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init">io_uring_queue_init()</a> 设置的 <a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">uring</a> 结构</li>
</ul>
<p><strong>返回值</strong>：返回提交的sqe数量。</p>
<h1 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://unixism.net/loti/low_level.html#low-level">io_uring 底层接口编程</a></li>
<li><a target="_blank" rel="noopener" href="https://unixism.net/loti/tutorial/cp_liburing.html#cp-liburing">cp 使用 liburing 实现</a></li>
</ul>
</blockquote>
<hr>
<p>int <strong>io_uring_submit_and_wait</strong>(struct io_uring *ring, unsigned wait_nr)	<br>	和**io_uring_submit()**一样，但是需要一个额外的参数wait_nr，让你指定要等待多少个完成。这个调用将阻塞，直到内核处理wait_nr个提交请求，并将它们的详细信息放入完成队列。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>wait_nr： 等待完成的数量。<br><strong>返回值</strong>：返回提交的sqe数量。</li>
</ul>
</blockquote>
<h1 id="Submission-辅助器"><a href="#Submission-辅助器" class="headerlink" title="Submission 辅助器"></a>Submission 辅助器</h1><p>提交辅助器是方便的函数，它可以轻松地指定你想通过SQE请求的I&#x2F;O操作。每个支持的I&#x2F;O类型都有一个函数。<br>关于**io_uring_prep_readv()**函数的使用实例，请参见<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#submission-intro-snippet">提交介绍代码</a>片段。</p>
<p>void <strong>io_uring_prep_nop</strong>(struct io_uring_sqe *sqe)<br>	此函数用于设置SQE通过读取操作指向的提交队列条目。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd：要读取的文件描述符</li>
<li>buf：用于将读取数据复制到其中的缓冲区</li>
<li>nbytes：要读取的字节数</li>
<li>offset：要读取的文件的绝对偏移量</li>
</ul>
<h1 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></li>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_write</strong>(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned nbytes, off_t offset)<br>	这个函数通过写操作设置sqe所指向的提交队列条目。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd：要读取的文件描述符</li>
<li>buf：用于将读取数据复制到其中的缓冲区</li>
<li>nbytes：要读取的字节数</li>
<li>offset：要读取的文件的绝对偏移量</li>
</ul>
<h1 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/write.2.html">write(2)</a></li>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_readv</strong>(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned nr_vecs, off_t offset)<br>	这个函数用 “scatter” 读操作设置sqe指向的提交队列条目，很像<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a>或<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/preadv.2.html">preadv(2)</a>，它们是Linux的 scatter&#x2F;gather I&#x2F;O 系列系统调用的一部分。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd：要读取的文件描述符</li>
<li>iovecs：指向iovec结构数组的指针</li>
<li>nr_vecs：由iovecs参数指向的数组中iovec实例的数目</li>
<li>offset：要读取的文件的绝对偏移量</li>
</ul>
<h1 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a></li>
<li><a target="_blank" rel="noopener" href="https://unixism.net/loti/tutorial/cat_liburing.html#cat-liburing">使用liburing实现cat程序</a>示例使用了这个函数</li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_read_fixed</strong>(struct io_uring_sqe *sqe, int fd, void *buf, unsigned nbytes, off_t offset, int buf_index)<br>	与io_uring_prep_read()非常类似，该函数通过读取操作设置SQE指向的提交队列条目。主要区别在于，这个函数被设计用来处理通过io_uring_register()注册的一组固定的预分配缓冲区。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd：要读取的文件描述符</li>
<li>buf：用于将读取数据复制到其中的缓冲区</li>
<li>nbytes：要读取的字节数</li>
<li>offset：要读取的文件的绝对偏移量	</li>
<li>buf_index：要使用的预分配缓冲区集的索引。</li>
</ul>
<h1 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-iouring/io_uring_register.html#c.io_uring_register">io_uring_register()</a></li>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></li>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_writev</strong>(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned nr_vecs, off_t offset)<br>	这个函数使用“gather”写操作来设置sqe所指向的提交队列条目，类似于<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/writev.2.html">writev(2)</a>或<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/pwritev.2.html">pwritev(2)</a>，它们是Linux的 scatter&#x2F;gather I&#x2F;O 系列系统调用的一部分。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd：要写入的文件描述符</li>
<li>iovecs：指向iovec结构数组的指针</li>
<li>nr_vecs：由iovecs参数指向的数组中iovec实例的数目</li>
<li>offset：要读取的文件的绝对偏移量</li>
</ul>
<h1 id="参考-6"><a href="#参考-6" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/writev.2.html">writev(2)</a></li>
<li><a target="_blank" rel="noopener" href="https://unixism.net/loti/tutorial/cat_liburing.html#cat-liburing">使用liburing实现cat程序</a>示例使用了这个函数</li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_write_fixed</strong>(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned nbytes, off_t offset, int buf_index)	<br>	TODO：补丁缓冲区案例添加</p>
<blockquote>
<p>与<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read">io_uring_prep_read()</a>非常类似，这个函数通过一个read操作设置sqe所指向的提交队列条目。主要区别在于，这个函数被设计用来处理通过<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-iouring/io_uring_register.html#c.io_uring_register">io_uring_register()</a>注册的一组固定的预分配缓冲区。</p>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd：要写入的文件描述符</li>
<li>buf：用于将读取数据复制到其中的缓冲区</li>
<li>nbytes：要读取的字节数</li>
<li>offset：要读取的文件的绝对偏移量	</li>
<li>buf_index：要使用的预分配缓冲区集的索引。</li>
</ul>
<h1 id="参考-7"><a href="#参考-7" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-iouring/io_uring_register.html#c.io_uring_register">io_uring_register()</a></li>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></li>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_fsync</strong>(struct io_uring_sqe *sqe, int fd, unsigned fsync_flags)<br>	此函数使用类似fsync(2)的操作设置<code>SQE</code>指向的提交队列条目。这会导致磁盘缓存中文件数据和任何缓冲区“脏”数据都同步到磁盘。
	</p>
<blockquote>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><pre><code>请务必注意，将此操作排队并不能保证在此操作之前排队的任何写入操作都会将它们写入文件的数据同步到磁盘。这是因为提交队列中的操作可以由内核并行获取和执行。此同步操作可以在其前面排队的其他写入操作之前完成。它真正起到的作用是，在执行此操作时，文件的任何现有“脏”缓冲区数据都会同步到磁盘。
</code></pre>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd：要读取的文件描述符</li>
<li>fsync_flags: 这个值可以是0，也可以是 <code>IORING_FSYNC_DATASYNC</code>，这使得它像<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/fdatasync.2.html">fdatasync(2)</a>一样。</li>
</ul>
<h1 id="参考-8"><a href="#参考-8" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-iouring/io_uring_register.html#c.io_uring_register">io_uring_register()</a></li>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></li>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek(2)</a></li>
</ul>
</blockquote>
<p>void <strong>io_uring_prep_close</strong>(struct io_uring_sqe *sqe, int fd)<br>	这个函数使用类似close(2)的操作设置sqe所指向的提交队列条目。这将导致fd所指向的文件描述符被关闭。</p>
<blockquote>
<p>参数：</p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd：要读取的文件描述符</li>
</ul>
<h1 id="参考-9"><a href="#参考-9" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/close.2.html">close(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_openat</strong>(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode)<br>	此函数使用类似openat(2)的操作设置SQE指向的提交队列条目。这会导致PATH指向的文件在相对于由DFD目录文件描述符表示的目录的路径中打开。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>dfd: 目录文件描述符，代表要打开文件的相对目录。</li>
<li>path: 要打开的文件的路径名</li>
<li>flags: 标志。这些是访问模式的标志。与<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</a>相同</li>
<li>mode: 模式。创建新文件时应用的文件权限位。与 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</a> 中的相同</li>
</ul>
<h1 id="参考-10"><a href="#参考-10" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/openat.2.html">openat(2)</a></li>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_openat2</strong>(struct io_uring_sqe *sqe, int dfd, const char *path, struct open_how *how)<br>	这个函数用类似<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/openat2.2.html">openat2(2)</a>的操作来设置sqe所指向的提交队列条目。这将导致path指向的文件在相对于dfd目录文件描述符所代表的目录的路径中被打开。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>dfd: 目录文件描述符，代表要打开文件的相对目录。</li>
<li>path: 要打开的文件的路径名</li>
<li>flags: 标志。这些是访问模式的标志。与<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</a>相同</li>
<li>how: 一个指向<code>open_how</code>结构的指针，该结构可以让你控制打开文件的方式。参见<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/openat2.2.html">openat2(2)</a>了解更多细节。</li>
</ul>
<h1 id="参考-11"><a href="#参考-11" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/openat2.2.html">openat2(2)</a></li>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_fallocate</strong>(struct io_uring_sqe *sqe, int fd, int mode, off_t offset, off_t len)		<br>	这个函数使用类似<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/fallocate.2.html">fallocate(2)</a>的操作设置sqe所指向的提交队列条目。<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/fallocate.2.html">fallocate(2)</a>系统调用用于为文件描述符fd表示的文件分配、释放、折叠、置零或增加文件空间。请参阅<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/fallocate.2.html">fallocate(2)</a>了解更多细节。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd：要读取的文件描述符</li>
<li>mode:描述了对文件进行的操作。详情请参见fallocate(2)。</li>
<li>offset：要读取的文件的绝对偏移量	</li>
<li>len：操作长度</li>
</ul>
<h1 id="参考-12"><a href="#参考-12" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/fallocate.2.html">fallocate(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_statx</strong>(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, unsigned mask, struct statx *statxbuf)<br>	这个函数用类似 statx(2) 的操作设置了 sqe 所指向的提交队列条目。statx(2) 系统调用会获取 path 指向的文件的元信息，这些元信息会被填入 statxbuf 指向的 statx 结构中。详见 statx(2) 。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>dfd: 根据this和path的值，path所指向的文件可以被解释为绝对路径文件，相对于process或相对于dfd中的目录描述符引用的目录，以及其他类型的解释都是可能的。详见 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/statx.2.html">statx(2)。</a></li>
<li>path: 文件路径。结合dfd中的值进行解释。详见statx（2）</li>
<li>flags：这用来影响路径名的查询方式，也可以影响内核在查询远程文件系统上的文件时做什么样的同步。详见 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/statx.2.html">statx(2) 。</a></li>
</ul>
<h1 id="参考-13"><a href="#参考-13" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/statx.2.html">statx(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_fadvise</strong>(struct io_uring_sqe *sqe, int fd, off_t offset, off_t len, int advice)<br>	此函数使用类似<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/posix_fadvise.2.html">posix_fadvise(2)</a>的操作用于设置SQE指向的提交队列条目。<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/posix_fadvise.2.html">posix_fadvise(2)</a>系统调用允许应用程序通知操作系统它计划如何访问由文件描述符FD表示的文件中的数据-顺序、随机或其他方式。这是为了提高应用程序的性能。有关更多详细信息，请参见<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/posix_fadvise.2.html">posix_fadvise(2)</a>。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd：要提供 advise 文件的文件描述符</li>
<li>offset：应用 advise 文件的偏移量</li>
<li>len：advise 文件的长度</li>
</ul>
<h1 id="参考-14"><a href="#参考-14" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/posix_fadvise.2.html">posix_fadvise(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_madvise</strong>(struct io_uring_sqe *sqe, void *addr, off_t length, int advice)<br>	这个函数使用类似于<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/madvise.2.html">madvise(2)</a>的操作设置sqe所指向的提交队列条目。<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/madvise.2.html">madvise(2)</a>系统调用让应用程序就addr所指向的内存(长度为字节)通知操作系统。建议包括:应用程序计划如何访问该范围内的内存(顺序、随机或其他方式)，或者当进程产生子进程时，操作系统是否不应该共享该范围内的内存等等。这样做的目的是提高应用程序的性能。详情请参见mdavise(2)。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>addr：advice应用的内存范围的起始地址。</li>
<li>len： advice 的长度</li>
</ul>
<h1 id="参考-15"><a href="#参考-15" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/madvise.2.html">madvise(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_splice</strong>(struct io_uring_sqe *sqe, int fd_in, loff_t off_in, int fd_out, loff_t off_out, unsigned int nbytes, unsigned int splice_flags)<br>	这个函数用类似[splice(2)的操作来设置<code>sqe</code>所指向的提交队列条目。<a href="">splice(2)系统调用在两个文件描述符(<code>fd_in</code>和<code>fd_out</code>)</a>之间复制数据，而不在内核地址空间和用户地址空间之间复制数据。然而，其中一个文件描述符必须代表一个管道。详见 <a href="">splice(2) 。</a></p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</p>
</li>
<li><p><code>fd_in</code>：要读取文件的描述符</p>
</li>
<li><p><code>off_in</code>：如果<code>fd_in</code>是指一个管道，则必须为NULL。如果<code>fd_in</code>不是一个管道，且：</p>
<ul>
<li><code>off_in</code>为NULL，则从<code>fd_in</code>的文件偏移量中读取数据，并相应调整文件偏移量。</li>
<li><code>off_in</code>是非NULL，那么<code>off_in</code>必须指向一个缓冲区，这个缓冲区指定了从<code>fd_in</code>读取字节的起始偏移量。在这种情况下，<code>fd_in</code>的文件偏移量是不变的。</li>
</ul>
</li>
<li><p><code>fd_out</code> 和 <code>off_out</code>： 类似于<code>fd_in</code>和<code>off_in</code>的语句适用于这些参数。</p>
</li>
<li><p>nbytes：要 copy 的字节数量</p>
</li>
<li><p>flags： 影响复制的位掩码。详见 <a href="">splice(2)。</a></p>
</li>
</ul>
<h1 id="参考-16"><a href="#参考-16" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/splice.2.html">splice(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_recvmsg</strong>(struct io_uring_sqe *sqe, int fd, struct msghdr *msg, unsigned flags)<br>	这个函数用类似splice(2)的操作来设置sqe所指向的提交队列条目。splice(2)系统调用在两个文件描述符(fd_in和fd_out)之间复制数据，而不在内核地址空间和用户地址空间之间复制数据。然而，其中一个文件描述符必须代表一个管道。详见 splice(2) 。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd:要读取的socket。</li>
<li>msg:指向msghdr结构体的指针。</li>
<li>flag:影响读取的位掩码。详见recvmsg(2)。</li>
</ul>
<h1 id="参考-17"><a href="#参考-17" class="headerlink" title="参考"></a>参考</h1><ul>
<li>recvmsg(2)</li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_sendmsg</strong>(struct io_uring_sqe *sqe, int fd, const struct msghdr *msg, unsigned flags)<br>	与io_uring_prep_recvmsg()相同，但用于写入套接字。</p>
<blockquote>
<h1 id="参考-18"><a href="#参考-18" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/sendmsg.2.html">sendmsg(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_recv</strong>(struct io_uring_sqe *sqe, int sockfd, void *buf, size_t len, int flags)<br>	这个函数使用类似<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a>的操作设置sqe所指向的提交队列条目。<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a>系统调用用于从套接字读取数据。它使用<code>msghdr</code>结构来减少参数的数量。此调用同时适用于面向连接(如TCP)和无连接(如UDP)套接字。如果没有<code>flags</code>参数，它完全等同于read(2)，除了在处理长度为零数据报时有一个小区别。请参阅<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a>了解更多细节。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd:要读取的socket。</li>
<li>buf：指向读取数据的缓冲区的指针</li>
<li>len：要读取的字节数</li>
<li>flags：影响读取的位掩码。请参见 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a></li>
</ul>
<h1 id="参考-19"><a href="#参考-19" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void io_uring_prep_send(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags)	<br>	与<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_recv">io_uring_prep_recv()</a>相同，但用于写入套接字。</p>
<blockquote>
<h1 id="参考-20"><a href="#参考-20" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/send.2.html">send(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_accept</strong>(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)<br>	这个函数使用类似于[accept4(2)的操作设置sqe所指向的提交队列条目。<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/accept4.2.html">accept4(2)系统调用与面向连接的套接字类型(SOCK_STREAM, SOCK_SEQPACKE</a>T)一起使用。它为侦听套接字fd提取挂起连接队列上的第一个连接请求。当flags参数设置为0时，[accept4(2)就相当于accept(2)。请参阅<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/accept4.2.html">accept4(2)了解更多细</a>节。</p>
<blockquote>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd:要监听的socket。</li>
<li>addr：指向sockaddr结构的指针。这将由对等方的地址填充</li>
<li>addrlen：socklen_t指针。value-result参数，必须用调用的sockaddr结构的大小填充，并将其设置为对等地址的大小。</li>
<li>flags：影响系统调用的位掩码。详见 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/accept4.2.html">accept4(2)</a> 。</li>
</ul>
<h1 id="参考-21"><a href="#参考-21" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/accept4.2.html">accept4(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_connect</strong>(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t addrlen)	<br>	这个函数通过类似<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/connect.2.html">connect(2)</a>的操作设置sqe所指向的提交队列条目。<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/connect.2.html">connect(2)</a>系统调用用于将fd中引用的套接字连接到addr中指定的地址。请参阅<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/connect.2.html">connect(2)</a>了解更多细节。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd:要监听的socket。</li>
<li>addr：指向sockaddr结构的指针。这将由对等方的地址填充</li>
<li>addrlen：socklen_t指针。value-result参数，必须用调用的sockaddr结构的大小填充，并将其设置为对等地址的大小。</li>
</ul>
<h1 id="参考-22"><a href="#参考-22" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/connect.2.html">connect(2)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_epoll_ctl</strong>(struct io_uring_sqe *sqe, int epfd, int fd, int op, struct epoll_event *ev)	<br>	这个函数使用类似于<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/epoll_ctl.2.html">epoll_ctl(2)</a>的操作设置sqe所指向的提交队列条目。<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/epoll_ctl.2.html">epoll_ctl(2)</a>系统调用用于在epfd引用的<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>实例的列表中添加或删除修改条目。op指定的添加、删除或修改操作应用于文件描述符fd。请参阅<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/epoll_ctl.2.html">epoll_ctl(2)</a>了解更多细节。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>epfd：文件描述符表和epoll实例。</li>
<li>fd:要添加、删除或修改的文件描述符。</li>
<li>op: 要执行的epoll操作(EPOLL_CTL_ADD、EPOLL_CTL_DEL或EPOLL_CTL_MOD)</li>
<li>ev: 指向epoll_event结构的指针</li>
</ul>
<h1 id="参考-23"><a href="#参考-23" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/epoll_ctl.2.html">epoll_ctl(2)</a></li>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a></li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_poll_add</strong>(struct io_uring_sqe *sqe, int fd, short poll_mask)<br>	这个函数使用类似 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a> 操作设置sqe所指向的提交队列条目，将文件描述符添加到poll的列表，并侦听poll_mask中指定的事件。与不带EPOLLONESHOT的poll或epoll不同，此接口始终以单次模式工作。也就是说，一旦轮询操作完成，就必须重新提交它。参见<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>了解更多细节。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>fd:用于轮询事件的文件描述符。</li>
<li>poll_mask: 包含要侦听的事件的位掩码</li>
</ul>
<h1 id="参考-24"><a href="#参考-24" class="headerlink" title="参考"></a>参考</h1><ul>
<li><pre><code>[poll(2)](http://man7.org/linux/man-pages/man2/poll.2.html)
</code></pre>
</li>
</ul>
</blockquote>
<hr>
<p>void <strong>io_uring_prep_poll_remove</strong>(struct io_uring_sqe *sqe, void *user_data)<br>	从通过<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>监视请求中删除。</p>
<blockquote>
<p><strong>参数</strong></p>
<ul>
<li>sqe：SQE的指针，通常由<a target="_blank" rel="noopener" href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li>
<li>user_data:用户数据指针。与此用户数据关联的请求将从进一步的监视中删除。</li>
</ul>
<h1 id="参考-25"><a href="#参考-25" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a></li>
</ul>
</blockquote>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../../../ebpf/2021-02-08-index/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../2021-02-08-setup_teardown/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
