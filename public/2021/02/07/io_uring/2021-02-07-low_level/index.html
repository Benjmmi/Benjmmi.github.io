<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>io_uring 底层接口 [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">io_uring 底层接口</h1>
<article class="post markdown-style">
  <h1 id="io-uring-的底层接口"><a href="#io-uring-的底层接口" class="headerlink" title="io_uring 的底层接口"></a>io_uring 的底层接口</h1><p>正如在前一个文章中所建议的那样，您不太可能在正式的程序中使用 <code>io_uring</code> 底层的 API。但是知道接口真正使用起来是什么样的方式总是一个好主意。为此，您必须通过共享环缓冲区和相关的 <code>io_uring</code> 系统调用来处理 <code>io_uring</code> 直接呈现给程序的接口。一个很好、简单的例子，可以很好地展示这个接口。为此，在这里，我们提供了一个模拟 Unix cat 实用程序的示例。为了保持简单，我们将创建一个程序，一次显示一个操作，等待它完成并显示下一个操作等等。虽然一个真正的程序也可以使用同步&#x2F;阻塞调用来以这种方式完成工作，但这个程序的主要目的是让您熟悉 i&#x2F;o 接口，而不会受到其他程序逻辑的干扰。</p>
<h2 id="熟悉readv（2）系统调用"><a href="#熟悉readv（2）系统调用" class="headerlink" title="熟悉readv（2）系统调用"></a>熟悉<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/readv.2.html">readv（2）</a>系统调用</h2><p>为了更好地理解这个示例，您需要熟悉 <code>[readv（2）](http://man7.org/linux/man-pages/man2/readv.2.html)</code>系统调用。如果你不熟悉它，我建议你读<a target="_blank" rel="noopener" href="https://unixism.net/2020/04/io-uring-by-example-part-1-introduction/">一个更通俗的介绍</a>，然后回到这里继续。</p>
<h2 id="底层接口介绍"><a href="#底层接口介绍" class="headerlink" title="底层接口介绍"></a>底层接口介绍</h2><p>它的接口很简单。有一个提交队列和一个完成队列。在提交队列中，您可以提交你想要完成的各种操作的信息。例如，在我们当前的程序中，我们希望使用 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/readv.2.html">readv（2）</a>读取文件，因此我们放置一个提交队列请求，将其描述为提交队列条目(SQE)的一部分。此外，您可以放置多个请求。根据队列深度(您可以定义)允许的请求数量。这些操作可以是读、写等操作的混合。这些操作可以是读、写等操作的混合。然后，我们调用 <code>[io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code>系统调用，告诉内核我们已经向提交队列添加了请求。一旦它完成了这些请求的处理，它将结果作为 CQE 的一部分放置在完成队列中，或者为每个相应的 SQE 放置一个完成队列条目。这些 CQEs 可以立即从用户空间访问，因为它们被放置在一个由内核和用户空间共享的缓冲区中。</p>
<p>我们在前面已经讨论了 io_uring 的这个特殊优点，但是聪明的读者会注意到这样一个接口: 用多个 i&#x2F;o 请求填充到一个队列中，然后进行一次系统调用的接口，而不是对每个I&#x2F;O请求进行一次系统调用，这样就已经很高效了。为了进一步提高效率，<code>io_uring</code> 支持了一种模式，在这种模式下，内核会对你加入提交队列的条目进行轮询，<br>而你甚至不需要调用 **<code>[io_uring_enter ()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code>**来通知内核更新的提交队列条目。另一点需要注意的是，<br>在 <strong>Specter</strong> 和 <strong>Meltdown</strong> 硬件漏洞被发现并且操作系统为其创建了解决方案之后，系统调用比以往任何时候都要昂贵。因此，对于高性能应用程序来说，减少系统调用的数量确实是一件大事。</p>
<p>在执行这些操作之前，需要设置队列，它们实际上是具有一定深度&#x2F;长度的环形缓冲区。<br>您可以调用 **<code>[io_ uring_setup ()](https://unixism.net/loti/ref-iouring/io_uring_setup.html#c.io_uring_setup)</code>**系统调用来完成此操作。我们通过将提交队列条目添加到循环缓冲区并从完成队<br>列循环缓冲区读取完成队列条目来完成真正的工作。这是对这个io_uring接口设计的概述。</p>
<h2 id="完成队列条目"><a href="#完成队列条目" class="headerlink" title="完成队列条目"></a>完成队列条目</h2><p>现在我们已经有了一个关于如何工作的心智模型，让我们更详细地看看这是如何完成的。与提交队列条目(SQE)相比，<br>完成队列条目(CQE)非常简单。那么，让我们先来看看。SQE 是一个 <strong><code>io_uring_sqe</code></strong> 结构的实例，您可以使用它提交请求。<br>将其添加到提交环缓冲区。CQE 是一个 <strong>io_uring_cqe</strong> 结构的实例，内核对添加到提交队列中的每个 <strong><code>io_uring_sqe</code></strong> 结构实例进行响应。它包含您通过 SQE 实例请求的操作的结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> &#123;</span></span><br><span class="line">  __u64  user_data;   <span class="comment">/* sqe-&gt;user_data submission passed back */</span></span><br><span class="line">  __s32  res;         <span class="comment">/* 此事件的结果代码 */</span></span><br><span class="line">  __u32  flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="将完成与提交相关联"><a href="#将完成与提交相关联" class="headerlink" title="将完成与提交相关联"></a>将完成与提交相关联</h2><p>正如在代码注释中提到的，<strong>user_data</strong> 字段是按原样从 SQE 传递到 CQE 实例的。假设您在提交队列中提交了一组请求，那么这些请求不一定以相同的顺序完成，<br>也不必以 CQEs 的身份出现在完成队列中。以下面的场景为例: 您的机器上有两个磁盘: 一个是慢速旋转的硬盘驱动器，另一个是超快的 SSD。<br>您在提交队列中提交2个请求。第一个在慢速旋转的硬盘上读取100kB 的文件，第二个在快速固态硬盘上读取同样大小的文件。<br>如果维护排序，即使来自 SSD 文件的数据会更早到达，内核是否应该等待来自旋转硬盘上的文件的数据变得可用？这是个不好的想法，<br>因为这会阻止我们以最快的速度运行。因此，当 CQEs 可用时，它们可以按任意顺序到达。无论哪个操作完成，其结果都会在 CQ 上公布。<br>由于 CQEs 的到达没有特定的顺序，现在你已经知道了从上面的 <strong>io_uring_cqe</strong> 结构中看到的 CQE 是什么样子的，你如何识别一个特定 CQE 对应的 SQE 请求？一种方法是使用 SQEs 和 CQEs 共有的 <strong>user_data</strong> 字段来标识完成情况。并不是说你要设置一个唯一的 ID 或者其他什么，而是你通常会传递一个指针。如果你对此感到困惑，那就等着看后面的例子吧。</p>
<p>完成队列条目很简单，因为它主要关注系统调用的返回值，这个返回值在 res 字段中返回。例如，如果您读取操作队列成功执行完成，那么它将包含读取的字节数。如果有错误，它将包含一个负的错误号。本质上，**<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a>**系统调用自身的内容将返回。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>虽然我提到了 CQEs 可以以任何顺序到达，但是您可以强制使用 SQE 排序对某些操作进行排序，实际上是将它们链接起来。有关更多细节，请参见<a target="_blank" rel="noopener" href="https://unixism.net/loti/tutorial/link_liburing.html#link-liburing">链接</a>请求教程。</p>
<h2 id="提交队列条目"><a href="#提交队列条目" class="headerlink" title="提交队列条目"></a>提交队列条目</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">     <span class="type">void</span>  *iov_base;    <span class="comment">/*开始地址 */</span></span><br><span class="line">     <span class="type">size_t</span> iov_len;     <span class="comment">/*要传输的字节数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>iovec 每个结构只指向一个缓冲区。基址和长度。</p>
<p>submission 队列条目比 completion 队列条目稍微复杂一些，因为它需要足够通用，以表示和处理目前 Linux 可能采用的各种 i&#x2F;o操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">  __u8  opcode;   <span class="comment">/* 指定操作类型 */</span></span><br><span class="line">  __u8  flags;    <span class="comment">/* IOSQE_ 标记 */</span></span><br><span class="line">  __u16  ioprio;  <span class="comment">/* ioprio 请求 */</span></span><br><span class="line">  __s32  fd;      <span class="comment">/* 要执行 IO 的文件描述符 */</span></span><br><span class="line">  __u64  off;     <span class="comment">/* 文件偏移 */</span></span><br><span class="line">  __u64  addr;    <span class="comment">/* 指向缓冲区或者iovecs */</span></span><br><span class="line">  __u32  len;     <span class="comment">/* 缓冲区大小或者iovecs 数量 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">__kernel_rwf_t</span>  rw_flags;</span><br><span class="line">    __u32    fsync_flags;</span><br><span class="line">    __u16    poll_events;</span><br><span class="line">    __u32    sync_range_flags;</span><br><span class="line">    __u32    msg_flags;</span><br><span class="line">  &#125;;</span><br><span class="line">  __u64  user_data;   <span class="comment">/* 完成时传回的数据  */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    __u16  buf_index; <span class="comment">/* 索引到固定缓冲区（如果使用） */</span></span><br><span class="line">    __u64  __pad2[<span class="number">3</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我知道这个结构看起来很繁杂。通常使用的字段只有少数，这很容易用一个简单的例子来解释，<br>比如我们正在处理的这个字段: cat。当你想使用 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a>系统调用读取一个文件时:</p>
<ul>
<li>opcode 用于指定操作，在这个case 中， <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a> 使用的是 <strong>IORING_OP_READV</strong> 常量</li>
<li>fd 用于指定表示要从中读取的文件的文件描述符</li>
<li>addr 用于指向 iovec 结构的数组，这些结构包含我们为 i&#x2F;o 分配的缓冲区的地址和长度。</li>
<li>len  用于保存 iovec 结构的数组的长度。</li>
</ul>
<p>这并不是很难，不是吗？你填写这些值，让 io_uring 知道该做什么。你可以将多个SQE 加入队列，最后当你想让内核开始处理你 SQE 队列的请求时，调用 <strong><code>[io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code></strong> 。</p>
<h2 id="使用-io-uring-实现-cat-命令"><a href="#使用-io-uring-实现-cat-命令" class="headerlink" title="使用 io_uring 实现 cat 命令"></a>使用 io_uring 实现 cat 命令</h2><p>让我们看看如何通过使用底层 <strong>io_uring</strong> 接口的来实现类似 cat 实用程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果你编译失败缺少这个头文件，那么是因为你得内核版本太低了</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io_uring.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_DEPTH 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_SZ    1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  x86规范 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> read_barrier()  __asm__ __volatile__(<span class="string">&quot;&quot;</span>:::<span class="string">&quot;memory&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> write_barrier() __asm__ __volatile__(<span class="string">&quot;&quot;</span>:::<span class="string">&quot;memory&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">struct io_uring_sqe &#123;</span></span><br><span class="line"><span class="comment">  __u8  opcode;   // sqe 操作类型代码</span></span><br><span class="line"><span class="comment">  __u8  flags;    // IOSQE_ flags </span></span><br><span class="line"><span class="comment">  __u16  ioprio;  // 请求ioprio</span></span><br><span class="line"><span class="comment">  __s32  fd;      // 执行IO操作的文件描述符</span></span><br><span class="line"><span class="comment">  __u64  off;     // 文件中的偏移量 </span></span><br><span class="line"><span class="comment">  __u64  addr;    // 指向缓冲区或iovecs的指针</span></span><br><span class="line"><span class="comment">  __u32  len;     // 缓冲区大小或iovecs数量</span></span><br><span class="line"><span class="comment">  union &#123;</span></span><br><span class="line"><span class="comment">    __kernel_rwf_t  rw_flags;</span></span><br><span class="line"><span class="comment">    __u32    fsync_flags;</span></span><br><span class="line"><span class="comment">    __u16    poll_events;</span></span><br><span class="line"><span class="comment">    __u32    sync_range_flags;</span></span><br><span class="line"><span class="comment">    __u32    msg_flags;</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">  __u64  user_data;   // 完成时要传回的数据</span></span><br><span class="line"><span class="comment">  union &#123;</span></span><br><span class="line"><span class="comment">    __u16  buf_index; // 索引到固定缓冲区(如果使用)</span></span><br><span class="line"><span class="comment">    __u64  __pad2[3];</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct io_uring_params &#123;</span></span><br><span class="line"><span class="comment">  __u32 sq_entries;</span></span><br><span class="line"><span class="comment">  __u32 cq_entries;</span></span><br><span class="line"><span class="comment">  __u32 flags;</span></span><br><span class="line"><span class="comment">  __u32 sq_thread_cpu;</span></span><br><span class="line"><span class="comment">  __u32 sq_thread_idle;</span></span><br><span class="line"><span class="comment">  __u32 resv[5];</span></span><br><span class="line"><span class="comment">  struct io_sqring_offsets sq_off;</span></span><br><span class="line"><span class="comment">  struct io_cqring_offsets cq_off;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">app_io_sq_ring</span> &#123;</span> <span class="comment">// Submission ring</span></span><br><span class="line">    <span class="type">unsigned</span> *head;</span><br><span class="line">    <span class="type">unsigned</span> *tail;</span><br><span class="line">    <span class="type">unsigned</span> *ring_mask;</span><br><span class="line">    <span class="type">unsigned</span> *ring_entries;</span><br><span class="line">    <span class="type">unsigned</span> *flags;</span><br><span class="line">    <span class="type">unsigned</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">app_io_cq_ring</span> &#123;</span> <span class="comment">// completions ring</span></span><br><span class="line">    <span class="type">unsigned</span> *head;</span><br><span class="line">    <span class="type">unsigned</span> *tail;</span><br><span class="line">    <span class="type">unsigned</span> *ring_mask;</span><br><span class="line">    <span class="type">unsigned</span> *ring_entries;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqes</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">submitter</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ring_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_sq_ring</span> <span class="title">sq_ring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqes</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_cq_ring</span> <span class="title">cq_ring</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> &#123;</span></span><br><span class="line">    <span class="type">off_t</span> file_sz;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovecs</span>[];</span>      <span class="comment">/* Referred by readv/writev */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这段代码是在io_uring相关的系统调用不属于标准C库的时候编写的。 </span></span><br><span class="line"><span class="comment">* 所以，我们推出了自己的系统调用封装函数。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">io_uring_setup</span><span class="params">(<span class="type">unsigned</span> entries, <span class="keyword">struct</span> io_uring_params *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) syscall(__NR_io_uring_setup, entries, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">io_uring_enter</span><span class="params">(<span class="type">int</span> ring_fd, <span class="type">unsigned</span> <span class="type">int</span> to_submit,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> <span class="type">int</span> min_complete, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) syscall(__NR_io_uring_enter, ring_fd, to_submit, min_complete,</span><br><span class="line">                flags, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回传入的打开文件描述符的文件大小。也能正确处理常规文件和驱动设备。很好。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">get_file_size</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (S_ISBLK(st.st_mode)) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> bytes;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(fd, BLKGETSIZE64, &amp;bytes) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(st.st_mode))</span><br><span class="line">        <span class="keyword">return</span> st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* io_uring需要进行大量的设置，这些设置看起来相当复杂，但并不都很难理解。</span></span><br><span class="line"><span class="comment">* 因为所有这些案例代码， 都在 io_uring的作者创建的liburing中，而且 liburing 相对容易使用。</span></span><br><span class="line"><span class="comment">* 但是，您应该花些时间来理解这段代码。</span></span><br><span class="line"><span class="comment">* 了解它的工作原理总是好的。出去好吹牛逼</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">app_setup_uring</span><span class="params">(<span class="keyword">struct</span> submitter *s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_sq_ring</span> *<span class="title">sring</span> =</span> &amp;s-&gt;sq_ring;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_cq_ring</span> *<span class="title">cring</span> =</span> &amp;s-&gt;cq_ring;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="type">void</span> *sq_ptr, *cq_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 我们需要将 io_uring_params 结构传递给的io_uring_setup（）调用并初始化为0。 </span></span><br><span class="line"><span class="comment">    * 如果需要，我们可以设置任何标志，但是对于本示例，我们不需要，因为这里只是做了简单的了解。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// io_uring_setup 返回值将用于调用 mmap 将两个环缓冲区和一组提交队列映射到用户空间</span></span><br><span class="line">    s-&gt;ring_fd = io_uring_setup(QUEUE_DEPTH, &amp;p);</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;ring_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_setup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * io_uring 通过两个 kernel-user 共享空间形成环形缓冲区通信。在最近的内核中，可以用 mmap() 调用来</span></span><br><span class="line"><span class="comment">    * 联合映射这个环形缓冲区。在直接操作完成队列时，提交队列有一个介于两者之间的间接数组。我们把它也映射进去。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sring_sz = p.sq_off.<span class="built_in">array</span> + p.sq_entries * <span class="keyword">sizeof</span>(<span class="type">unsigned</span>);</span><br><span class="line">    <span class="type">int</span> cring_sz = p.cq_off.cqes + p.cq_entries * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_cqe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 在内核版本 5.4 及以上，可能使用一个 mmap()  来映射 completion 缓冲区和 submission缓冲区.</span></span><br><span class="line"><span class="comment">    * 如果去检测内核版本还不如直接使用 io_uring_params 结构的特征字段，这是一个位掩码。如果设置了 IORING_FEAT_SINGLE_MMAP </span></span><br><span class="line"><span class="comment">    * 那么我们就可以不用再调用第二个mmap()来映射 CQ ring。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">if</span> (p.features &amp; IORING_FEAT_SINGLE_MMAP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cring_sz &gt; sring_sz) &#123;</span><br><span class="line">            sring_sz = cring_sz;</span><br><span class="line">        &#125;</span><br><span class="line">        cring_sz = sring_sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * submission 队列和 completion 队列可以映射到 ring 缓冲区，但是老版本的内核只能映射到队列中。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    sq_ptr = mmap(<span class="number">0</span>, sring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">            MAP_SHARED | MAP_POPULATE,</span><br><span class="line">            s-&gt;ring_fd, IORING_OFF_SQ_RING);</span><br><span class="line">    <span class="keyword">if</span> (sq_ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.features &amp; IORING_FEAT_SINGLE_MMAP) &#123;</span><br><span class="line">        cq_ptr = sq_ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 在旧的内核中分别映射完成队列环缓冲区 */</span></span><br><span class="line">        cq_ptr = mmap(<span class="number">0</span>, cring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">                MAP_SHARED | MAP_POPULATE,</span><br><span class="line">                s-&gt;ring_fd, IORING_OFF_CQ_RING);</span><br><span class="line">        <span class="keyword">if</span> (cq_ptr == MAP_FAILED) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  将有用的字段保存在全局app_io_sq_ring结构中，以便以后方便地引用*/</span></span><br><span class="line">    sring-&gt;head = sq_ptr + p.sq_off.head;</span><br><span class="line">    sring-&gt;tail = sq_ptr + p.sq_off.tail;</span><br><span class="line">    sring-&gt;ring_mask = sq_ptr + p.sq_off.ring_mask;</span><br><span class="line">    sring-&gt;ring_entries = sq_ptr + p.sq_off.ring_entries;</span><br><span class="line">    sring-&gt;flags = sq_ptr + p.sq_off.flags;</span><br><span class="line">    sring-&gt;<span class="built_in">array</span> = sq_ptr + p.sq_off.<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 映射到提交队列条目数组中 */</span></span><br><span class="line">    s-&gt;sqes = mmap(<span class="number">0</span>, p.sq_entries * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_sqe),</span><br><span class="line">            PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,</span><br><span class="line">            s-&gt;ring_fd, IORING_OFF_SQES);</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;sqes == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将有用的字段保存在全局的app_io_cq_ring结构中，以便以后方便地引用 */</span></span><br><span class="line">    cring-&gt;head = cq_ptr + p.cq_off.head;</span><br><span class="line">    cring-&gt;tail = cq_ptr + p.cq_off.tail;</span><br><span class="line">    cring-&gt;ring_mask = cq_ptr + p.cq_off.ring_mask;</span><br><span class="line">    cring-&gt;ring_entries = cq_ptr + p.cq_off.ring_entries;</span><br><span class="line">    cring-&gt;cqes = cq_ptr + p.cq_off.cqes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将长度为len的字符串输出到标准输出。我们在这里使用缓冲输出以提高效率，因为我们需要逐字符输出。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">output_to_console</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">        fputc(*buf++, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 从 completion 队列读取。在这个函数中，我们从 completion 队列中读取完成事件，</span></span><br><span class="line"><span class="comment">* 获取包含文件数据的数据缓冲区，并将其打印到控制台。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_from_cq</span><span class="params">(<span class="keyword">struct</span> submitter *s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">fi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_cq_ring</span> *<span class="title">cring</span> =</span> &amp;s-&gt;cq_ring;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> head, reaped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    head = *cring-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        read_barrier();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 记住，这是一个环形缓冲区。如果head == tail，则表示缓冲区为空。</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (head == *cring-&gt;tail)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 获取一个条目 */</span></span><br><span class="line">        cqe = &amp;cring-&gt;cqes[head &amp; *s-&gt;cq_ring.ring_mask];</span><br><span class="line">        fi = (<span class="keyword">struct</span> file_info*) cqe-&gt;user_data;</span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, strerror(<span class="built_in">abs</span>(cqe-&gt;res)));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> blocks = (<span class="type">int</span>) fi-&gt;file_sz / BLOCK_SZ;</span><br><span class="line">        <span class="keyword">if</span> (fi-&gt;file_sz % BLOCK_SZ) blocks++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; blocks; i++)</span><br><span class="line">            output_to_console(fi-&gt;iovecs[i].iov_base, fi-&gt;iovecs[i].iov_len);</span><br><span class="line"></span><br><span class="line">        head++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    *cring-&gt;head = head;</span><br><span class="line">    write_barrier();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 提交到 submission 队列.</span></span><br><span class="line"><span class="comment">* 在这个方法, 我们提交请求到 submission 队列. </span></span><br><span class="line"><span class="comment">* 您可以提交多种类型的请求。我们的将是readv()请求，我们通过IORING_OP_READV来指定。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">submit_to_sq</span><span class="params">(<span class="type">char</span> *file_path, <span class="keyword">struct</span> submitter *s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">fi</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> file_fd = open(file_path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (file_fd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_sq_ring</span> *<span class="title">sring</span> =</span> &amp;s-&gt;sq_ring;</span><br><span class="line">    <span class="type">unsigned</span> index = <span class="number">0</span>, current_block = <span class="number">0</span>, tail = <span class="number">0</span>, next_tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> file_sz = get_file_size(file_fd);</span><br><span class="line">    <span class="keyword">if</span> (file_sz &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">off_t</span> bytes_remaining = file_sz;</span><br><span class="line">    <span class="type">int</span> blocks = (<span class="type">int</span>) file_sz / BLOCK_SZ;</span><br><span class="line">    <span class="keyword">if</span> (file_sz % BLOCK_SZ) blocks++;</span><br><span class="line"></span><br><span class="line">    fi = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*fi) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iovec) * blocks);</span><br><span class="line">    <span class="keyword">if</span> (!fi) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to allocate memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fi-&gt;file_sz = file_sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 对于需要读取的每个文件块，我们分配一个iovec结构体，该结构体被索引到iovecs数组中。</span></span><br><span class="line"><span class="comment">    * 此数组作为提交的一部分传入。如果您不理解这一点，那么您需要查看readv()和writev()系统调用是如何工作的。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">while</span> (bytes_remaining) &#123;</span><br><span class="line">        <span class="type">off_t</span> bytes_to_read = bytes_remaining;</span><br><span class="line">        <span class="keyword">if</span> (bytes_to_read &gt; BLOCK_SZ)</span><br><span class="line">            bytes_to_read = BLOCK_SZ;</span><br><span class="line"></span><br><span class="line">        fi-&gt;iovecs[current_block].iov_len = bytes_to_read;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> *buf;</span><br><span class="line">        <span class="keyword">if</span>( posix_memalign(&amp;buf, BLOCK_SZ, BLOCK_SZ)) &#123;</span><br><span class="line">            perror(<span class="string">&quot;posix_memalign&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fi-&gt;iovecs[current_block].iov_base = buf;</span><br><span class="line"></span><br><span class="line">        current_block++;</span><br><span class="line">        bytes_remaining -= bytes_to_read;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将我们的 submission 队列条目添加到SQE ring缓冲区的尾部 */</span></span><br><span class="line">    next_tail = tail = *sring-&gt;tail;</span><br><span class="line">    next_tail++;</span><br><span class="line">    read_barrier();</span><br><span class="line">    index = tail &amp; *s-&gt;sq_ring.ring_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> &amp;s-&gt;sqes[index];</span><br><span class="line">    sqe-&gt;fd = file_fd;</span><br><span class="line">    sqe-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    sqe-&gt;opcode = IORING_OP_READV;</span><br><span class="line">    sqe-&gt;addr = (<span class="type">unsigned</span> <span class="type">long</span>) fi-&gt;iovecs;</span><br><span class="line">    sqe-&gt;len = blocks;</span><br><span class="line">    sqe-&gt;off = <span class="number">0</span>;</span><br><span class="line">    sqe-&gt;user_data = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) fi;</span><br><span class="line">    sring-&gt;<span class="built_in">array</span>[index] = index;</span><br><span class="line">    tail = next_tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新尾部以便内核能够看到它. */</span></span><br><span class="line">    <span class="keyword">if</span>(*sring-&gt;tail != tail) &#123;</span><br><span class="line">        *sring-&gt;tail = tail;</span><br><span class="line">        write_barrier();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 用io_uring_enter()系统调用告诉内核我们已经提交了事件。</span></span><br><span class="line"><span class="comment">    * 我们还传递了IOURING_ENTER_GETEVENTS标志，</span></span><br><span class="line"><span class="comment">    * 它使io_uring_enter()调用等到min_complete事件（第3个参数）完成。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">int</span> ret =  io_uring_enter(s-&gt;ring_fd, <span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">            IORING_ENTER_GETEVENTS);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_enter&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">submitter</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;filename&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*s));</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(*s));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(app_setup_uring(s)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup uring!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(submit_to_sq(argv[i], s)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error reading file\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        read_from_cq(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>让我们更深入地研究代码中特定的、重要的领域，看看这个示例程序是如何工作的。</p>
<h2 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h2><p>在 <strong>main()</strong> 中，我们调用 <strong>app_setup_uring()</strong> ，它完成了我们使用 <strong>io_uring</strong> 所需的初始化工作。首先，我们调用 <strong>io_uring_setup()</strong> 系统调用，将我们需要的队列深度和结构 <strong>io_uring_params</strong> 的实例全部设置为0。当调用返回时，内核将填充这个结构成员中的值。这就是 <strong>io_uring_params</strong> 的样子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> &#123;</span></span><br><span class="line">  __u32 sq_entries;</span><br><span class="line">  __u32 cq_entries;</span><br><span class="line">  __u32 flags;</span><br><span class="line">  __u32 sq_thread_cpu;</span><br><span class="line">  __u32 sq_thread_idle;</span><br><span class="line">  __u32 resv[<span class="number">5</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_sqring_offsets</span> <span class="title">sq_off</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_cqring_offsets</span> <span class="title">cq_off</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在将这个结构作为 **<code>io_uring_setup ()</code>**系统调用的一部分传递之前，您唯一可以指定的是 flags 结构成员，但是在这个示例中，<br>我们不想传递任何 flag 。此外，在这个示例中，我们一个接一个地处理文件。我们不打算做任何并行 i&#x2F;o，因为这是一个简单的例子，主要是为了了解 io_uring 的原始接口。为此，我们将队列深度设置为1。</p>
<p>来自 <strong><code>io_uring_setup ()</code></strong> 的返回值、文件描述符和 <strong>io_uring_param</strong> 结构中的其他字段随后将用于调用 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap(2)</a>以将两个环缓冲区和一组提交队列条目映射到用户空间。看看吧。我已经删除了一些周围的代码，以便将重点放在 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap(2)</a> 调用上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* submission 和 completion 队列中映射环形缓冲区.</span></span><br><span class="line"><span class="comment"> * 不过旧的内核只在提交队列中映射。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">sq_ptr = mmap(<span class="number">0</span>, sring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">        MAP_SHARED | MAP_POPULATE,</span><br><span class="line">        s-&gt;ring_fd, IORING_OFF_SQ_RING);</span><br><span class="line"><span class="keyword">if</span> (sq_ptr == MAP_FAILED) &#123;</span><br><span class="line">    perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p.features &amp; IORING_FEAT_SINGLE_MMAP) &#123;</span><br><span class="line">    cq_ptr = sq_ptr;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 在旧内核中单独映射完成队列环形缓冲区 */</span></span><br><span class="line">    cq_ptr = mmap(<span class="number">0</span>, cring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">            MAP_SHARED | MAP_POPULATE,</span><br><span class="line">            s-&gt;ring_fd, IORING_OFF_CQ_RING);</span><br><span class="line">    <span class="keyword">if</span> (cq_ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 映射到提交队列条目数组中 */</span></span><br><span class="line">s-&gt;sqes = mmap(<span class="number">0</span>, p.sq_entries * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_sqe),</span><br><span class="line">        PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,</span><br><span class="line">        s-&gt;ring_fd, IORING_OFF_SQES);</span><br></pre></td></tr></table></figure>

<p>我们将重要的细节保存在 <strong><code>app_io_sq_ring</code></strong> 和 <strong><code>app_io_cq_ring</code></strong> 中，以便以后参考。<br>当我们将两个环缓冲区分别映射为提交和完成时，您可能想知道第三个映射是用来做什么的。<br>完成队列环直接对 CQEs 的共享数组建立索引，而提交环在两者之间有一个间接数组。<br>提交端环形缓冲区是该数组的索引，该数组又包含 SQEs 中的索引。这对于将提交请求嵌入内部数据结构的某些应用程序非常有用。<br>这种设置允许他们一次提交多个提交条目，同时允许他们更容易地采用io_uring。</p>
<pre><code># 注意
在内核版本5.4及以上，单个 mmap (2)映射提交队列和完成队列。然而，在较老的内核中，
它们需要单独映射。与检查内核版本不同，
您可以通过检查 IORING_FEAT_SINGLE_MMAP  功能标志来检查内核使用一个 mmap (2)映射两个队列的能力，就像我们在上面的代码中所做的那样。

# 参考
- [io_uring_setup](https://unixism.net/loti/ref-iouring/io_uring_setup.html#io-uring-setup)
</code></pre>
<h2 id="处理共享-ring-缓冲器"><a href="#处理共享-ring-缓冲器" class="headerlink" title="处理共享 ring 缓冲器"></a>处理共享 ring 缓冲器</h2><p>在常规编程中，我们习惯于处理用户空间和内核之间非常清晰的接口: 系统调用。然而，<br>系统调用确实有成本，对于像 <strong>io_uring</strong> 这样的高性能接口，希望尽可能去掉系统调用。<br>我们在前面看到，与通常的多个系统调用不同，使用 io_uring<br>允许我们批处理多个 i&#x2F;o 请求，并对 <strong><code>[io_uring_enter ()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code></strong> 系统调用进行单个调用。或者在<a target="_blank" rel="noopener" href="https://unixism.net/loti/tutorial/sq_poll.html#sq-poll">轮询模式</a>下，甚至不需要调用。</p>
<p>当从用户空间读取或更新共享 ring 缓冲区时，需要注意一些事项，以确保在读取时看到最新的数据，<br>并在更新之后“刷新”或“同步”写操作，以便内核看到您的更新。这是因为 CPU 可以重新安排读写顺序，<br>编译器也可以。当读写操作发生在同一个 CPU 上时，这通常不是问题。但是在 <strong><code>io_uring</code></strong> 的情况下，<br>当一个共享缓冲区涉及到两个不同的上下文: 用户空间和内核，并且它们在上下文<br>切换之后可以在不同的 cpu 上运行。您需要确保从用户空间读取之前，先前的写操作是可见的。<br>或者，当您在 SQE 中填充细节并更新提交缓冲区的尾部时，您希望确保在更新环缓冲区尾部的写入之前，<br>对 SQE 成员进行的写入是有序的。如果这些写操作没有被排序，内核可能会看到尾部被更新，<br>但是当它读取 SQE 时，它可能无法在读取 SQE 时找到所需的所有数据。在轮询模式中，<br>内核正在查找对尾部的更改，这就成了一个真正的问题。<br>这都是因为 cpu 和编译器为了优化而对读写进行重新排序。</p>
<h2 id="读取完成队列条目"><a href="#读取完成队列条目" class="headerlink" title="读取完成队列条目"></a>读取完成队列条目</h2><p>一如既往，我们首先处理事情的完成方面，因为它比提交方面更简单。<br>这些解释甚至是必要的，因为我们需要讨论内存的顺序和我们需要如何处理它。<br>否则，我们只想看看如何处理环形缓冲区。对于完成事件，内核将 CQEs 添加到循环缓冲区并更新尾部，<br>而我们在用户空间中从头部读取。在任何环形缓冲区中，如果头部和尾部相等，则表示环形缓冲区为空。看看下面的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> head;</span><br><span class="line">head = cqring-&gt;head;</span><br><span class="line">read_barrier(); <span class="comment">/* 确保以前的写入可见 */</span></span><br><span class="line"><span class="keyword">if</span> (head != cqring-&gt;tail) &#123;</span><br><span class="line">    <span class="comment">/* 环形缓冲区中有可用的数据 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> index;</span><br><span class="line">    index = head &amp; (cqring-&gt;mask);</span><br><span class="line">    cqe = &amp;cqring-&gt;cqes[index];</span><br><span class="line">    <span class="comment">/* 在此处完成cqe过程 */</span></span><br><span class="line">     ...</span><br><span class="line">    <span class="comment">/* 我们现在已经消耗了这一项 */</span></span><br><span class="line">    head++;</span><br><span class="line">&#125;</span><br><span class="line">cqring-&gt;head = head;</span><br><span class="line">write_barrier();</span><br></pre></td></tr></table></figure>

<p>为了得到头部的索引，应用程序需要使用环形缓冲区的大小掩码来掩码头部。请记住，<br>上面代码中的任何一行都可能在上下文切换之后运行。因此，在比较之前，<br>我们有一个 <strong><code>read_barrier()</code></strong> ，这样，如果内核确实更新了尾部，<br>我们可以在 if 语句中将其作为比较的一部分来读取。一旦我们获得了 CQE 并处理它，<br>我们就更新 head，让内核知道我们已经使用了来自 ring 缓冲区的条目。最后一个 **<code>write_barrier()</code>**确保我们的写操作可见，这样内核就可以知道它。</p>
<h2 id="提交-submission"><a href="#提交-submission" class="headerlink" title="提交 submission"></a>提交 submission</h2><p>做一个提交和读取一个完成是相反的。在处理 completion 时，内核将条目添加到尾部，<br>我们从循环缓冲区的头部读取条目，当 submission 时，我们添加到尾部，内核从循环缓冲区的头部读取条目。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"><span class="type">unsigned</span> tail, index;</span><br><span class="line">tail = sqring-&gt;tail;</span><br><span class="line">index = tail &amp; (*sqring-&gt;ring_mask);</span><br><span class="line">sqe = &amp;sqring-&gt;sqes[index];</span><br><span class="line"><span class="comment">/* 此函数调用填写此IO请求的SQE详细信息 */</span></span><br><span class="line">app_init_io(sqe);</span><br><span class="line"><span class="comment">/* 将SQE索引填充到SQ环数组中 */</span></span><br><span class="line">sqring-&gt;<span class="built_in">array</span>[index] = index;</span><br><span class="line">tail++;</span><br><span class="line">write_barrier();</span><br><span class="line">sqring-&gt;tail = tail;</span><br><span class="line">write_barrier();</span><br></pre></td></tr></table></figure>

<p>在上面的代码片段中，应用程序中的 <strong><code>app_init_io()</code></strong> 函数将填充提交请求的详细信息。在尾部更新之前，<br>我们有一个 <strong><code>write_barrier()</code></strong> 来确保前面的写操作是有序的。然后我们更新 tail 并再次调用 <strong><code>write_barrier()</code></strong> 以确保我们的更新被看到。我们在这里按照正确的顺序处理。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>本文档中的代码和其他示例可以在这个 <a target="_blank" rel="noopener" href="https://github.com/shuveb/loti-examples">Github</a> 存储库中找到。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://unixism.net/loti/low_level.html">The Low-level io_uring Interface</a></li>
<li><a target="_blank" rel="noopener" href="https://kernel.dk/io_uring.pdf">Efficient IO with io_uring PDF</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/axboe/liburing">Efficient IO with io_uring github</a></li>
</ul>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../tutorial/2021-02-07-cat_liburing/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../2021-02-07-what_is_io_uring/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
