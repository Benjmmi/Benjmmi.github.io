<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>3. eBPF 工具链 [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">3. eBPF 工具链</h1>
<article class="post markdown-style">
  <h1 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h1><hr>
<p>本节介绍 BPF 相关的用户态工具、内省设施（introspection facilities）和内核控制选项。 注意，围绕 BPF 的工具和基础设施还在快速发展当中，因此本文提供的内容可能只覆 盖了其中一部分。</p>
<h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt-get install -y make gcc libssl-dev bc libelf-dev libcap-dev \</span><br><span class="line">  clang gcc-multilib llvm libncurses5-dev git pkg-config libmnl-dev bison flex \</span><br><span class="line">  graphviz</span><br></pre></td></tr></table></figure>

<h1 id="2-2-LLVM"><a href="#2-2-LLVM" class="headerlink" title="2.2 LLVM"></a>2.2 LLVM</h1><p>写作本文时，LLVM 是唯一提供 BPF 后端的编译器套件。gcc 目前还不支持。</p>
<p>主流的发行版在对 LLVM 打包的时候就默认启用了 BPF 后端，因此，在大部分发行版上安 装 clang 和 llvm 就可以将 C 代码编译为 BPF 对象文件了。</p>
<p>典型的工作流是：</p>
<ol>
<li>用 C 编写 BPF 程序</li>
<li>用 LLVM 将 C 程序编译成对象文件（ELF）</li>
<li>用户空间 BPF ELF 加载器（例如 iproute2）解析对象文件</li>
<li>加载器通过 bpf() 系统调用将解析后的对象文件注入内核</li>
<li>内核验证 BPF 指令，然后对其执行即时编译（JIT），返回程序的一个新文件描述符</li>
<li>利用文件描述符 attach 到内核子系统（例如网络子系统）</li>
</ol>
<p>某些子系统还支持将 BPF 程序 offload 到硬件（例如网卡）。</p>
<h2 id="2-2-1-BPF-Target（目标平台）"><a href="#2-2-1-BPF-Target（目标平台）" class="headerlink" title="2.2.1 BPF Target（目标平台）"></a>2.2.1 BPF Target（目标平台）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ llc --version</span><br><span class="line">LLVM (http://llvm.org/):</span><br><span class="line">LLVM version 3.8.1</span><br><span class="line">Optimized build.</span><br><span class="line">Default target: x86_64-unknown-linux-gnu</span><br><span class="line">Host CPU: skylake</span><br><span class="line"></span><br><span class="line">Registered Targets:</span><br><span class="line">  [...]</span><br><span class="line">  bpf        - BPF (host endian)</span><br><span class="line">  bpfeb      - BPF (big endian)</span><br><span class="line">  bpfel      - BPF (little endian)</span><br><span class="line">  [...]</span><br></pre></td></tr></table></figure>

<p><strong>默认情况下，bpf target 使用编译时所在的 CPU 的大小端格式</strong> ，即，如果 CPU 是小 端，BPF 程序就会用小端表示；如果 CPU 是大端，BPF 程序就是大端。这也和 BPF 的运 行时行为相匹配，这样的行为比较通用，而且大小端格式一致可以避免一些因为格式导致的 架构劣势。</p>
<p>BPF 程序可以在大端节点上编译，在小端节点上运行，或者相反，因此对于 <strong>交叉编译</strong> ， 引入了两个新目标 <code>bpfeb</code> 和 <code>bpfel</code>。注意前端也需要以相应的大小端方式运行。</p>
<p>在不存在大小端混用的场景下，建议使用 bpf target。例如，在 x86_64 平台上（小端 ），指定 bpf 和 bpfel 会产生相同的结果，因此触发编译的脚本不需要感知到大小端 。</p>
<p>下面是一个最小的完整 XDP 程序，实现丢弃包的功能（xdp-example.c）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __section(NAME)                  \</span></span><br><span class="line"><span class="meta">   __attribute__((section(NAME), used))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">__section(<span class="string">&quot;prog&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">xdp_drop</span><span class="params">(<span class="keyword">struct</span> xdp_md *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> __license[] __section(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>用下面的命令编译并加载到内核：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -Wall -target bpf -c xdp-example.c -o xdp-example.o</span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> dev em1 xdp obj xdp-example.o</span><br></pre></td></tr></table></figure>

<pre><code># 注意
以上命令将一个 XDP 程序 attach 到一个网络设备，需要是 Linux 4.11 内核中支持 XDP 的设备，或者 4.12+ 版本的内核。
</code></pre>
<p>LLVM（&gt;&#x3D; 3.9） 使用正式的 BPF 机器值（machine value），即 EM_BPF（十进制 247 ，十六进制 0xf7），来生成对象文件。在这个例子中，程序是用 bpf target 在 x86_64 平台上编译的，因此下面显示的大小端标识是 LSB (和 MSB 相反)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file xdp-example.o</span><br><span class="line">xdp-example.o: ELF 64-bit LSB relocatable, *unknown <span class="built_in">arch</span> 0xf7* version 1 (SYSV), not stripped</span><br></pre></td></tr></table></figure>
<p><code>readelf -a xdp-example.o</code> 能够打印 ELF 文件的更详细信息，有时在检查生成的 section header、relocation entries 和符号表时会比较有用。</p>
<hr>
<h1 id="2-2-2-调试信息（DWARF、BTF）"><a href="#2-2-2-调试信息（DWARF、BTF）" class="headerlink" title="2.2.2 调试信息（DWARF、BTF）"></a>2.2.2 调试信息（<a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a>、BTF）</h1><p>若是要 debug，clang 可以生成下面这样的汇编器输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -S -Wall -target bpf -c xdp-example.c -o xdp-example.S</span><br><span class="line">$ <span class="built_in">cat</span> xdp-example.S</span><br><span class="line">    .text</span><br><span class="line">    .section    prog,<span class="string">&quot;ax&quot;</span>,@progbits</span><br><span class="line">    .globl      xdp_drop</span><br><span class="line">    .p2align    3</span><br><span class="line">xdp_drop:                             <span class="comment"># @xdp_drop</span></span><br><span class="line"><span class="comment"># BB#0:</span></span><br><span class="line">    r0 = 1</span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">    .section    license,<span class="string">&quot;aw&quot;</span>,@progbits</span><br><span class="line">    .globl    __license               <span class="comment"># @__license</span></span><br><span class="line">__license:</span><br><span class="line">    .asciz    <span class="string">&quot;GPL&quot;</span></span><br></pre></td></tr></table></figure>

<p>LLVM 从 6.0 开始，还包括了汇编解析器（assembler parser）的支持。你可以直接使用 BPF 汇编指令编程，然后使用 llvm-mc 将其汇编成一个目标文件。例如，你可以将前面 的 xdp-example.S 重新变回对象文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ llvm-mc -triple bpf -filetype=obj -o xdp-example.o xdp-example.S</span><br></pre></td></tr></table></figure>

<h1 id="DWARF-格式和-llvm-objdump"><a href="#DWARF-格式和-llvm-objdump" class="headerlink" title="DWARF 格式和 llvm-objdump"></a><a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 格式和 llvm-objdump</h1><p>另外，较新版本（&gt;&#x3D; 4.0）的 LLVM 还可以将调试信息以 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a> 格式存储到对象文件中。 只要在编译时加上 -g：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -g -Wall -target bpf -c xdp-example.c -o xdp-example.o</span><br><span class="line">$ llvm-objdump -S -no-show-raw-insn xdp-example.o</span><br><span class="line"></span><br><span class="line">xdp-example.o:        file format ELF64-BPF</span><br><span class="line"></span><br><span class="line">Disassembly of section prog:</span><br><span class="line">xdp_drop:</span><br><span class="line">; &#123;</span><br><span class="line">    0:        r0 = 1</span><br><span class="line">; <span class="built_in">return</span> XDP_DROP;</span><br><span class="line">    1:        <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>llvm-objdump 工具能够用编译的 C 源码对汇编输出添加注解（annotate ）。这里 的例子过于简单，没有几行 C 代码；但注意上面的 0 和 1 行号，这些行号直接对 应到内核的校验器日志（见下面的输出）。这意味着假如 BPF 程序被校验器拒绝了， llvm-objdump能帮助你将 BPF 指令关联到原始的 C 代码，对于分析来说非常有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> dev em1 xdp obj xdp-example.o verb</span><br><span class="line"></span><br><span class="line">Prog section <span class="string">&#x27;prog&#x27;</span> loaded (5)!</span><br><span class="line"> - Type:         6</span><br><span class="line"> - Instructions: 2 (0 over <span class="built_in">limit</span>)</span><br><span class="line"> - License:      GPL</span><br><span class="line"></span><br><span class="line">Verifier analysis:</span><br><span class="line"></span><br><span class="line">0: (b7) r0 = 1</span><br><span class="line">1: (95) <span class="built_in">exit</span></span><br><span class="line">processed 2 insns</span><br></pre></td></tr></table></figure>

<p>从上面的校验器分析可以看出，llvm-objdump 的输出和内核中的 BPF 汇编是相同的。</p>
<p>去掉 -no-show-raw-insn 选项还可以以十六进制格式在每行汇编代码前面打印原始的 struct bpf_insn：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ llvm-objdump -S xdp-example.o</span><br><span class="line"></span><br><span class="line">xdp-example.o:        file format ELF64-BPF</span><br><span class="line"></span><br><span class="line">Disassembly of section prog:</span><br><span class="line">xdp_drop:</span><br><span class="line">; &#123;</span><br><span class="line">   0:       b7 00 00 00 01 00 00 00     r0 = 1</span><br><span class="line">; <span class="built_in">return</span> foo();</span><br><span class="line">   1:       95 00 00 00 00 00 00 00     <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h3 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h3><p>对于 LLVM IR 调试，BPF 的编译过程可以分为两个步骤：首先生成一个二进制 LLVM IR 临 时文件 xdp-example.bc，然后将其传递给 <code>llc</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -Wall -target bpf -emit-llvm -c xdp-example.c -o xdp-example.bc</span><br><span class="line">$ llc xdp-example.bc -march=bpf -filetype=obj -o xdp-example.o</span><br></pre></td></tr></table></figure>

<p>生成的 LLVM IR 还可以 dump 成人类可读的格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -Wall -emit-llvm -S -c xdp-example.c -o -</span><br></pre></td></tr></table></figure>

<h2 id="BTF"><a href="#BTF" class="headerlink" title="BTF"></a>BTF</h2><p>LLVM 能将调试信息（例如对程序使用的数据的描述）attach 到 BPF 对象文件。默认情况 下使用 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 格式。</p>
<p>BPF 使用了一个高度简化的版本，称为 <strong>BTF</strong> (BPF Type Format)。生成的 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 可以 转换成 BTF 格式，然后通过 BPF 对象加载器加载到内核。内核验证 BTF 数据的正确性， 并跟踪 BTF 数据中包含的数据类型。</p>
<p>这样的话，就可以用键和值对 BPF map 打一些注解（annotation）存储到 BTF 数据中，这 样下次 dump map 时，除了 map 内的数据外还会打印出相关的类型信息。这对内省（ introspection）、调试和格式良好的打印都很有帮助。注意，BTF 是一种通用的调试数据 格式，因此任何从 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 转换成的 BTF 数据都可以被加载（例如，内核 vmlinux <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 数 据可以转换成 BTF 然后加载）。后者对于未来 BPF 的跟踪尤其有用。</p>
<p>将 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 格式的调试信息转换成 BTF 格式需要用到 <code>elfutils</code> (&gt;&#x3D; 0.173) 工具。 如果没有这个工具，那需要在 <code>llc</code> 编译时打开 <code>-mattr=[dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction)ris</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ llc -march=bpf -mattr=<span class="built_in">help</span> |&amp; grep [dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction)ris</span><br><span class="line">[dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction)ris - Disable MCAsmInfo [Dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction)UsesRelocationsAcrossSections.</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>使用 -mattr&#x3D;<a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris 是因为 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris (<a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a> relocation in section) 选项禁 用了 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 和 ELF 的符号表之间的 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> cross-section 重定位，因为 libdw 不支持 BPF 重定位。不打开这个选项的话，pahole 这类工具将无法正确地从对象中 dump 结构。</p>
<p>elfutils (&gt;&#x3D; 0.173) 实现了合适的 BPF 重定位，因此没有打开 -mattr&#x3D;<a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris 选 项也能正常工作。它可以从对象文件中的 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 或 BTF 信息 dump 结构。目前 pahole 使用 LLVM 生成的 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 信息，但未来它可能会使用 BTF 信息。</p>
<h2 id="pahole-注：pahole-一种代码审计工具"><a href="#pahole-注：pahole-一种代码审计工具" class="headerlink" title="pahole (注：pahole 一种代码审计工具)"></a>pahole (注：pahole 一种代码审计工具)</h2><p>将 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 转换成 BTF 格式需要使用较新的 pahole 版本（&gt;&#x3D; 1.12），然后指定 -J 选项。 检查所用的 pahole 版本是否支持 BTF（注意，pahole 会用到 llvm-objcopy，因此 也要检查后者是否已安装）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pahole --<span class="built_in">help</span> | grep BTF</span><br><span class="line">-J, --btf_encode           Encode as BTF</span><br></pre></td></tr></table></figure>

<p>生成调试信息还需要前端的支持，在 clang 编译时指定 -g 选项，生成源码级别的调 试信息。注意，不管 llc 是否指定了 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris 选项，-g 都是需要指定的。生成目 标文件的完整示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -g -Wall -target bpf -emit-llvm -c xdp-example.c -o xdp-example.bc</span><br><span class="line">$ llc xdp-example.bc -march=bpf -mattr=[dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction)ris -filetype=obj -o xdp-example.o</span><br></pre></td></tr></table></figure>

<p>或者，只使用 clang 这一个工具来编译带调试信息的 BPF 程序（同样，如果有合适的 elfutils 版本，<a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris 选项可以省略）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -target bpf -O2 -g -c -Xclang -target-feature -Xclang +[dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction)ris -c xdp-example.c -o xdp-example.o</span><br></pre></td></tr></table></figure>

<p>基于 <a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 信息 dump BPF 程序的数据结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pahole xdp-example.o</span><br><span class="line">struct xdp_md &#123;</span><br><span class="line">        __u32                      data;                 /*     0     4 */</span><br><span class="line">        __u32                      data_end;             /*     4     4 */</span><br><span class="line">        __u32                      data_meta;            /*     8     4 */</span><br><span class="line"></span><br><span class="line">        /* size: 12, cachelines: 1, members: 3 */</span><br><span class="line">        /* last cacheline: 12 bytes */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在对象文件中，<a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 数据将仍然伴随着新加入的 BTF 数据一起保留。完整的 clang 和 pahole 示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -target bpf -O2 -Wall -g -c -Xclang -target-feature -Xclang +[dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction)ris -c xdp-example.c -o xdp-example.o</span><br><span class="line">$ pahole -J xdp-example.o</span><br></pre></td></tr></table></figure>

<h2 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h2><p>通过 readelf 工具可以看到多了一个 .BTF section：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -a xdp-example.o</span><br><span class="line">[...]</span><br><span class="line">  [18] .BTF              PROGBITS         0000000000000000  00000671</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>BPF 加载器（例如 iproute2）会检测和加载 BTF section，因此给 BPF map 注释（ annotate）类型信息。</p>
<h3 id="2-2-3-BPF-指令集"><a href="#2-2-3-BPF-指令集" class="headerlink" title="2.2.3 BPF 指令集"></a>2.2.3 BPF 指令集</h3><pre><code>根据不同的 CPU 生成不同的汇编指令，用于编译和执行
</code></pre>
<p>LLVM 默认用 BPF 基础指令集（base instruction set）来生成代码，以确保这些生成的对<br>象文件也能够被稍老的 LTS 内核（例如 4.9+）加载。</p>
<p>但是，LLVM 提供了一个 BPF 后端选项 <code>-mcpu</code>，可以指定不同版本的 BPF 指令集，即<br>BPF 基础指令集之上的指令集扩展（instruction set extensions），以生成更高效和体积<br>更小的代码。</p>
<p>可用的 <code>-mcpu</code> 类型：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">llc -march bpf -mcpu=<span class="built_in">help</span></span></span><br><span class="line">Available CPUs for this target:</span><br><span class="line"></span><br><span class="line">  generic - Select the generic processor.</span><br><span class="line">  probe   - Select the probe processor.</span><br><span class="line">  v1      - Select the v1 processor.</span><br><span class="line">  v2      - Select the v2 processor.</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>generic</code> processor 是默认的 processor，也是 BPF <code>v1</code> 基础指令集。</li>
<li><code>v1</code> 和 <code>v2</code> processor 通常在交叉编译 BPF 的环境下比较有用，即编译 BPF 的平台<br>和最终执行 BPF 的平台不同（因此 BPF 内核特性可能也会不同）。</li>
</ul>
<p><strong>推荐使用 <code>-mcpu=probe</code> ，这也是 Cilium 内部在使用的类型</strong>。使用这种类型时，<br>LLVM BPF 后端会向内核询问可用的 BPF 指令集扩展，如果找到可用的，就会使用相应的指<br>令集来编译 BPF 程序。</p>
<p>使用 <code>llc</code> 和 <code>-mcpu=probe</code> 的完整示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang -O2 -Wall -target bpf -emit-llvm -c xdp-example.c -o xdp-example.bc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">llc xdp-example.bc -march=bpf -mcpu=probe -filetype=obj -o xdp-example.o</span></span><br></pre></td></tr></table></figure>

<p><a name="ch_2.2.4"></a></p>
<h3 id="2-2-4-指令和寄存器位宽（64-32-位）"><a href="#2-2-4-指令和寄存器位宽（64-32-位）" class="headerlink" title="2.2.4 指令和寄存器位宽（64&#x2F;32 位）"></a>2.2.4 指令和寄存器位宽（64&#x2F;32 位）</h3><p>通常来说，LLVM IR 生成是架构无关的。但使用 <code>clang</code> 编译时是否指定 <code>-target bpf</code><br>是有几点小区别的，取决于不同的平台架构（<code>x86_64</code>、<code>arm64</code> 或其他），<code>-target</code> 的<br>默认配置可能不同。</p>
<p>引用内核文档 <code>Documentation/bpf/bpf_devel_QA.txt</code>：</p>
<ul>
<li><p>BPF 程序可以嵌套 include 头文件，只要头文件中都是文件作用域的内联汇编代码（<br>file scope inline assembly codes）。大部分情况下默认 target 都可以处理这种情况，<br>但如果 BPF 后端汇编器无法理解这些汇编代码，那 <code>bpf</code> target 会失败。</p>
</li>
<li><p>如果编译时没有指定 <code>-g</code>，那额外的 elf sections（例如 <code>.eh_frame</code><br>和 <code>.rela.eh_frame</code>）可能会以默认 target 格式出现在对象文件中，但不会是 <code>bpf</code><br>target。</p>
</li>
<li><p>默认 target 可能会将一个 C <code>switch</code> 声明转换为一个 <code>switch</code> 表的查找和跳转操作。<br>由于 switch 表位于全局的只读 section，因此 BPF 程序的加载会失败。 <code>bpf</code> target<br>不支持 switch 表优化。clang 的 <code>-fno-jump-tables</code> 选项可以禁止生成 switch 表。</p>
</li>
<li><p>如果 clang 指定了 <code>-target bpf</code>，那指针或 <code>long</code>&#x2F;<code>unsigned long</code> 类型将永远<br>是 64 位的，不管底层的 clang 可执行文件或默认的 target（或内核）是否是 32<br>位。但如果使用的是 native clang target，那 clang 就会根据底层的架构约定（<br>architecture’s conventions）来编译这些类型，这意味着对于 32 位的架构，BPF 上下<br>文中的指针或 <code>long</code>&#x2F;<code>unsigned long</code> 类型会是 32 位的，但此时的 BPF LLVM 后端仍<br>然工作在 64 位模式。</p>
</li>
</ul>
<p><code>native</code> target 主要用于跟踪（tracing）内核中的 <code>struct pt_regs</code>，这个结构体对<br>CPU 寄存器进行映射，或者是跟踪其他一些能感知 CPU 寄存器位宽（CPU’s register<br>width）的内核结构体。除此之外的其他场景，例如网络场景，都建议使用 <code>clang -target bpf</code>。</p>
<p>另外，LLVM 从 7.0 开始支持 32 位子寄存器和 BPF ALU32 指令。另外，新加入了一个代<br>码生成属性 <code>alu32</code>。当指定这个参数时，LLVM 会尝试尽可能地使用 32 位子寄存器，例<br>如当涉及到 32 位操作时。32 位子寄存器及相应的 ALU 指令组成了 ALU32 指令。例如，<br>对于下面的示例代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> 32-bit-example.c</span></span><br><span class="line">void cal(unsigned int *a, unsigned int *b, unsigned int *c)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int sum = *a + *b;</span><br><span class="line">  *c = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用默认的代码生成选项，产生的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ clang -target bpf -emit-llvm -S 32-bit-example.c</span><br><span class="line">$ llc -march=bpf 32-bit-example.ll</span><br><span class="line">$ cat 32-bit-example.s</span><br><span class="line">cal:</span><br><span class="line">  r1 = *(u32 *)(r1 + 0)</span><br><span class="line">  r2 = *(u32 *)(r2 + 0)</span><br><span class="line">  r2 += r1</span><br><span class="line">  *(u32 *)(r3 + 0) = r2</span><br><span class="line">  exit</span><br></pre></td></tr></table></figure>

<p>可以看到默认使用的是 <code>r</code> 系列寄存器，这些都是 64 位寄存器，这意味着其中的加法都<br>是 64 位加法。现在，如果指定 <code>-mattr=+alu32</code> 强制要求使用 32 位，生成的汇编代码<br>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ llc -march=bpf -mattr=+alu32 32-bit-example.ll</span><br><span class="line">$ cat 32-bit-example.s</span><br><span class="line">cal:</span><br><span class="line">  w1 = *(u32 *)(r1 + 0)</span><br><span class="line">  w2 = *(u32 *)(r2 + 0)</span><br><span class="line">  w2 += w1</span><br><span class="line">  *(u32 *)(r3 + 0) = w2</span><br><span class="line">  exit</span><br></pre></td></tr></table></figure>

<p>可以看到这次使用的是 <code>w</code> 系列寄存器，这些是 32 位子寄存器。</p>
<p>使用 32 位子寄存器可能会减小（最终生成的代码中）<strong>类型扩展指令</strong>（type extension<br>instruction）的数量。另外，它对 32 位架构的内核 eBPF JIT 编译器也有所帮助，因为<br>原来这些编译器都是用 32 位模拟 64 位 eBPF 寄存器，其中使用了很多 32 位指令来操作<br>高 32 bit。即使写 32 位子寄存器的操作仍然需要对高 32 位清零，但只要确保从 32 位<br>子寄存器的读操作只会读取低 32 位，那只要 JIT 编译器已经知道某个寄存器的定义只有<br>子寄存器读操作，那对高 32 位的操作指令就可以避免。</p>
<h1 id="文档连接"><a href="#文档连接" class="headerlink" title="文档连接"></a>文档连接</h1><p><a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/2019/12/10/5dee76b007da0/">Linux BPF 3.2、BPF and XDP Reference Guide</a><br><a target="_blank" rel="noopener" href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">[译] Cilium：BPF 和 XDP 参考指南（2019）</a><br><a target="_blank" rel="noopener" href="https://docs.cilium.io/en/stable/bpf/">BPF and XDP Reference Guide</a><br><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">BPF 辅助函数</a><br><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/bpf.2.html">BPF man 文档</a></p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../2021-02-24-C_Programs_For_eBPF/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../../../22/ebpf/2021-02-22-eBPF-translate/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
