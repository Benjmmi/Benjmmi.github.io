<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>Raft 实现 [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">Raft 实现</h1>
<article class="post markdown-style">
  <p>Raft 实现的三个核心模块</p>
<ol>
<li>通信</li>
<li>共识算法</li>
<li>持久化存储</li>
</ol>
<p>持久化存储可以暂时方式。满足一般通信即可，主要还是一致性算法。<br>一致性算法涉及到数据结构的定义。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这个课程包括一系列实验，目标是开发一个容错的KV系统，本实验是其中的第一个。在这个实验里，要求你实现Raft，它是一个复制状态机。在后续的实验中，会要求你在这个Raft的基础上开发一个KV服务。这个服务会把请求打散（Shard）到多个复制状态机上去处理，以提高性能。</p>
<p>复制服务能做到容错的方法是：把多份完整拷贝存放到多个副本服务器上。复制使得这个KV服务在多个服务器故障的情况下（崩溃了、坏了或者网络掉线了）也能正常工作。难点在于，故障可能导致不同服务器上存储的数据副本也是不同的。</p>
<p>Raft把客户端的请求组织成一个序列，叫做日志，并且确保所有副本服务器看到的日志都是相同的。每个副本服务器都按顺序执行这些客户端请求，并且把这些请求应用到自己的服务状态机的本地副本上。因为所有的活着的服务器都有相同的日志内容，并且它们以相同的顺序运行相同的日志，所以他们的状态也就是相同的。如果一个节点故障了，然后又恢复了，Raft负责把它的日志重新带到最新的状态。只要集群里面多数（超过半数）节点正常工作，并且相互之间能够正常通信，那么Raft就可以正常工作。一旦多数节点都不能正常工作了，那么Raft也就停止工作了，只要集群多数节点又恢复正常了，Raft就能立即从上次它停止的状态中恢复过来。</p>
<p>在这个实验中，要求你把Raft实现成一个go的Object类型，并且带有关联的方法，也就是说，这个raft可以作为一个模块用在另外一个更大的服务中。一个Raft实例用RPC相互通信来共同维护日志。你的raft接口应该支持未确定的待编号命令序列，也就是所说的日志条目。这些条目都用index number进行编号。带有特定index的条目最终都会被提交。在这个时刻，你实现的raft服务应该把这个日志条目发送给更大的服务去执行。</p>
<p>你应该按照raft论文（<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">raft-extended.pdf</a>）里面描述的设计去实现，特别是要注意论文中的图2，包括：持久化保存状态、节点故障重启之后读入这些状态。你不需要实现集群成员变更（Section6里面内容）。</p>
<p>这个指导书（<a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/">students-guide-to-raft&#x2F;</a>）里面的内容可能对你有用，也包括这些关于锁（<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt">raft-locking.txt</a>）和<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt">并发结构</a> 的建议。从拓宽知识面的角度说，浏览一下Paxos，Chubby，PaxosMade Live，Spanner，Zookeeper，Harp，Viewstamped Replication，以及Bolosky et al (<a target="_blank" rel="noopener" href="http://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf">Bolosky.pdf</a>都是有好处的。（注意：这个学生指导书是很多年之前写的了，其中2D部分现在已经有些变化了，你自己要思考为这些特殊的实现策略的意义是什么，不要盲从）。</p>
<p>一个raft模块和其他部分的交互图<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf">https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf</a>，可以帮助你理解raft模块与其他部分是如何交互的。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>如果你完成了实验1，那么你应该有一份实验的源码了。如果你没完成，那么你可以用这里面的命令（<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">lab-mr.html</a>）去下载这些代码。</p>
<p>我们给你提供了一些代码框架（src&#x2F;raft&#x2F;raft.go）。我们也提供一个测试集，你应该用它驱动你自己实现raft。我们也会用这个测试集给你的实验作业打分。测试代码在&#x2F;src&#x2F;raft&#x2F;test_test.go里面。</p>
<p>用下面命令开始运行。不要忘了用get pull下载最新的软件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/6.824</span><br><span class="line">$ git pull</span><br><span class="line">...</span><br><span class="line">$ <span class="built_in">cd</span> src/raft</span><br><span class="line">$ go <span class="built_in">test</span> -race</span><br><span class="line">Test (2A): initial election ...</span><br><span class="line">--- FAIL: TestInitialElection2A (5.04s)</span><br><span class="line">        config.go:326: expected one leader, got none</span><br><span class="line">Test (2A): election after network failure ...</span><br><span class="line">--- FAIL: TestReElection2A (5.03s)</span><br><span class="line">        config.go:326: expected one leader, got none</span><br><span class="line">...</span><br><span class="line">$</span><br></pre></td></tr></table></figure>


<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>你实现的raft代码添加到raft&#x2F;raft.go里面。在这个文件里面，有一些框架代码，以及一些给你展示如何发送和接收RPC的例子代码。</p>
<p>你的实现必须支持下面这些接口，测试代码和以后你要实现的kev&#x2F;value服务都会用到这些接口。在raft.go里面还有很多有用的注释，就像下面这样。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a new Raft server instance:</span></span><br><span class="line">rf := Make(peers, me, persister, applyCh)</span><br><span class="line"></span><br><span class="line"><span class="comment">// start agreement on a new log entry:</span></span><br><span class="line">rf.Start(command <span class="keyword">interface</span>&#123;&#125;) (index, term, isleader)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ask a Raft for its current term, and whether it thinks it is leader</span></span><br><span class="line">rf.GetState() (term, isLeader)</span><br><span class="line"></span><br><span class="line"><span class="comment">// each time a new entry is committed to the log, each Raft peer</span></span><br><span class="line"><span class="comment">// should send an ApplyMsg to the service (or tester).</span></span><br><span class="line"><span class="keyword">type</span> ApplyMsg</span><br></pre></td></tr></table></figure>

<p>服务调用Make(peers, me, …)来产生一个Raft peer。这个参数peers就是一些Raft peers的网络标识符，RPC用这些标识符。这个参数me是本peer在这个peers数组中的index。Start(command)请求Raft开始一个把命令追加到replicated log中的处理流程。Start()应该立刻返回，不能等到日志追加完毕才返回。服务希望你代码在日志条目提交的时候，给applyCh发送ApplyMsg，每个新提交的日志条目都要发，applyCh是在调用Make()函数时传入的一个参数。</p>
<p>Raft.go有发送RPC的例子代码（sendRequestVote()），以及处理收到的RPC的例子代码（RequestVote()）。你的Raft peers应该用Go语言包labrpc来收发RPC消息。测试代码会控制librpc来对RPC消息人为地制造时延、乱序、丢包等问题来模拟网络故障。你也可以临时修改labrpc，但是你要保证你的代码能够跟原始的labrpc一起正常工作，因为我们要用这个给你的作业打分。你的raft实例之间只能用RPC进行交互，比如，不允许他们之间用共享变量或者文件来交互。</p>
<p>这个课程后面的这些实验都是在这个实验基础上开展的，所以，多花点时间，把代码写的健壮一点，是很重要的。</p>
<h1 id="实验2A：领导选举"><a href="#实验2A：领导选举" class="headerlink" title="实验2A：领导选举"></a>实验2A：领导选举</h1><p><em><strong>任务：实现 Raft 的领导选举和心跳（不带日志条目的 AppendEntries RPC 消息）。实验 2 A 的目标是：如果没有故障，那么领导就一直</strong></em><br><em><strong>是领导。如果发送故障，那么新领导就要接管（集群），这里说的故障，可能是老领导死机或者丢包导致联系不上。运行 <code>go test -run 2a -race</code></strong></em><br><em><strong>来测试你的 2A 代码</strong></em></p>
<ul>
<li><p>提示：没办法很容易地直接运行Raft实现，你应该用测试框架去运行：go test -run 2A -race。</p>
</li>
<li><p>提示：仔细读Raft论文上的图2。现在这个时间点，你需要关心发送和接收RequestVote RPC消息，跟选举相关的一些服务器规则，以及跟选举相关的领导者规则。</p>
</li>
<li><p>提示：把图2中的一些领导者选举状态添加到raft.go文件的Raft结构中。另外，还需要定义一个结构去保存每个日志条目的信息。</p>
</li>
<li><p>提示：填充RequestVoteArgs和RequestVoteReply这两个结构。修改Make()这个函数，创建一个后台goroutine，如果长时间没有收到其他peer的消息，这个goroutine就会发送RequestVote RPCs消息，周期性的启动leader选举。如果已经存在一个领导者，或者它自己成了领导者，通过这种方法(周期性发送消息)，让peer知道谁是领导者。实现RequestVote()这个RPC处理函数，这样服务器节点之间就会相互投票。</p>
</li>
<li><p>提示：实现心跳，定义AppendEntries的RPC结构（尽管现在可能还不需要所有参数），并且让Leader周期性的发送这个AppendEntries RPC消息。写AppendEntries RPC消息的处理函数，在这个函数中，对选举超时变量进行清零，这样一旦选出一个领导者之后，其他节点就不会再继续尝试成为领导者了。</p>
</li>
<li><p>提示：确保不同的peers的超时时间不一样，要不然所有peer都会投票给他们自己，这样就选不出来领导者了。</p>
</li>
<li><p>提示：测试框架要求领导者发送心跳RPC消息的频率不超过10次&#x2F;秒。</p>
</li>
<li><p>提示：测试框架要求你的Raft实现应该在老领导者故障后的5秒钟之内选出新领导者（假设多数peers之间可以相互通信）。注意，选举可能会有多轮，因为可能会有多个候选人平分选票的情况（可能是报文丢失导致的，也可能是两个候选人使用了相同的回退时间）。你必须定一个足够短的选举的超时时间（以及heartbeat的间隔），尽量在5秒钟之内能够完成选举，即便经历多轮选举也应该能完成。</p>
</li>
<li><p>提示：在Raft论文的5.2节提到，选举超时时间在150ms到300ms之间，这个超时值只在领导者发送心跳的间隔远远小于150ms的情况下才有意义。因为测试框架把心跳频率现在小于10次&#x2F;1秒，这样你就必须把选举间隔设置为大于论文中给出的150到300ms，但是也不能太长，否则5秒钟之内无法完成选举。</p>
</li>
<li><p>提示：你需要用go语言的rand函数（<a target="_blank" rel="noopener" href="https://golang.org/pkg/math/rand/%EF%BC%89%E3%80%82">https://golang.org/pkg/math/rand/）。</a></p>
</li>
<li><p>提示：当你要写一个周期性的处理函数，或者需要延时一段时间再处理，那么最方便的实现方法就是创建一个goroutine，里面一个大循环，循环里面调用time.Sleep()。（参见Make()里面创建的ticker() goroutine就是这个目的）。不要用Go的time.Timer或者time.Ticker，想把这俩货用对很难。</p>
</li>
<li><p>提示：指导书<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/guidance.html">https://pdos.csail.mit.edu/6.824/labs/guidance.html</a>里面有一些怎么开发，怎么调试代码的建议。</p>
</li>
<li><p>提示：如果你的代码无法通过测试，那么建议你再回头仔细看论文里面的图2。整个领导者选举的逻辑散落在这个图里面的各个角落。（需要仔细看）</p>
</li>
<li><p>提示：别忘了实现GetState()这个函数。</p>
</li>
<li><p>提示：测试框架要永久终止某个raft实例的时候，会调用rf.Kill()这个函数。你调用rf.killed()来检查Kill（）是否已经被调用了。你应该在所有的循环中都调用rf.killed()来检查，避免那些已经死掉的raft实例还继续输出迷惑性的打印信息。</p>
</li>
<li><p>提示：Go的RPC只能发送struct中名字是大写字母的字段，嵌套结构的字段名字也必须是大写的（主要数组中的logrecord）。Labgob包会提示你这一点，不要忽略这些警告信息。</p>
</li>
</ul>
<p>交实验2A的作业之前，确保通过了2A的测试用例，就像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -run 2A -race</span><br><span class="line">Test (2A): initial election ...</span><br><span class="line">  ... Passed --   4.0  3   32    9170    0</span><br><span class="line">Test (2A): election after network failure ...</span><br><span class="line">  ... Passed --   6.1  3   70   13895    0</span><br><span class="line">PASS</span><br><span class="line">ok      raft    10.187s</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>每个”Passed”行都有五个数字，它们是：这个测试用了多少秒，有多少个Raft peers（一般是3个或者5个），这次测试发送了多少个RPC消息，这些RPC消息的总字节数是多少，Raft报告了多少个日志条目被提交了。你的代码实际运行时的数字可能跟上图不一样。你也可以不管这些数字，尽管这些数字可能对排错有用。尽量把每个单独的测试都控制在120秒之内，因为所有实验2、3、4加起来时间不能超过120秒，超时不给分</p>
<h1 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h1><ul>
<li>server 会处在三种状态中的一种：leader、follower 和 candidate</li>
<li>集群中的参与者是被动的</li>
<li><del>Raft 将时间分为任意长度的间隔，每个间隔是一个任期</del></li>
<li>每个任期会由一个连续的整数进行表示，在这个阶段会有一个或者多个候选者参与竞选，</li>
<li>每个任期只会选举出至多一个 leader</li>
<li>每个 server 都用一个变量存储了当前任期,并且这个变量随着时间是单调递增的</li>
<li>当 servers 进行通讯的时候，也会交换当前的任期（心跳）</li>
<li>如果一个 server 存储的任期小于其他机器存储的任期，那么它将更新自己的任期为其它机器传送的最大任期（心跳）</li>
<li>如果一个 server 接受到一个请求，这个请求中的任期是过时的，它将直接拒绝该请求（小于任期，问题：没有说是谁发送的心跳）</li>
<li>RequestVote RPCs 是候选在这选举过程中使用的</li>
<li>AppendEntries RPCs 是 leader 进行日志复制和心跳时使用的</li>
</ul>
<ol>
<li>Raft 使用心跳机制来触发选主的过程</li>
<li>leader 会发送心跳到其它的 server 来授权延长自己的任期。（发送心跳的过程中，发现server 返回更大的任期，自动跟随？）</li>
<li>选举定时器超时的时候还没有收到任何请求，它可以假设整个集群没有可用的leader 或者候选者，然后发起新的选举<br>  （投票后，等待下一个超时。超时后还是没有心跳更新，就发起投票）</li>
<li>候选者先选举自己，并行的给集群中的其它机器发送 RequestVote RPCs。（只需要过半以上的票就可以了，自己默认+1）</li>
<li>一个候选者如果接收到集群中大多数机器在同一个任期的选票，它将胜出成为 leader<br>  （先到先得，先到之后直接将当前任期修改为候选任期，后续除非大于当前任期，否则都是反对票，候选人根据投票结果自己判断，然后等待一个心跳周期）</li>
<li>每台机器在一个任期只能投票给一个候选者（先到先得，先到之后直接将当前任期修改为候选任期，后续除非大于当前任期，否则都是反对票）</li>
<li>一旦一个候选者胜出将成为集群的 leader，它将会并行的给集群的其它机器发送心跳来宣示自己胜出，并阻止进行新的选举<br>  （这里是并行，看似困难，其实简单需要归纳法证明，如何阻止）</li>
<li></li>
</ol>
<blockquote>
<p>一个候选者可能接受到来自其它 server 的请求，该请求声明自己已经成为 leader。</p>
</blockquote>
<ol>
<li>如果请求中的 leader 的任期大于候选者本地存储的任期，那么当前候选者认为这个 leader 是合法的并转变为参与者状态。<br>（这里是并行，需要证明，看似简单其实困难需要证明）</li>
<li>如果请求中 leader 的任期小于当前候选者本地存储的任期，那么候选将拒绝这个请求并保持在候选者状态。<br>  （这里是并行，需要证明，看似简单其实困难）</li>
<li>整个集群的所有候选者都没有胜出,等待候选者的选举定时器超时，增加自己本地存储的任期并启动新一轮的选举</li>
<li></li>
</ol>
<p><em><strong>注：来源消息看做完全信任，即永远不会被破坏、出现间谍情况，只会出现乱序、重复、超时、失败的情况</strong></em></p>
<p>方法实现流程：</p>
<h1 id="server-处理心跳"><a href="#server-处理心跳" class="headerlink" title="server 处理心跳"></a>server 处理心跳</h1><p>接收 未知来源（默认是 ） 携带 <code>Term</code>、<code>LeaderId</code> 数据发送的心跳，处理流程如下</p>
<ol>
<li><code>来源.Term</code> 大于等于当前 <code>server</code> 保存的 <code>leader.currentTerm</code> </li>
<li>表示接收到心跳</li>
<li>修改 当前 <code>server</code> 保存的 <code>leader.currentTerm</code> 为 <code>来源.Term</code></li>
<li>修改 当前 <code>server</code> 保存的 <code>leader.LeaderId</code> 为 <code>来源.LeaderId</code></li>
<li>更新最新收到的心跳时间为 <code>NOW</code><br>  解释：</li>
</ol>
<ul>
<li>当前 Server 如果是 Follow<ul>
<li><code>leader.Term</code> 小于 <code>来源.Term</code> ，自动跟随 <code>Term</code> 最新的 <code>Leader</code>。不会关心上次心跳的信息包括 <code>LeaderId</code>、<code>Term</code>，永远追随最新的 <code>Leader</code></li>
<li><code>leader.Term</code> 等于 <code>来源.Term</code><ul>
<li>情况一：当前 <code>Leader</code> 已经持续一段时间，属于正常情况</li>
<li>情况二：当前  <code>来源.Term</code> 为未胜出的 <code>候选人</code>，根据归纳法证明：只有 <code>候选人</code> 在胜出的情况下才可以发送心跳，基于完全相互信任的法则</li>
</ul>
</li>
<li><code>leader.Term</code> 大于 <code>来源.Term</code>，自动拒绝</li>
</ul>
</li>
<li>当前 <code>Server</code> 如果是 <code>候选人</code><ul>
<li><code>候选人</code> 与上面的情况一致，候选人处了身份特殊以外并无特殊情况</li>
</ul>
</li>
</ul>
<h1 id="server-处理拉票"><a href="#server-处理拉票" class="headerlink" title="server 处理拉票"></a>server 处理拉票</h1><p>接收 未知来源（默认是 ） 携带 <code>Term</code>、<code>LeaderId</code> 数据发送的心跳，处理流程如下</p>
<p><strong>选举超时是为了负载均衡？？？？经验证翻译的并准确，英文原版将心跳拦截他们选举超时，表达的意思就是心跳检测时间就是选举超时时间</strong></p>
<p><em><strong>此选举任期将持续到追随者停止接收心跳并成为候选人为止。</strong></em> 好像和之前理解的不一样<br><em><strong>下次心跳都要重新设置随机，下次选举超时也是</strong></em></p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../../../../../../2022/01/08/core/net/2022-01-08-net_rx_action/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../../../../17/microservices/istio/2021-11-17-istio2/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
