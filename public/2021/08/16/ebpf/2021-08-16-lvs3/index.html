<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>LVS  学习： 源码理解修改 [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">LVS  学习： 源码理解修改</h1>
<article class="post markdown-style">
  <h1 id="Hook-点理解"><a href="#Hook-点理解" class="headerlink" title="Hook 点理解"></a>Hook 点理解</h1><p><img src="https://raw.githubusercontent.com/liexusong/linux-source-code-analyze/master/images/netfilter-hooks.png" alt="netfilter-hooks.png"><br>这5个阶段分为：</p>
<ul>
<li>PER_ROUTING：路由前阶段，发生在内核对数据包进行路由判决前。</li>
<li>LOCAL_IN：本地上送阶段，发生在内核通过路由判决后。如果数据包是发送给本机的，那么就把数据包上送到上层协议栈。</li>
<li>FORWARD：转发阶段，发生在内核通过路由判决后。如果数据包不是发送给本机的，那么就把数据包转发出去。</li>
<li>LOCAL_OUT：本地发送阶段，发生在对发送数据包进行路由判决之前。</li>
<li>POST_ROUTING：路由后阶段，发生在对发送数据包进行路由判决之后。</li>
</ul>
<p>在 PER_ROUTING 、 LOCAL_IN 、 FORWARD 之间有个路由 HOOK，这里应该是判断 IP 的走向是否是本机，如果是会发送 LOCAL_IN，如果不是就发送到 FORWARD，<br>所以 PREROUTING 工作在链路层，后 LOCAL_IN 工作在网络层，那么 FORWARD 也应该是在网络层，通过链路层 POST ROUTING 将数据包发送出去。</p>
<p>netfilter 5 个阶段注册钩子函数，内核会在处理数据包时，根据所在的不通阶段来调用这些钩子。注册 hook 通过 <code>nf_register_net_hook</code></p>
<p>梳理了一下，整个 hook 被注册的过程：</p>
<ol>
<li>module_init(ip_vs_init)</li>
<li>ip_vs_init(void) -&gt; ip_vs_register_nl_ioctl()</li>
<li>ip_vs_register_nl_ioctl(void) -&gt; nf_register_sockopt(&amp;ip_vs_sockopts)</li>
<li>nf_register_sockopt(&amp;ip_vs_sockopts) -&gt; ip_vs_sockopts.do_ip_vs_set_ctl</li>
<li>ip_vs_sockopts.do_ip_vs_set_ctl -&gt; ip_vs_add_service(ipvs, &amp;usvc, &amp;svc)</li>
<li>ip_vs_add_service(ipvs, &amp;usvc, &amp;svc) -&gt;  ip_vs_register_hooks(ipvs, u-&gt;af)</li>
<li>ip_vs_register_hooks(ipvs, u-&gt;af) -&gt; nf_register_net_hooks(ipvs-&gt;net, ops, count)</li>
<li>nf_register_net_hooks(ipvs-&gt;net, ops, count) -&gt; nf_register_net_hook(net, &amp;reg[i])</li>
<li>nf_register_net_hook(net, &amp;reg[i]) -&gt; __nf_register_net_hook(net, NFPROTO_IPV4, reg);</li>
</ol>
<p>现在在来看 ipvs 的初始化清晰了不少，但是细节方面还没有了解。最终调用的注册函数的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nf_register_net_hook</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *reg)</span></span><br></pre></td></tr></table></figure>

<p><code>nf_hook_ops</code> 数据结构查看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> &#123;</span></span><br><span class="line">  nf_hookfn   *hook;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">  <span class="type">void</span>      *priv;</span><br><span class="line">  <span class="type">u_int8_t</span>    pf;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>    hooknum;</span><br><span class="line">  <span class="type">int</span>     priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/include/net/net_namespace.h#L55">struct net</a> 是网络命名空间，大概猜测应该是 <code>namespace</code> 隔离的。<br><code>nf_register_net_hook</code> 会根据需要将不 hook 注册到不同的 <code>namespace</code> 。</p>
<p>各字段含义：</p>
<ul>
<li><strong>hook</strong>: 钩子函数指针</li>
<li><strong>dev</strong>: 注册的设备列表，因为将设备抽离了出来</li>
<li><strong>priv</strong>:  </li>
<li><strong>pf</strong>: 协议，IPV4 或者 IPV6</li>
<li><strong>hooknum</strong>: 当前阶段，处于 HOOK 的哪个阶段</li>
<li><strong>priority</strong>: 优先级，值越大优先级越小</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_hookfn</span><span class="params">(<span class="type">void</span> *priv,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_state</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hook;</span><br><span class="line">  <span class="type">u_int8_t</span> pf;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">in</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">out</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">  <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>skb</strong>: 要处理的数据包</li>
<li><strong>in</strong>： 输入设备</li>
<li><strong>out</strong>：输出设备</li>
<li><strong>okfn</strong>：如果 hook 执行成功且没有异常，那么就会调用这个方法处理后续流程。</li>
</ul>
<p>上一篇文章指出了每个 hook 对应的函数。<br>NF_INET_LOCAL_IN      -&gt;    ip_vs_reply4                NF_IP_PRI_NAT_SRC - 2<br>NF_INET_LOCAL_IN      -&gt;    ip_vs_remote_request4       NF_IP_PRI_NAT_SRC - 1<br>NF_INET_LOCAL_OUT     -&gt;    ip_vs_local_reply4          NF_IP_PRI_NAT_SRC + 1<br>NF_INET_LOCAL_OUT     -&gt;    ip_vs_local_request4        NF_IP_PRI_NAT_DST + 2<br>NF_INET_FORWARD       -&gt;    ip_vs_forward_icmp          99<br>NF_INET_FORWARD       -&gt;    ip_vs_reply4                100</p>
<p>根据优先级字段，越小的优先级越高。所以触发的顺序：<code>ip_vs_reply4</code> &gt; <code>ip_vs_remote_request4</code> &gt; <code>ip_vs_local_reply4</code> &gt; <code>ip_vs_forward_icmp</code> &gt; <code>ip_vs_reply4</code><br>ip_vs_reply4、ip_vs_local_reply4 只用于 NAT 修改 source<br>ip_vs_remote_request4 用于 DR、NAT（修改 Dest）、Tunnel 修改包数据</p>
<p>查看 <code>ipvs</code> 大部分的数据结构：<br><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L37">https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L37</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_iphdr</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> hdr_flags;  <span class="comment">/* ipvs flags */</span></span><br><span class="line">  __u32 off;  <span class="comment">/* Where IP or IPv4 header starts */</span></span><br><span class="line">  __u32 len;  <span class="comment">/* IPv4只是L4的起点</span></span><br><span class="line"><span class="comment">       * IPv6，其中L4传输头开始 */</span></span><br><span class="line">  __u16 fragoffs; <span class="comment">/* IPv6分片偏移，如果第一个分片为0(或不是分片)*/</span></span><br><span class="line">  __s16 protocol;</span><br><span class="line">  __s32 flags;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span> <span class="title">saddr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span> <span class="title">daddr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_seq</span> &#123;</span></span><br><span class="line">  __u32     init_seq; <span class="comment">/* 从这个seq中添加增量 */</span></span><br><span class="line">  __u32     delta;    <span class="comment">/* 序列号中的增量 */</span></span><br><span class="line">  __u32     previous_delta; <span class="comment">/* 序列号中的增量</span></span><br><span class="line"><span class="comment">             * 上次调整pkt大小之前 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ipvs 连接参数，用于保持 ct 的参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_conn_param</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netns_ipvs</span>   *<span class="title">ipvs</span>;</span>  </span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span>  *<span class="title">caddr</span>;</span>  <span class="comment">// 来源地址</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span>  *<span class="title">vaddr</span>;</span>  <span class="comment">// 虚拟地址</span></span><br><span class="line">  __be16        cport;  </span><br><span class="line">  __be16        vport;</span><br><span class="line">  __u16       protocol;</span><br><span class="line">  u16       af;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_pe</span>   *<span class="title">pe</span>;</span>  <span class="comment">// 持久化结构</span></span><br><span class="line">  <span class="type">char</span>        *pe_data;   <span class="comment">// 持久化数据</span></span><br><span class="line">  __u8        pe_data_len;  <span class="comment">// 持久化长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>[ip_vs_conn](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L502)</code>：连接对象，主要为了维护相同的客户端与真实服务器之间的连接关系。这是由于 TCP 协议是面向连接的，所以同一个的客户端每次选择真实服务器的时候必须保存一致，否则会出现连接中断的情况，而连接对象就是为了维护这种关系。<br><code>[ip_vs_service](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L612)</code>：服务配置对象，主要用于保存 LVS 的配置信息，如 支持的 传输层协议、虚拟IP 和 端口 等。<br><code>[ip_vs_dest](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L654)</code>：真实服务器对象，主要用于保存真实服务器 (Real-Server) 的配置，如 真实IP、端口 和 权重 等。<br><code>[ip_vs_scheduler](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L696)</code>：调度器对象，主要通过使用不同的调度算法来选择合适的真实服务器对象。<br><code>[ip_vs_app](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L742)</code>：应用模块对象<br><code>[netns_ipvs](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L832)</code>：命名空间的网络信息</p>
<p>相互之间依赖如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ip_vs_service.destinations &lt;-&gt; ip_vs_dest.n_list</span><br><span class="line">n_list 属于 ip_vs_dest</span><br><span class="line">n_list 包含 ip_vs_dest</span><br><span class="line">ip_vs_service.scheduler  -&gt; ip_vs_scheduler</span><br><span class="line">ip_vs_scheduler.scheduler -&gt; 调度算法</span><br><span class="line">调度算法 调用  ip_vs_dest</span><br><span class="line"></span><br><span class="line">struct list_head &#123;</span><br><span class="line">  struct list_head *next, *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ip_vs_service 对象的 destinations 字段用于保存 ip_vs_dest 对象的列表，而 scheduler 字段指向了一个 ip_vs_scheduler 对象。<br>ip_vs_scheduler 对象的 schedule 字段指向了一个调度算法函数，通过这个调度函数可以从 ip_vs_service 对象的 ip_vs_dest 对象列表中选择一个合适的真实服务器。</p>
<p>通常操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node1 ]# ipvsadm -A -t node1:80 -s wrr</span><br><span class="line">node1 ]# ipvsadm -a -t node1:80 -r node2 -m -w 3</span><br><span class="line">node1 ]# ipvsadm -a -t node1:80 -r node3 -m -w 5</span><br></pre></td></tr></table></figure>

<p><code>ipvsadm -A -t node1:80</code> 用于添加一个虚拟服务，使用 ip_vs_service 保存。<br><code> -s wrr</code>：用于添加一个调度算法，追加到  <code>ip_vs_service.scheduler</code><br><code>ipvsadm -a -t node1:80 -r node2</code> 用于添加一个 <code>ip_vs_service.destinations</code> 实例，使用 <code>ip_vs_dest</code> 保存。</p>
<p>看看实际添加操作，除了初始化外，可能还好奇用户空间的接口，可以在这里查看 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_ctl.c#L3896">ip_vs_ctl.c</a>, by 让内核不在神秘</p>
<p>2021年8月19日<br>思考：今天在考虑网络流量包进来以后是如何触发 <code>NF_HOOK</code> 方法的，然后分别触发每个 <code>ipvs</code> 的 hook，例如： <code>[ip_rcv](https://elixir.bootlin.com/linux/v5.11.2/source/net/ipv4/ip_input.c#L530)</code> 触发 <code>NF_INET_PRE_ROUTING</code> 方法。<br>总结：思考太过于纠结底层，倒是错失了很多有用的信息，已经不止一次这样思考。根据 《Linux 内核网络协议》 书中就可以解开这个问题。因为网络数据包都是经过网卡 DMA 的形式将<br>数据包放置到指定内存的位置，然后通过引脚触发 CPU 中断，中断后执行上半段函数，然后根据情况在 <code>硬/软中断</code> 中执行下半段函数。这一段就跳过吧。看了没什么意思。</p>
<p>接着上面的分析。</p>
<blockquote>
<p>根据优先级字段，越小的优先级越高。所以触发的顺序：<code>ip_vs_reply4</code> &gt; <code>ip_vs_remote_request4</code> &gt; <code>ip_vs_local_reply4</code> &gt; <code>ip_vs_forward_icmp</code> &gt; <code>ip_vs_reply4</code></p>
</blockquote>
<p><code>ip_vs_reply4</code> 被注册到 <code>NF_INET_LOCAL_IN</code> HOOK，<code>NF_INET_LOCAL_IN</code> 执行 <code>LOCAL_IN</code> HOOK 点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ip_vs_reply4</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ip_vs_out(state-&gt;net-&gt;ipvs, state-&gt;hook, skb, AF_INET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">nf_hook_entry_hookfn</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nf_hook_entry *entry, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">         <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> entry-&gt;hook(entry-&gt;priv, skb, state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发调用链路：<code>ip_rcv</code> -&gt; <code>NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,...)</code> -&gt; <code>nf_hook</code> -&gt; <code>nf_hook_slow</code> -&gt; <code>nf_hook_entry_hookfn</code></p>
<p>最终 <code>entry-&gt;hook(entry-&gt;priv, skb, state)</code> 调用到 <code>ip_vs_reply4</code>，<br>priv: 好像没什么用<br>skb: 就是数据包<br>state: 见下面代码，好像是把当前连接的所有上下文都保存在里面了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">nf_hook_state_init</span><span class="params">(<span class="keyword">struct</span> nf_hook_state *p,</span></span><br><span class="line"><span class="params">              <span class="type">unsigned</span> <span class="type">int</span> hook,</span></span><br><span class="line"><span class="params">              <span class="type">u_int8_t</span> pf,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> net_device *indev,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> net_device *outdev,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> sock *sk,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> net *net,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;hook = hook;</span><br><span class="line">  p-&gt;pf = pf;</span><br><span class="line">  p-&gt;in = indev;</span><br><span class="line">  p-&gt;out = outdev;</span><br><span class="line">  p-&gt;sk = sk;</span><br><span class="line">  p-&gt;net = net;</span><br><span class="line">  p-&gt;okfn = okfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用：<code>[ip_vs_out](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_core.c#L1345)</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ip_vs_out</span><span class="params">(<span class="keyword">struct</span> netns_ipvs *ipvs, <span class="type">unsigned</span> <span class="type">int</span> hooknum, <span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> af)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 检查是否存在现有的连接</span></span><br><span class="line">  cp = INDIRECT_CALL_1(pp-&gt;conn_out_get, ip_vs_conn_out_get_proto,</span><br><span class="line">           ipvs, af, skb, &amp;iph);</span><br><span class="line">  <span class="comment">// 存在直接调用当前连接</span></span><br><span class="line">  <span class="keyword">if</span> (likely(cp))</span><br><span class="line">    <span class="keyword">return</span> handle_response(af, skb, pd, cp, &amp;iph, hooknum);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在阅读源码时从参考文档上看已经有很多不一样的概念和流程了。所以 <a target="_blank" rel="noopener" href="https://github.com/liexusong/linux-source-code-analyze/blob/master/lvs-principle-and-source-analysis-part2.md">LVS原理与实现 - 实现篇
</a> 可以做个参考，了解一下入门及其思路。<br>整体流程看下来核心的点：</p>
<ol>
<li>接收报文、转发报文</li>
<li>连接的追踪、销毁</li>
<li>负载均衡算法的调度</li>
</ol>
<p>在查看 NF_HOOK 返回值的时候经常看见 <code>NF_STOLEN</code> 返回值，一直不了解什么意思，索性查了一下相关资料：</p>
<blockquote>
<p>NF_INET_PRE_ROUTING(位置1)：可以截获接收的所有报文，包括目的地址是自己的报文和需要转发的报文。<br>NF_INET_LOCAL_IN(位置2)：可以截获目的地址是自己的报文。<br>NF_INET_FORWARD(位置3)：可以截获所有转发的报文。<br>NF_INET_LOCAL_OUT(位置4)：可以截获自身发出的所有报文。<br>NF_INET_POST_ROUTING(位置5)：可以截获发送的所有报文，包括自身发出的报文和转发的报文。</p>
</blockquote>
<blockquote>
<p>#define NF_DROP 0 &#x2F;&#x2F; 丢弃该报文，不再继续传输<br>#define NF_ACCEPT 1 &#x2F;&#x2F; 继续正常传输报文<br>#define NF_STOLEN 2 &#x2F;&#x2F;Netfilter 模块接管该报文，不再继续传输<br>#define NF_QUEUE 3 &#x2F;&#x2F; 对该数据报进行排队，通常用于将数据报提交给用户空间进程处理<br>#define NF_REPEAT 4 &#x2F;&#x2F; 再次调用该钩子函数<br>#define NF_STOP 5 &#x2F;&#x2F; 继续正常传输报文</p>
</blockquote>
<p><strong>NF_ACCEPT表示报文通过了某个钩子函数的处理，下一个钩子函数可以接着处理了。</strong><br><strong>NF_STOP表示报文通过了某个钩子函数的处理，后面的钩子函数你们就不要处理了</strong></p>
<p>来源:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hadis-yuki/p/5529737.html">Netfilter机制</a></p>
<p>经跟着看下一章。</p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../2021-08-16-softroce1/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../../../10/ebpf/2021-08-10-lvs0/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
