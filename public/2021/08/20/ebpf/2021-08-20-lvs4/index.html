<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>LVS  学习： netfilter 与 ipvs 源码理解修改 [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">LVS  学习： netfilter 与 ipvs 源码理解修改</h1>
<article class="post markdown-style">
  <p>参考文档：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/XscKernel/article/details/8186679">深入Linux网络核心堆栈–netfilter详解(整理)</a><br><a target="_blank" rel="noopener" href="https://github.com/liexusong/linux-source-code-analyze/blob/master/lvs-principle-and-source-analysis-part2.md">LVS原理与实现 - 实现篇</a><br><a target="_blank" rel="noopener" href="http://www.linuxvirtualserver.org/zh/index.html">Linux服务器集群系统</a><br><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs">Linux 源码</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hadis-yuki/p/5529737.html">Netfilter机制</a></p>
<p><strong>此文章较长</strong></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Netfilter是Linux 2.4内核的一个子系统，Netfiler使得诸如数据包过滤、网络地址转换(NAT)<br>以及网络连接跟踪等技巧成为可能，这些功能仅通过使用内核网络代码提供的各式各样的hook既可以完成。<br>这些hook位于内核代码中，要么是静态链接的，要么是以动态加载的模块的形式存在。</p>
<p>Linux Virtual Server(LVS) 针对高可伸缩、高可用网络服务的需求，给出了基于IP层和基于内容请求分发的负载<br>平衡调度解决方法，并在Linux内核中实现了这些方法，将一组服务器构成一个实现可伸缩的、高可用网络服务的虚拟<br>服务器。由于负载调度技术是在Linux内核中实现的，我们称之为Linux虚拟服务器（Linux Virtual Server）。</p>
<p>LVS 项目的目标 ：使用集群技术和Linux操作系统实现一个高性能、高可用的服务器，<br>它具有很好的可伸缩性（Scalability）、可靠性（Reliability）和可管理性（Manageability）</p>
<p>在LVS框架中，提供了含有IP负载均衡技术的<code>IP虚拟服务器软件IPVS</code>。</p>
<h1 id="Netfilter"><a href="#Netfilter" class="headerlink" title="Netfilter"></a>Netfilter</h1><p>Netfilter中定义了五个关于IPv4的hook，对这些符号的声明可以在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.2/source/include/uapi/linux/netfilter_ipv4.h#L18">netfilter_ipv4.h</a> 中找到，可用的 IP HOOK 如下：</p>
<blockquote>
<p>#define NF_IP_PRE_ROUTING   0   在进行完整性检查之后，可以截获接收的所有报文，包括目的地址是自己的报文和需要转发的报文；目的IP地址转换在此点<br>#define NF_IP_LOCAL_IN      1   路由决策后，可以截获目的地址是自己的报文，INPUT 包过滤在这里进行<br>#define NF_IP_FORWARD       2   截获所有转发的报文，FORWARD 在这里进行过滤<br>#define NF_IP_LOCAL_OUT     3   可以截获自身发出的所有报文(不包括转发)，OUTPUT 过滤在这里进行<br>#define NF_IP_POST_ROUTING  4   可以截获发送的所有报文，包括自身发出的报文和转发的报文</p>
</blockquote>
<p>在hook函数完成了对数据包所需的任何的操作之后，它们必须返回下列预定义的Netfilter返回值中的一个：</p>
<blockquote>
<p>#define NF_DROP     0     丢弃数据包，不在继续<br>#define NF_ACCEPT   1     正常传输报文<br>#define NF_STOLEN   2     Netfilter 模块接管该报文，不再继续传输<br>#define NF_QUEUE    3     对该数据报进行排队，通常用于将数据报提交给用户空间进程处理<br>#define NF_REPEAT   4     再次调用该钩子函数<br>#define NF_STOP     5     继续正常传输报文</p>
</blockquote>
<p><code>Note</code>：NF_ACCEPT和NF_STOP都表示报文通过了检查，可以正常向下流通。</p>
<blockquote>
<p><code>NF_ACCEPT</code> 表示报文通过了某个 <code>HOOK</code> 函数的处理，下一个 <code>HOOK</code> 函数可以接着处理了<br><code>NF_STOP</code> 表示报文通过了某个 <code>HOOK</code> 函数的处理，后面的 <code>HOOK</code> 函数你们就不要处理了</p>
</blockquote>
<p>场景解释：假设有两个 <code>hook</code> 分别是 <code>hook1</code>、<code>hook2</code>，<code>hook1</code> &gt; <code>hook2</code> 优先级。<br><code>hook1</code> 设定的处理结果是<code>NF_STOP</code>，那么报文就会有 <code>hook1</code> 提交给应用程序或者其他处理，因为<code>hook1</code>放行了，根本不会给<code>hook2</code>处理的机会。数据包依然有效</p>
<p>处理代码体现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/nf_queue.c#L237</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_iterate</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> nf_hook_state *state,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> nf_hook_entries *hooks, <span class="type">unsigned</span> <span class="type">int</span> *index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entry</span> *<span class="title">hook</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> verdict, i = *index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; hooks-&gt;num_hook_entries) &#123;</span><br><span class="line">    hook = &amp;hooks-&gt;hooks[i];</span><br><span class="line">repeat:</span><br><span class="line">    verdict = nf_hook_entry_hookfn(hook, skb, state); <span class="comment">// 调用 hook 函数</span></span><br><span class="line">    <span class="keyword">if</span> (verdict != NF_ACCEPT) &#123;</span><br><span class="line">      *index = i;</span><br><span class="line">      <span class="keyword">if</span> (verdict != NF_REPEAT) <span class="comment">// 不是重试直接返回</span></span><br><span class="line">        <span class="keyword">return</span> verdict;</span><br><span class="line">      <span class="keyword">goto</span> repeat;   <span class="comment">// 重试</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册-注销-hook"><a href="#注册-注销-hook" class="headerlink" title="注册&#x2F;注销 hook"></a>注册&#x2F;注销 hook</h2><p>注册一个hook函数是围绕nf_hook_ops数据结构,数据结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.11.2/source/include/linux/netfilter.h#L77</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_hookfn</span><span class="params">(<span class="type">void</span> *priv,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> &#123;</span></span><br><span class="line">  nf_hookfn   *hook;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">  <span class="type">void</span>      *priv;</span><br><span class="line">  <span class="type">u_int8_t</span>    pf;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>    hooknum;</span><br><span class="line">  <span class="type">int</span>     priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_state</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hook;</span><br><span class="line">  <span class="type">u_int8_t</span> pf;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">in</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">out</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">  <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>priv：私有数据<br>skb：正在处理的报文<br>state：将相关参数都将存储到state中<br>hook：hook 函数<br>dev：设备<br>pf：协议族<br>hooknum：hook 触发点的编号<br>priority：优先级<br>net_device *in：用于描述数据包到达的接口<br>net_device *out：用于描述数据包离开的接口</p>
</blockquote>
<p>参数 <code>in</code> 只用于<code>NF_IP_PRE_ROUTING</code>和<code>NF_IP_LOCAL_IN</code>，参数<code>out</code>只用于<code>NF_IP_LOCAL_OUT</code>和<code>NF_IP_POST_ROUTING</code></p>
<p>注册一个Netfilter <code>hook</code> 需要调用 <code>nf_register_net_hook()</code> 函数，以及用到一个 <code>nf_hook_ops</code> 数据结构。<br><code>nf_register_net_hook()</code>函数以一个 <code>nf_hook_ops</code> 数据结构的地址作为参数并且返回一个整型的值。 代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/core.c#L557</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_register_net_hooks</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *reg,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    err = nf_register_net_hook(net, &amp;reg[i]); <span class="comment">// 注册 hook 函数</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">goto</span> err; <span class="comment">// 注册失败</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="comment">// 注销 hook 函数</span></span><br><span class="line">    nf_unregister_net_hooks(net, reg, i);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="hook-触发"><a href="#hook-触发" class="headerlink" title="hook 触发"></a>hook 触发</h2><p>因为制作 hook 触发需要将程序加载到内核中，所以先了解下 linux 内核模块化，加载和卸载。</p>
<p>创建两个个源代码文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hds.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">// 任何模块都必须包含，定义了可动态加载到内核的模块所需要的必要信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> <span class="comment">// 必须包含，包含了宏__init(指定初始化函数)和__exit(指定清除函数)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">//里面包含常用的内核API，例如内核打印函数printk()</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hds_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//__init将函数hds_init()标记为初始化函数，在模块被装载到内核时调用hds_init()</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(KERN_CRIT <span class="string">&quot;Hello Kernell\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hds_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//清除函数,在模块被卸载之前调用</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;GoodBye Kernel\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hds_init);</span><br><span class="line">module_exit(hds_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;jony&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;for fun&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Makefile</span><br><span class="line">obj-m:=hds.o <span class="comment">#根据make的自动推导原则，make会自动将源程序hds.c编译成目标程序hds.o</span></span><br><span class="line">            <span class="comment">#所有在配置文件中标记为-m的模块将被编译成可动态加载进内核的模块。即后缀为.ko的文件</span></span><br><span class="line">CURRENT_PATH:=$(shell <span class="built_in">pwd</span>)        <span class="comment">#参数化，将模块源码路径保存在CURRENT_PATH中</span></span><br><span class="line">LINUX_KERNEL:=$(shell <span class="built_in">uname</span> -r)   <span class="comment">#参数化，将当前内核版本保存在LINUX_KERNEL中</span></span><br><span class="line">LINUX_KERNEL_PATH:=/usr/src/linux-headers-$(LINUX_KERNEL)      <span class="comment">#参数化，将内核源代码的绝对路径保存在LINUX_KERNEL_PATH中</span></span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules    <span class="comment">#编译模块</span></span><br><span class="line">clean:</span><br><span class="line">        make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean  <span class="comment">#清理</span></span><br></pre></td></tr></table></figure>

<p>两个文件创建完成后，执行编译加载命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make    <span class="comment"># 执行编译</span></span><br><span class="line">$ <span class="built_in">sudo</span> insmod hds.ko  <span class="comment"># 模块加载到内核</span></span><br><span class="line">$ lsmod |grep hds   <span class="comment"># 查看是否加载成功</span></span><br><span class="line">$ dmesg   <span class="comment"># 查看内核输出</span></span><br><span class="line">$ <span class="built_in">sudo</span> rmmod hds <span class="comment"># 卸载内核模块</span></span><br></pre></td></tr></table></figure>
<p><strong>制作 HOOK</strong></p>
<p>制作一个轻量级防火墙，根据 <code>net_device</code> 中的 <code>name</code> 字段来制作防火墙。比如当 <code>in-&gt;name</code> 等于 <code>eth0</code> 的时候我们<br>就返回 <code>NF_DROP</code> ，数据包会自动销毁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drop_if_lo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter_ipv4.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">nf_drop</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *if_name = <span class="string">&quot;eth0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hook_func</span><span class="params">(<span class="type">void</span> *priv,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(state-&gt;out != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(state-&gt;out-&gt;name,if_name) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> NF_DROP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">drop_if_lo_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(KERN_CRIT <span class="string">&quot;drop_if_lo_init&quot;</span>);</span><br><span class="line">        nf_drop.hook = &amp;hook_func;</span><br><span class="line">        nf_drop.pf = PF_INET;</span><br><span class="line">        nf_drop.hooknum = NF_INET_LOCAL_OUT;</span><br><span class="line">        nf_drop.priority = NF_IP_PRI_FIRST;</span><br><span class="line"></span><br><span class="line">        nf_register_net_hook(&amp;init_net, &amp;nf_drop);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">drop_if_lo_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;drop if lo exit\n&quot;</span>);</span><br><span class="line">        nf_unregister_net_hook(&amp;init_net, &amp;nf_drop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(drop_if_lo_init);</span><br><span class="line">module_exit(drop_if_lo_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;jony&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;drop if eth0&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//Makefile</span><br><span class="line">obj-m:=drop_if_lo.o</span><br><span class="line"></span><br><span class="line">CURRENT_PATH:=$(shell <span class="built_in">pwd</span>)</span><br><span class="line">LINUX_KERNEL:=$(shell <span class="built_in">uname</span> -r)</span><br><span class="line">LINUX_KERNEL_PATH:=/usr/src/linux-headers-$(LINUX_KERNEL)</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules</span><br><span class="line">clean:</span><br><span class="line">        make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题：理想状态是只会删除 eth0 的数据包，不会删除其他网卡的数据包，但是实际情况是任何数据包都被删除了。查下原因本地访问会自动转为 lo 设备。</p>
<p>总结：Netfilter 基本上特点大概都了解了一遍，基本上 Netfilter 原理大致都了解，也可以通过编写内核模块来编写 Netfilter 插件，加载到内核中执行。</p>
<blockquote>
<p><strong><code>Note：在linux内核中默认情况下，会有一个默认的网络命名空间，其名为init_net</code></strong></p>
</blockquote>
<h1 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h1><p>学完 Netfilter 之后，在看 IPVS 基本已经没有秘密，IPVS 也是在基于 Netfilter 编写的一款插件。<br>关于注册就不在考虑如何注册整个流程，只学习下几个核心功能。</p>
<blockquote>
<p><code>[ip_vs_service](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L612)</code>：服务配置对象，主要用于保存 LVS 的配置信息，如 支持的 传输层协议、虚拟IP 和 端口 等。<br><code>[ip_vs_dest](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L654)</code>：真实服务器对象，主要用于保存真实服务器 (Real-Server) 的配置，如 真实IP、端口 和 权重 等。<br><code>[ip_vs_scheduler](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L696)</code>：调度器对象，主要通过使用不同的调度算法来选择合适的真实服务器对象。<br><code>[ip_vs_conn](https://elixir.bootlin.com/linux/v5.11.2/source/include/net/ip_vs.h#L502)</code>：连接对象，主要为了维护相同的客户端与真实服务器之间的连接关系。这是由于 TCP 协议是面向连接的，所以同一个的客户端每次选择真实服务器的时候必须保存一致，否则会出现连接中断的情况，而连接对象就是为了维护这种关系。<br><code>[ip_vs_xmit](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_conn.c#L512)</code>：数据包转发模式<br><code>[ip_vs_app](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_xmit.c)</code>：应用层协议对象的一种实现</p>
</blockquote>
<p>来自 <a href="./lvs3.md">LVS  学习： 源码理解修改</a></p>
<h2 id="ip-vs-service"><a href="#ip-vs-service" class="headerlink" title="ip_vs_service"></a>ip_vs_service</h2><blockquote>
<p>注：Persistence(PE) 设置持久连接，这个模式可以使来自客户的多个请求被送到同一个真实服务器</p>
</blockquote>
<p><code>ip_vs_service</code> 的创建通过 <code>ip_vs_add_service()</code> 函数来完成，真实代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_ctl.c#L1286</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ip_vs_add_service</span><span class="params">(<span class="keyword">struct</span> netns_ipvs *ipvs, <span class="comment">// 所属哪个命名空间</span></span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> ip_vs_service_user_kern *u, <span class="comment">// 用户通过命令行配置的规则信息</span></span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> ip_vs_service **svc_p</span></span><br><span class="line"><span class="params">      )</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>, i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_scheduler</span> *<span class="title">sched</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_pe</span> *<span class="title">pe</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_service</span> *<span class="title">svc</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> ret_hooks = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(u-&gt;sched_name, <span class="string">&quot;none&quot;</span>)) &#123; <span class="comment">// 根据调度器名称获取调度策略对象</span></span><br><span class="line">    sched = ip_vs_scheduler_get(u-&gt;sched_name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (u-&gt;pe_name &amp;&amp; *u-&gt;pe_name) &#123;  <span class="comment">// 根据持久化名称获取持久化管理方法</span></span><br><span class="line">    pe = ip_vs_pe_getbyname(u-&gt;pe_name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((u-&gt;af == AF_INET &amp;&amp; !ipvs-&gt;num_services) ||</span><br><span class="line">      (u-&gt;af == AF_INET6 &amp;&amp; !ipvs-&gt;num_services6)) &#123;</span><br><span class="line">    ret = ip_vs_register_hooks(ipvs, u-&gt;af);  <span class="comment">// 如果是首次创建 SVC，那么就将调度策略注册到 Netfilter</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> out_err;</span><br><span class="line">    ret_hooks = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  svc = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_vs_service), GFP_KERNEL); <span class="comment">// 申请一个 ip_vs_service 对象</span></span><br><span class="line">  svc-&gt;af = u-&gt;af; <span class="comment">// 3 层协议</span></span><br><span class="line">  svc-&gt;protocol = u-&gt;protocol; <span class="comment">// 4 层协议</span></span><br><span class="line">  ip_vs_addr_copy(svc-&gt;af, &amp;svc-&gt;addr, &amp;u-&gt;addr); <span class="comment">// svc IP</span></span><br><span class="line">  svc-&gt;port = u-&gt;port; <span class="comment">// svc 端口</span></span><br><span class="line">  svc-&gt;fwmark = u-&gt;fwmark; <span class="comment">// 防火墙标记，持久化对象</span></span><br><span class="line">  svc-&gt;flags = u-&gt;flags; <span class="comment">// 标志位</span></span><br><span class="line">  svc-&gt;timeout = u-&gt;timeout * HZ; <span class="comment">// 超时时间</span></span><br><span class="line">  svc-&gt;netmask = u-&gt;netmask; <span class="comment">// 网络掩码</span></span><br><span class="line">  svc-&gt;ipvs = ipvs; </span><br><span class="line"></span><br><span class="line">  INIT_LIST_HEAD(&amp;svc-&gt;destinations);</span><br><span class="line">  spin_lock_init(&amp;svc-&gt;sched_lock);</span><br><span class="line">  spin_lock_init(&amp;svc-&gt;stats.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sched) &#123;</span><br><span class="line">    ret = ip_vs_bind_scheduler(svc, sched); <span class="comment">// 绑定到指定的调度器</span></span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">      <span class="keyword">goto</span> out_err;</span><br><span class="line">    sched = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">  RCU_INIT_POINTER(svc-&gt;pe, pe);  <span class="comment">// 初始化持久化方式</span></span><br><span class="line">  pe = <span class="literal">NULL</span>;</span><br><span class="line">  ...</span><br><span class="line">  ip_vs_svc_hash(svc); <span class="comment">// 添加 ip_vs_service 到 hash 表</span></span><br><span class="line">  *svc_p = svc; <span class="comment">// 返回 svc</span></span><br><span class="line">  ipvs-&gt;enable = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码主要完成一下几个工作：</p>
<ul>
<li>通过调用 <code>ip_vs_scheduler_get</code> 函数来获取一个 <code>ip_vs_scheduler</code> 调度器</li>
<li>申请 <code>ip_vs_service</code> 对象，并初始化。然后将上面获取到调度器，与当前 <code>svc</code> 绑定</li>
<li>最终将 <code>ip_vs_service</code> 对象添加到全局 hash 表中。（思考：内存决定了 hash 表的上线，如果使用 LRU 是否可以进一步扩展至硬盘）</li>
</ul>
<h2 id="ip-vs-dest"><a href="#ip-vs-dest" class="headerlink" title="ip_vs_dest"></a>ip_vs_dest</h2><p>真实服务器对象，主要用于创建保存真实服务器 (Real-Server) 的相关配置信息。<br>创建 <code>ip_vs_dest</code> 对象通过 <code>ip_vs_add_dest()</code> 创建，具体代码细节如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_ctl.c#L1038</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ip_vs_add_dest</span><span class="params">(<span class="keyword">struct</span> ip_vs_service *svc, <span class="keyword">struct</span> ip_vs_dest_user_kern *udest)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_dest</span> *<span class="title">dest</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span> <span class="title">daddr</span>;</span></span><br><span class="line">  __be16 dport = udest-&gt;port;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="comment">// 复制目标地址</span></span><br><span class="line">  ip_vs_addr_copy(udest-&gt;af, &amp;daddr, &amp;udest-&gt;addr);</span><br><span class="line">  <span class="comment">// 冲当前 svc 的hash 中获取 目标RS地址，检查是否存在，如果存在就直接返回</span></span><br><span class="line">  dest = ip_vs_lookup_dest(svc, udest-&gt;af, &amp;daddr, dport);</span><br><span class="line">  <span class="keyword">if</span> (dest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -EEXIST;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从删除但是没有回收的 hash 中查找 目标RS地址，如果存在就撤回删除</span></span><br><span class="line">  <span class="comment">// 为什么删除了却没有回收，因为需要保证 conn 被正确的关闭，因为如果 conn 还在被引用</span></span><br><span class="line">  <span class="comment">// 直接删除可能会引发不可预测的问题</span></span><br><span class="line">  dest = ip_vs_trash_get_dest(svc, udest-&gt;af, &amp;daddr, dport);</span><br><span class="line">  <span class="keyword">if</span> (dest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 撤回删除状态</span></span><br><span class="line">    __ip_vs_update_dest(svc, dest, udest, <span class="number">1</span>);</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 新建目标 rs 地址，映射到 hash 中</span></span><br><span class="line">    ret = ip_vs_new_dest(svc, udest, &amp;dest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ip_vs_new_dest</span><span class="params">(<span class="keyword">struct</span> ip_vs_service *svc, <span class="keyword">struct</span> ip_vs_dest_user_kern *udest,</span></span><br><span class="line"><span class="params">         <span class="keyword">struct</span> ip_vs_dest **dest_p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_dest</span> *<span class="title">dest</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> atype, i;</span><br><span class="line">  ...</span><br><span class="line">  dest = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_vs_dest), GFP_KERNEL);</span><br><span class="line">  ...</span><br><span class="line">  dest-&gt;af = udest-&gt;af; <span class="comment">// 地址族</span></span><br><span class="line">  dest-&gt;protocol = svc-&gt;protocol; <span class="comment">// 端口协议</span></span><br><span class="line">  dest-&gt;vaddr = svc-&gt;addr; <span class="comment">// 虚拟 IP 地址</span></span><br><span class="line">  dest-&gt;vport = svc-&gt;port; <span class="comment">// 虚拟端口</span></span><br><span class="line">  dest-&gt;vfwmark = svc-&gt;fwmark; <span class="comment">// 虚拟网络掩码</span></span><br><span class="line">  ip_vs_addr_copy(udest-&gt;af, &amp;dest-&gt;addr, &amp;udest-&gt;addr); <span class="comment">// 添加的 RS 地址</span></span><br><span class="line">  dest-&gt;port = udest-&gt;port; <span class="comment">// 添加的 RS 端口</span></span><br><span class="line"></span><br><span class="line">  <span class="type">atomic_set</span>(&amp;dest-&gt;activeconns, <span class="number">0</span>);</span><br><span class="line">  <span class="type">atomic_set</span>(&amp;dest-&gt;inactconns, <span class="number">0</span>);</span><br><span class="line">  <span class="type">atomic_set</span>(&amp;dest-&gt;persistconns, <span class="number">0</span>); <span class="comment">// 初始化连接状态</span></span><br><span class="line">  refcount_set(&amp;dest-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  INIT_HLIST_NODE(&amp;dest-&gt;d_list);</span><br><span class="line">  spin_lock_init(&amp;dest-&gt;dst_lock);</span><br><span class="line">  spin_lock_init(&amp;dest-&gt;stats.lock);</span><br><span class="line">  __ip_vs_update_dest(svc, dest, udest, <span class="number">1</span>);  <span class="comment">// 更新 svc hash 桶中的 dest 地址</span></span><br><span class="line"></span><br><span class="line">  *dest_p = dest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>ip_vs_new_dest() 函数的实现也比较简单，与 svc 一样通过调用 kmalloc() 函数申请一个 ip_vs_dest ，然后根据用户配置的规则信息来初始化 ip_vs_dest 对象的各个字段。</p>
<h2 id="ip-vs-scheduler"><a href="#ip-vs-scheduler" class="headerlink" title="ip_vs_scheduler"></a>ip_vs_scheduler</h2><p><code>ip_vs_scheduler</code> 用于从 <code>ip_vs_service</code> 对象的 <code>destinations</code> hash 桶中获取一个合适的 <code>ip_vs_dest</code> 对象，结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_scheduler</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">n_list</span>;</span>   <span class="comment">/* 调度策略链表 */</span></span><br><span class="line">  <span class="type">char</span>      *name;    <span class="comment">/* scheduler 名称 */</span></span><br><span class="line">  <span class="type">atomic_t</span>    refcnt;   <span class="comment">/* 引用基数 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span>   *<span class="title">module</span>;</span>  <span class="comment">/* THIS_MODULE/NULL */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* scheduler 初始化一个 svc */</span></span><br><span class="line">  <span class="type">int</span> (*init_service)(<span class="keyword">struct</span> ip_vs_service *svc);</span><br><span class="line">  <span class="comment">/* scheduling 停止一个 svc */</span></span><br><span class="line">  <span class="type">void</span> (*done_service)(<span class="keyword">struct</span> ip_vs_service *svc);</span><br><span class="line">  <span class="comment">/* 连接一个目标服务 */</span></span><br><span class="line">  <span class="type">int</span> (*add_dest)(<span class="keyword">struct</span> ip_vs_service *svc, <span class="keyword">struct</span> ip_vs_dest *dest);</span><br><span class="line">  <span class="comment">/* 解除一个目标服务的连接 */</span></span><br><span class="line">  <span class="type">int</span> (*del_dest)(<span class="keyword">struct</span> ip_vs_service *svc, <span class="keyword">struct</span> ip_vs_dest *dest);</span><br><span class="line">  <span class="comment">/* 更新一个目标服务 */</span></span><br><span class="line">  <span class="type">int</span> (*upd_dest)(<span class="keyword">struct</span> ip_vs_service *svc, <span class="keyword">struct</span> ip_vs_dest *dest);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 选择一个真实服务器的对象 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_dest</span>* (*<span class="title">schedule</span>)(<span class="keyword">struct</span> <span class="title">ip_vs_service</span> *<span class="title">svc</span>,</span></span><br><span class="line"><span class="class">               <span class="title">const</span> <span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>,</span></span><br><span class="line"><span class="class">               <span class="keyword">struct</span> <span class="title">ip_vs_iphdr</span> *<span class="title">iph</span>);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述字段中，<code>schedule</code> 是指向一个函数的指针，用于从 <code>ip_vs_service</code> 对象的 <code>destinations</code> hash 桶中获取一个合适的 <code>ip_vs_dest</code> 对象。<code>ip_vs_scheduler</code> 定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_scheduler</span> <span class="title">ip_vs_rr_scheduler</span> =</span> &#123;</span><br><span class="line">  .name =     <span class="string">&quot;rr&quot;</span>,     <span class="comment">/* 策略名称 */</span>  </span><br><span class="line">  .refcnt =   ATOMIC_INIT(<span class="number">0</span>), <span class="comment">// 引用基数</span></span><br><span class="line">  .module =   THIS_MODULE,</span><br><span class="line">  .n_list =   LIST_HEAD_INIT(ip_vs_rr_scheduler.n_list),</span><br><span class="line">  .init_service =   ip_vs_rr_init_svc, <span class="comment">// 调度策略，初始化 svc 方法 ip_vs_rr_init_svc</span></span><br><span class="line">  .add_dest =   <span class="literal">NULL</span>,</span><br><span class="line">  .del_dest =   ip_vs_rr_del_dest,  <span class="comment">// 删除一个目标服务</span></span><br><span class="line">  .schedule =   ip_vs_rr_schedule, <span class="comment">// 调度策略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体调度实现，可以查看该连接：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_rr.c#L53">Round-Robin Scheduling</a></p>
<h2 id="ip-vs-conn"><a href="#ip-vs-conn" class="headerlink" title="ip_vs_conn"></a>ip_vs_conn</h2><p><code>ip_vs_conn</code> 对象是用于维护 <code>访问来源</code> 和 <code>真实目标服务</code> 之间的联系，因为网络都是分包发送的，如果将每个包<br>都是使用调度策略，那么将会产生很多包失效的问题，<code>后端目标服务</code> 将会受到莫名其妙的网络包。</p>
<p>所以为了将来源包发送经过匹配发送到后端某一绑定实例，后端才会收到有用的数据。保持连接的方式有很多种，这里介绍<br>比较常用的 <code>s-hash</code>（来源 hash）。</p>
<p>先了解下 <code>ip_vs_conn</code> 的结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_conn</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">c_list</span>;</span>         <span class="comment">/* hashed list heads */</span></span><br><span class="line">  <span class="comment">/* Protocol, addresses and port numbers */</span></span><br><span class="line">  __be16                  cport; <span class="comment">// 来源端口</span></span><br><span class="line">  __be16                  dport; <span class="comment">// 目标端口</span></span><br><span class="line">  __be16                  vport; <span class="comment">// 虚拟端口</span></span><br><span class="line">  u16     af;   <span class="comment">/* 地址族 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span>      <span class="title">caddr</span>;</span>          <span class="comment">/* 客户端 IP 地址 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span>      <span class="title">vaddr</span>;</span>          <span class="comment">/* 虚拟 IP 地址 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span>      <span class="title">daddr</span>;</span>          <span class="comment">/* 目标地址 */</span></span><br><span class="line">  <span class="keyword">volatile</span> __u32          flags;          <span class="comment">/* 状态 */</span></span><br><span class="line">  __u16                   protocol;       <span class="comment">/* 4 层协议 (TCP/UDP) */</span></span><br><span class="line">  __u16     daf;    <span class="comment">/* 目标地址族 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netns_ipvs</span> *<span class="title">ipvs</span>;</span></span><br><span class="line">  <span class="comment">/* 统计和计时器 */</span></span><br><span class="line">  <span class="type">refcount_t</span>    refcnt;   <span class="comment">/* 引用计数 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span>    <span class="comment">/* 定时器 */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span>  timeout;  <span class="comment">/* 超时时长 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags and state transition */</span></span><br><span class="line">  <span class="type">spinlock_t</span>              lock;           <span class="comment">/* 锁定状态转换 */</span></span><br><span class="line">  <span class="keyword">volatile</span> __u16          state;          <span class="comment">/* state 信息 */</span></span><br><span class="line">  <span class="keyword">volatile</span> __u16          old_state;      </span><br><span class="line">  __u32     fwmark;   <span class="comment">/* 来自skb的防火墙标志 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>   sync_endtime; <span class="comment">/* jiffies + sent_retries */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 管理字段 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_conn</span>       *<span class="title">control</span>;</span>       <span class="comment">/* Master control connection */</span></span><br><span class="line">  <span class="type">atomic_t</span>                n_control;      <span class="comment">/* Number of controlled ones */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_dest</span>       *<span class="title">dest</span>;</span>          <span class="comment">/* real server */</span></span><br><span class="line">  <span class="type">atomic_t</span>                in_pkts;        <span class="comment">/* incoming packet counter */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 发送方式，DR、NAT、Tunnel 都会使用不同的方式进行数据包的转发，</span></span><br><span class="line"><span class="comment">     会根据不同的转发方式，返回 netfilter 结果，如 NF_STOLEN、NF_ACCEPT */</span></span><br><span class="line">  <span class="type">int</span> (*packet_xmit)(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> ip_vs_conn *cp,</span><br><span class="line">         <span class="keyword">struct</span> ip_vs_protocol *pp, <span class="keyword">struct</span> ip_vs_iphdr *iph);</span><br><span class="line">  <span class="comment">/* 下面几个成员主要用于 NAT 模式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_app</span>        *<span class="title">app</span>;</span>           <span class="comment">/* bound ip_vs_app object */</span></span><br><span class="line">  <span class="type">void</span>                    *app_data;      <span class="comment">/* Application private data */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_seq</span>        <span class="title">in_seq</span>;</span>         <span class="comment">/* incoming seq. struct */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_seq</span>        <span class="title">out_seq</span>;</span>        <span class="comment">/* outgoing seq. struct */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_pe</span> *<span class="title">pe</span>;</span></span><br><span class="line">  <span class="type">char</span>      *pe_data;</span><br><span class="line">  __u8      pe_data_len;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>   <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体转发模式的绑定使用 <code>ip_vs_bind_xmit</code> 函数，根据每个连接的不同，绑定转发模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">ip_vs_bind_xmit</span><span class="params">(<span class="keyword">struct</span> ip_vs_conn *cp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (IP_VS_FWD_METHOD(cp)) &#123;</span><br><span class="line">  <span class="keyword">case</span> IP_VS_CONN_F_MASQ:</span><br><span class="line">    cp-&gt;packet_xmit = ip_vs_nat_xmit; <span class="comment">// NAT 模式</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> IP_VS_CONN_F_TUNNEL:</span><br><span class="line">      cp-&gt;packet_xmit = ip_vs_tunnel_xmit; <span class="comment">// Tunnel 模式</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> IP_VS_CONN_F_DROUTE:</span><br><span class="line">    cp-&gt;packet_xmit = ip_vs_dr_xmit; <span class="comment">// DR 模式</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> IP_VS_CONN_F_LOCALNODE:</span><br><span class="line">    cp-&gt;packet_xmit = ip_vs_null_xmit;  <span class="comment">// Null 模式，用于本地地址</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> IP_VS_CONN_F_BYPASS:</span><br><span class="line">    cp-&gt;packet_xmit = ip_vs_bypass_xmit; <span class="comment">// 当目标 RS 不可用时，让数据包绕，可能只用缓存</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个 <code>来源方</code> 请求到达 <code>LVS</code> 服务器后，<code>LVS</code> 会首先根据指定元数据信息和 <code>CT</code> 策略，查找当前来源<br>是否已经有存在的连接，如果有将会通过存在的连接，将请求转发到后端 <code>RS</code>，如果没有那么就创建一个新的连接<br>并且将新建的连接保存。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端请求 -&gt; LVS -&gt; 是否已经存在连接 -是-&gt; 复用已存在的连接 -&gt; 发送到 RS -&gt; 结束</span><br><span class="line">                                    |                     /|\</span><br><span class="line">                                   \|/                     |</span><br><span class="line">                                    否      -&gt;        新建连接并保存 </span><br></pre></td></tr></table></figure>

<h2 id="ip-vs-xmit"><a href="#ip-vs-xmit" class="headerlink" title="ip_vs_xmit"></a>ip_vs_xmit</h2><p>常用的将 <code>LVS</code> 接收到的来源数据包转发到 RS 服务器上的模式核心的三种：<code>[DR](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_xmit.c#L1435)</code>、<code>[NAT](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_xmit.c#L765)</code>、<code>[Tunnel](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_xmit.c#L1133)</code></p>
<h3 id="DR"><a href="#DR" class="headerlink" title="DR"></a>DR</h3><p><code>[DR](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_xmit.c#L1435)</code> （Director）相对容易理解。核心点在目标 <code>MAC</code> 地址上，通过修改目标 <code>MAC</code> 地址可以完成这种方案。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ip_vs_dr_xmit</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> ip_vs_conn *cp,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> ip_vs_protocol *pp, <span class="keyword">struct</span> ip_vs_iphdr *ipvsh)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> local;</span><br><span class="line">  <span class="comment">// 根据元数据信息查找目的服务的路由信息</span></span><br><span class="line">  local = __ip_vs_get_out_rt(cp-&gt;ipvs, cp-&gt;af, skb, cp-&gt;dest, cp-&gt;daddr.ip,</span><br><span class="line">           IP_VS_RT_MODE_LOCAL |</span><br><span class="line">           IP_VS_RT_MODE_NON_LOCAL |</span><br><span class="line">           IP_VS_RT_MODE_KNOWN_NH, <span class="literal">NULL</span>, ipvsh);</span><br><span class="line">  <span class="keyword">if</span> (local &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> tx_error;</span><br><span class="line">  <span class="keyword">if</span> (local)</span><br><span class="line">    <span class="keyword">return</span> ip_vs_send_or_cont(NFPROTO_IPV4, skb, cp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ip_send_check(ip_hdr(skb));</span><br><span class="line">  <span class="comment">// 不允许分片</span></span><br><span class="line">  skb-&gt;ignore_df = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 直接将修改好的数据包发送出去</span></span><br><span class="line">  ip_vs_send_or_cont(NFPROTO_IPV4, skb, cp, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> NF_STOLEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ip-vs-app"><a href="#ip-vs-app" class="headerlink" title="ip_vs_app"></a>ip_vs_app</h2><p><code>ip_vs_app</code> 是通过 LVS 实现了应用层协议的一个框架。为应用层提供了接口，对一些特殊的应用可以进行特殊的处理。<br>目前只支持应用层 <code>FTP</code> 协议。</p>
<p>具体详情查看：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_ftp.c">ip_vs_ftp.c</a>、<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_app.c">ip_vs_app.c</a></p>
<h1 id="知识串联"><a href="#知识串联" class="headerlink" title="知识串联"></a>知识串联</h1><p>通过整个分析来，LVS 核心的代码主要集中在:<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_conn.c">ip_vs_conn.c</a>、<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_core.c">ip_vs_core.c</a>、<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_ctl.c">ip_vs_ctl.c</a> 、<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/ipvs/ip_vs_xmit.c">ip_vs_xmit.c</a>四个个代码文件。分别负责：连接相关、核心流程、对外接口、转发模式。</p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../../../../09/04/ebpf/2021-09-04-katran0/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../../../16/ebpf/2021-08-16-softroce1/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
