<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>LVS  学习： 源码阅读-iptables 整篇文档不行可以不看 [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">LVS  学习： 源码阅读-iptables 整篇文档不行可以不看</h1>
<article class="post markdown-style">
  <h1 id="netfilter-HOOK"><a href="#netfilter-HOOK" class="headerlink" title="netfilter HOOK"></a>netfilter HOOK</h1><p>netfilter 提供了 5 个 hook 点。包经过协议栈时就会触发内核模块注册在这里的处理函数。触发哪个 hook 取决于包的方向、<br>包的目的地址、以及包在上一个 hook 点时丢弃还是拒绝等。</p>
<ul>
<li>NF_IP_PRE_ROUTING: 接收到的包进入协议栈后立即触发此 hook，在进行任何路由判断 （将包发往哪里）之前</li>
<li>NF_IP_LOCAL_IN: 接收到的包经过路由判断，如果目的是本机，将触发此 hook</li>
<li>NF_IP_FORWARD: 接收到的包经过路由判断，如果目的是其他机器，将触发此 hook</li>
<li>NF_IP_LOCAL_OUT: 本机产生的准备发送的包，在进入协议栈后立即触发此 hook</li>
<li>NF_IP_POST_ROUTING: 本机产生的准备发送的包或者转发的包，在经过路由判断之后， 将触发此 hook</li>
</ul>
<p>netfilter 框架，提示该对这个包做以下几个操作之一：</p>
<ul>
<li>NF_ACCEPT: 继续正常遍历</li>
<li>NF_DROP: 丢弃数据包，不再进行遍历</li>
<li>NF_STOLEN: 该模块接收了该包，不再进行遍历</li>
<li>NF_QUEUE: 将数据包排队（通常用于用户空间处理）</li>
<li>NF_REPEAT: 再次调用此hook</li>
</ul>
<h1 id="netfilter-源码阅读"><a href="#netfilter-源码阅读" class="headerlink" title="netfilter 源码阅读"></a>netfilter 源码阅读</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收到的报文</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sk_buff *<span class="title function_">ip_rcv_core</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net *net)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span> <span class="comment">// 定义 ip 报文的数据头</span></span><br><span class="line">  u32 len;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (skb-&gt;pkt_type == PACKET_OTHERHOST)</span><br><span class="line">    <span class="keyword">goto</span> drop; <span class="comment">// 不是自己的数据包就删除</span></span><br><span class="line"></span><br><span class="line">  __IP_UPD_PO_STATS(net, IPSTATS_MIB_IN, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">  skb = skb_share_check(skb, GFP_ATOMIC); <span class="comment">// 如果数据包是共享的，则复制一个出来，复制出来的 skb 就和 socket 没有啥关系了</span></span><br><span class="line">  <span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">    __IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!pskb_may_pull(skb, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr))) <span class="comment">// 检查iphdr 长度是否正确，总的长度 - 数据报文长度</span></span><br><span class="line">    <span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">  iph = ip_hdr(skb); <span class="comment">// 指针移向头部位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iph-&gt;ihl &lt; <span class="number">5</span> || iph-&gt;version != <span class="number">4</span>) <span class="comment">// 头部长度或者协议版本号不对，这里的 5 代表 20 字节</span></span><br><span class="line">    <span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">  __IP_ADD_STATS(net,</span><br><span class="line">           IPSTATS_MIB_NOECTPKTS + (iph-&gt;tos &amp; INET_ECN_MASK),</span><br><span class="line">           <span class="type">max_t</span>(<span class="type">unsigned</span> <span class="type">short</span>, <span class="number">1</span>, skb_shinfo(skb)-&gt;gso_segs)); <span class="comment">// 数据包统计加1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!pskb_may_pull(skb, iph-&gt;ihl*<span class="number">4</span>))  <span class="comment">// 检查头部长度</span></span><br><span class="line">    <span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">  iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlikely(ip_fast_csum((u8 *)iph, iph-&gt;ihl)))<span class="comment">// 检验校验和</span></span><br><span class="line">    <span class="keyword">goto</span> csum_error;</span><br><span class="line"></span><br><span class="line">  len = ntohs(iph-&gt;tot_len);</span><br><span class="line">  <span class="keyword">if</span> (skb-&gt;len &lt; len) &#123; <span class="comment">// 总长度小于报文头长度</span></span><br><span class="line">    __IP_INC_STATS(net, IPSTATS_MIB_INTRUNCATEDPKTS);</span><br><span class="line">    <span class="keyword">goto</span> drop;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; (iph-&gt;ihl*<span class="number">4</span>)) <span class="comment">// 报文头长度小于应该的报文头长度</span></span><br><span class="line">    <span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pskb_trim_rcsum(skb, len)) &#123;</span><br><span class="line">    __IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS); <span class="comment">// **对数据包包进行剪裁，防止分片数据发送过来的数据有重复数据**</span></span><br><span class="line">    <span class="keyword">goto</span> drop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(dev);</span><br><span class="line"></span><br><span class="line">  skb = ip_rcv_core(skb, net);</span><br><span class="line">  <span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> NET_RX_DROP; <span class="comment">// 删除接收的包</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,</span><br><span class="line">           net, <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">           ip_rcv_finish); <span class="comment">// 触发 NF_INET_PRE_ROUTING hook 点，通过回掉函数调用 ip_rcv_finish</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 NF_HOOK 如何处理，也就是进入了 netfilter 处理过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">NF_HOOK</span><span class="params">(<span class="type">uint8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> net_device *in, <span class="keyword">struct</span> net_device *out,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">1</span>) <span class="comment">// 如果没有 HOOK 点就直接调用 okfn ，相对 NF_INET_PRE_ROUTING 来说就是 ip_rcv_finish</span></span><br><span class="line">    ret = okfn(net, sk, skb);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">nf_hook</span><span class="params">(<span class="type">u_int8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> net_device *indev, <span class="keyword">struct</span> net_device *outdev,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entries</span> *<span class="title">hook_head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  rcu_read_lock();</span><br><span class="line">  <span class="keyword">switch</span> (pf) &#123;   </span><br><span class="line">    <span class="comment">// 根据协议获取不同的 nf_hookfn         取得对应的 hook， </span></span><br><span class="line">    <span class="comment">// #define NF_IP_PRE_ROUTING 0        路由前，进入本机的数据</span></span><br><span class="line">    <span class="comment">// #define NF_IP_LOCAL_IN 1           路由后，进入本机的数据</span></span><br><span class="line">    <span class="comment">// #define NF_IP_FORWARD 2            路由后，本机转发的数据</span></span><br><span class="line">    <span class="comment">// #define NF_IP_LOCAL_OUT 3          路由前，本机本地进程发出的数据</span></span><br><span class="line">    <span class="comment">// #define NF_IP_POST_ROUTING 4       路由后，本机发出的数据</span></span><br><span class="line">  <span class="keyword">case</span> NFPROTO_IPV4:</span><br><span class="line">    hook_head = rcu_dereference(net-&gt;nf.hooks_ipv4[hook]);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> NFPROTO_IPV6:</span><br><span class="line">    hook_head = rcu_dereference(net-&gt;nf.hooks_ipv6[hook]);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hook_head) &#123;  <span class="comment">// 如果存在 hook</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_state</span> <span class="title">state</span>;</span></span><br><span class="line"></span><br><span class="line">    nf_hook_state_init(&amp;state, hook, pf, indev, outdev,</span><br><span class="line">           sk, net, okfn); <span class="comment">// 初始化 state</span></span><br><span class="line"></span><br><span class="line">    ret = nf_hook_slow(skb, &amp;state, hook_head, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_hook_slow</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> nf_hook_state *state,</span></span><br><span class="line"><span class="params">     <span class="type">const</span> <span class="keyword">struct</span> nf_hook_entries *hook_head, <span class="type">unsigned</span> <span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> verdict;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="comment">// 遍历 hook 列表</span></span><br><span class="line">  <span class="keyword">for</span> (; s &lt; hook_head-&gt;num_hook_entries; s++) &#123;</span><br><span class="line">    <span class="comment">// 调用 hook 对应的 函数，依次调用指定 hook 点下的所有 entry-&gt;hook 函数。</span></span><br><span class="line">    <span class="comment">// 资料限制 entry 关联了 filter 和 mangle 表</span></span><br><span class="line">    verdict = nf_hook_entry_hookfn(&amp;hook_head-&gt;hooks[s], skb, state);</span><br><span class="line">    <span class="keyword">switch</span> (verdict &amp; NF_VERDICT_MASK) &#123; <span class="comment">// 根据函数返回的结果做对应的处理</span></span><br><span class="line">    <span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NF_DROP:</span><br><span class="line">      kfree_skb(skb);  <span class="comment">// 释放 skb</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>关键数据结构</code></strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entry</span> &#123;</span></span><br><span class="line">  nf_hookfn     *hook;  <span class="comment">// 注册的函数</span></span><br><span class="line">  <span class="type">void</span>        *priv;    <span class="comment">// 优先级</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entries</span> &#123;</span></span><br><span class="line">  u16       num_hook_entries;           <span class="comment">// 总共由多少 hook 统计</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entry</span>    <span class="title">hooks</span>[];</span>      <span class="comment">// hook 表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>上面的代码可以看见整个 NF_HOOK 的调用过程，但是另一个问题还没有解开就是：<strong>“<code>内核是如何注册 HOOK 函数的</code>”</strong>。<br>解答这个问题前：先看下 netfilter 有几个表。<br>iptable 总共有五个表：</p>
<ul>
<li><code>[filter](https://elixir.bootlin.com/linux/v5.11.2/source/net/ipv4/netfilter/iptable_filter.c)</code>： 最常用的 table ，用于判断是否允许一个包通过</li>
<li><code>[nat](https://elixir.bootlin.com/linux/v5.11.2/source/net/ipv4/netfilter/iptable_nat.c)</code>： 用于实现网络地址规则转换</li>
<li><code>[mangle](https://elixir.bootlin.com/linux/v5.11.2/source/net/ipv4/netfilter/iptable_mangle.c)</code>；用于修改包的 IP 头。例如：修改 TTL</li>
<li><code>[raw](https://elixir.bootlin.com/linux/v5.11.2/source/net/ipv4/netfilter/iptable_raw.c)</code>：iptables 防火墙是有状态的：对每个包进行判断的时候依赖以及判断过的包。根据 连接跟踪 ct 使得 iptables 将包看作已有的连接或者会话的一部分，而不是独立的包</li>
<li><code>[security](https://elixir.bootlin.com/linux/v5.11.2/source/net/ipv4/netfilter/iptable_security.c#L114)</code>：table 的作用是给包做 SELinux 标记，以此影响 SELinux</li>
</ul>
<p><strong>通过 iptable 常见的 4 个表：filter、nat、mangle、raw。排个序 Raw &gt; mangle &gt; nat &gt; filter</strong><br><strong>netfilter 对应的 5 个 HOOK ： PREROUTING、INPUT、FORWARD、OUTPUT、POSTROUTING</strong></p>
<p>在内核代码中的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nf_inet_hooks</span> &#123;</span></span><br><span class="line">  NF_INET_PRE_ROUTING,  <span class="comment">//  PREROUTING</span></span><br><span class="line">  NF_INET_LOCAL_IN,     <span class="comment">//  INPUT</span></span><br><span class="line">  NF_INET_FORWARD,      <span class="comment">//  FORWARD</span></span><br><span class="line">  NF_INET_LOCAL_OUT,    <span class="comment">//  OUTPUT</span></span><br><span class="line">  NF_INET_POST_ROUTING, <span class="comment">// POSTROUTING</span></span><br><span class="line">  NF_INET_NUMHOOKS,</span><br><span class="line">  NF_INET_INGRESS = NF_INET_NUMHOOKS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>这五个表分别触发的对应的 HOOK：</p>
<ol>
<li>filter -&gt; INPUT、FORWARD、OUTPUT</li>
<li>Nat -&gt; PREROUTING、POSTROUTING、OUTPUT</li>
<li>Mangle -&gt;  PREROUTING、POSTROUTING、INPUT、OUTPUT、FORWARD</li>
<li>Raw -&gt; OUTPUT、PREROUTING</li>
</ol>
<h2 id="内核是如何注册-HOOK-函数的：filter"><a href="#内核是如何注册-HOOK-函数的：filter" class="headerlink" title="内核是如何注册 HOOK 函数的：filter"></a>内核是如何注册 HOOK 函数的：filter</h2><p>要在内核中使用filter表，首先要向内核注册这个表，然后该表在<code>NF_IP_LOCAL_IN</code>、<code>NF_IP_FORWARD</code>、 <code>NF_IP_LOCAL_OUT</code>三个Hook点<br>注册相应的钩子函数，在内核filter模块的初始化函数（iptable_filter.c），完成了这一功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __net_init <span class="title function_">iptable_filter_table_init</span><span class="params">(<span class="keyword">struct</span> net *net)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (repl == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">  <span class="comment">/* Entry 1 is the FORWARD hook */</span></span><br><span class="line">  ((<span class="keyword">struct</span> ipt_standard *)repl-&gt;entries)[<span class="number">1</span>].target.verdict =</span><br><span class="line">    forward ? -NF_ACCEPT - <span class="number">1</span> : -NF_DROP - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注册 filter 表</span></span><br><span class="line">  err = ipt_register_table(net, &amp;packet_filter, repl, filter_ops,</span><br><span class="line">         &amp;net-&gt;ipv4.iptable_filter);</span><br><span class="line">  kfree(repl);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ipt_register_table</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> xt_table *table,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="keyword">struct</span> ipt_replace *repl,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *ops, <span class="keyword">struct</span> xt_table **res)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册 filter 表的 hook</span></span><br><span class="line">  ret = nf_register_net_hooks(net, ops, hweight32(table-&gt;valid_hooks));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_register_net_hooks</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *reg,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    err = nf_register_net_hook(net, &amp;reg[i]);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="表注册"><a href="#表注册" class="headerlink" title="表注册"></a>表注册</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table</span> &#123;</span></span><br><span class="line">  <span class="comment">// 链表成员</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 位向量，表示当前表影响了哪些（个）HOOK 类型 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> valid_hooks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* iptable的数据区 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> __<span class="title">rcu</span> *<span class="title">private</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 是否在模块中定义，若否，则为NULL */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">me</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">u_int8_t</span> af;    <span class="comment">/* address/protocol family */</span></span><br><span class="line">  <span class="type">int</span> priority;   <span class="comment">/* 优先级 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 在给定的网络中需要表是调用 */</span></span><br><span class="line">  <span class="type">int</span> (*table_init)(<span class="keyword">struct</span> net *net);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 表名，如“filter”、“nat” */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> name[XT_TABLE_MAXNAMELEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> &#123;</span></span><br><span class="line">  <span class="comment">/* 每个表的大小 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">  <span class="comment">/* 表中的规则数. --RR */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> number;</span><br><span class="line">  <span class="comment">/*  初始的规则数，用于模块计数 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> initial_entries;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 记录所影响的HOOK的规则入口相对于下面的entries变量的偏移量 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hook_entry[NF_INET_NUMHOOKS];</span><br><span class="line">  <span class="comment">// 与hook_entry相对应的规则表上限偏移量，当无规则录入时，相应的hook_entry和underflow均为0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> underflow[NF_INET_NUMHOOKS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Number of user chains. Since tables cannot have loops, at most</span></span><br><span class="line"><span class="comment">   * @stacksize jumps (number of user chains) can possibly be made.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> stacksize;</span><br><span class="line">  <span class="type">void</span> ***jumpstack;</span><br><span class="line">  <span class="comment">// 每个CPU的Hook点规则表入口</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> entries[] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-26744085-id-3086405.html">Linux中Netfilter的原理介绍</a></p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../2021-08-10-lvs0/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../../../05/ebpf/2021-08-05-lvs1/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
