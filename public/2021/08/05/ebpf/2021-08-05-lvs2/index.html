<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>LVS  学习： Ct 深入理解 [ Benjmmi 的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="/about">关于</a>
        
          
          
          
          
          
          <a target="_blank" rel="noopener" href="https://github.com/Benjmmi">Codes</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">LVS  学习： Ct 深入理解</h1>
<article class="post markdown-style">
  <h1 id="连接跟踪表"><a href="#连接跟踪表" class="headerlink" title="连接跟踪表"></a>连接跟踪表</h1><p>连接跟踪也是最近学习下来的最关心、最有疑问的的一个问题了，但是应该属于一劳永逸的问题。</p>
<p>问题如下：<br>lvs 是个四层负载均衡转发器，负责将数据包转给后端的服务器。根据调度规则将数据包转发给正确的后端 Server。<br>因为每个 TCP 连接需要包含若干的数据包进行交互，如果每个 Packet 都按照调度规则来调度，比如按照 RR 模式来进行调度，<br>那么该 TCP 连接相关的若干数据包则被轮询转发给了 N 个后端服务器，那么整个数据包就乱套了。显然负载均衡需要将同属<br>于同一个 TCP 连接的数据流的若干数据包转发至其中一台后端服务器上，而不是分散到多个服务器。</p>
<p>解决方案：<br>lvs 若想正确转发数据包，需要维护记录数据包五元组代表的连接信息，包括首次建立连接时调度的 RS。<br>那么后续的同一个连接（会话）的数据包到来后，查询系统维护的连接信息，查到该连接后就能确定这条连接对应的 RS 服务器，<br>最终将数据包正确转发给服务器，这样就完成了将一个 TCP 连接转发给后端服务器了。</p>
<p><strong>复制博客 <a target="_blank" rel="noopener" href="https://www.linuxblogs.cn/articles/20011018.html">https://www.linuxblogs.cn/articles/20011018.html</a></strong></p>
<p>看这个字面意思好像根据五元组将同一个连接的请求打到同一个服务其上，从 L4 负载感觉不是很均衡啊。 和理想的有点差异的样子</p>
<p>lvs 标识一个连接信息，结构体如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_conn</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">c_list</span>;</span>         <span class="comment">/* 哈希链表头 */</span></span><br><span class="line">  <span class="comment">/* Protocol, addresses and port numbers */</span></span><br><span class="line">  __be16                  cport;          <span class="comment">/* 客户端请求源端口 */</span></span><br><span class="line">  __be16                  dport;          <span class="comment">/* 后端服务器的端口，可以不同于 vport */</span></span><br><span class="line">  __be16                  vport;          <span class="comment">/* 访问的业务端口，一般为 80 或 443 */</span></span><br><span class="line">  u16     af;   <span class="comment">/* 协议族，代表 v4 或 v6 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span>      <span class="title">caddr</span>;</span>          <span class="comment">/* 客户端 IP 地址 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span>      <span class="title">vaddr</span>;</span>          <span class="comment">/* 客户端访问的 vip */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span>      <span class="title">daddr</span>;</span>          <span class="comment">/* 后端 RS 服务器 IP 地址 */</span></span><br><span class="line">  <span class="keyword">volatile</span> __u32          flags;          <span class="comment">/* status flags */</span></span><br><span class="line">  __u16                   protocol;       <span class="comment">/* Which protocol (TCP/UDP) */</span></span><br><span class="line">  __u16     daf;    <span class="comment">/* dest 协议族，代表 v4 或 v6 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netns_ipvs</span> *<span class="title">ipvs</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* counter and timer */</span></span><br><span class="line">  <span class="type">refcount_t</span>    refcnt;   <span class="comment">/* 引用计数 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span>    <span class="comment">/* 连接对应的定时器 */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span>  timeout;  <span class="comment">/* 超时时间 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags and state transition */</span></span><br><span class="line">  <span class="type">spinlock_t</span>              lock;           <span class="comment">/* 状态转化时需要锁操作 */</span></span><br><span class="line">  <span class="keyword">volatile</span> __u16          state;          <span class="comment">/* 状态信息 */</span></span><br><span class="line">  <span class="keyword">volatile</span> __u16          old_state;      <span class="comment">/* 保存上一个状态</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">  __u32     fwmark;   <span class="comment">/* Fire wall mark from skb */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>   sync_endtime; <span class="comment">/* jiffies + sent_retries */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Control members */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_conn</span>       *<span class="title">control</span>;</span>       <span class="comment">/* Master control connection */</span></span><br><span class="line">  <span class="type">atomic_t</span>                n_control;      <span class="comment">/* Number of controlled ones */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_dest</span>       *<span class="title">dest</span>;</span>          <span class="comment">/* real server */</span></span><br><span class="line">  <span class="type">atomic_t</span>                in_pkts;        <span class="comment">/* incoming packet counter */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Packet transmitter for different forwarding methods.  If it</span></span><br><span class="line"><span class="comment">   * mangles the packet, it must return NF_DROP or better NF_STOLEN,</span></span><br><span class="line"><span class="comment">   * otherwise this must be changed to a sk_buff **.</span></span><br><span class="line"><span class="comment">   * NF_ACCEPT can be returned when destination is local.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> (*packet_xmit)(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> ip_vs_conn *cp,</span><br><span class="line">         <span class="keyword">struct</span> ip_vs_protocol *pp, <span class="keyword">struct</span> ip_vs_iphdr *iph);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_app</span>        *<span class="title">app</span>;</span>           <span class="comment">/* bound ip_vs_app object */</span></span><br><span class="line">  <span class="type">void</span>                    *app_data;      <span class="comment">/* Application private data */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_seq</span>        <span class="title">in_seq</span>;</span>         <span class="comment">/* incoming seq. struct */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_seq</span>        <span class="title">out_seq</span>;</span>        <span class="comment">/* outgoing seq. struct */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_pe</span> *<span class="title">pe</span>;</span></span><br><span class="line">  <span class="type">char</span>      *pe_data;</span><br><span class="line">  __u8      pe_data_len;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>   <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过这些信息就完成了一个链接表管理。<br><strong>反思：好像和 conntrack 不太一样</strong></p>
<p>lvs 为了提高性能，采用了 hash 表存储，根据 <code>caddr</code>、<code>cport</code>、<code>proto</code> 关键字计算，得到一个 hash 值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip_vs_conn_hashkey(p-&gt;ipvs, p-&gt;af, p-&gt;protocol, addr, port);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ip_vs_conn_hashkey</span><span class="params">(<span class="keyword">struct</span> netns_ipvs *ipvs, <span class="type">int</span> af, <span class="type">unsigned</span> <span class="type">int</span> proto,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">union</span> nf_inet_addr *addr,</span></span><br><span class="line"><span class="params">               __be16 port)</span></span><br></pre></td></tr></table></figure>
<p>然后再根据 hash 下面的链表计算除槽位，相当于 二次 hash 的意思。找对应的连接。</p>
<p>关于连接表的建立：客户端发起  <code>syn</code> 建立连接的时候触发新建连接，相同连接的话其他数据包到来时，只需要查找存在的连接表即可继续后面的转发工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 只有在成功调度可用的后端 RS 服务器后才去新建连接</span></span><br><span class="line">  cp = ip_vs_conn_new(param, type, daddr, dport, flags, dest,</span><br><span class="line">            fwmark);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ip_vs_conn *</span><br><span class="line"><span class="title function_">ip_vs_conn_new</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ip_vs_conn_param *p, <span class="type">int</span> dest_af,</span></span><br><span class="line"><span class="params">         <span class="type">const</span> <span class="keyword">union</span> nf_inet_addr *daddr, __be16 dport, <span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">         <span class="keyword">struct</span> ip_vs_dest *dest, __u32 fwmark)</span></span><br></pre></td></tr></table></figure>

<p>连接创建步骤：</p>
<ol>
<li>分配 <code>连接</code> 所需要的内存资源空间</li>
<li>初始化链表相关字段</li>
<li>设置注册定时器工作函数</li>
<li>填充核心关键字段</li>
<li>关联绑定调度到的后端 RS 服务器</li>
<li>初始化状态、超时时间、绑定 xmit 函数</li>
<li>准备就绪，将 new_conn 挂再全局的哈希表上</li>
</ol>
<p>后续的数据包就可以通过 <code>标识参数</code> 查找<strong>连接表</strong>。 找到改数据包所属的连接信息，也就能确定本次数据包需要转发给后端内的那一台 RS 服务器，<br>通过相关操作后将数据包转发给连接所对应的 目标服务器。</p>
<p>如果使用 <code>DR 模式</code> ，只有客户端请求的流量会经过 LVS 服务器，数据包到达 LVS 会触发下面的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_conn_param</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netns_ipvs</span>   *<span class="title">ipvs</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span>  *<span class="title">caddr</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">union</span> <span class="title">nf_inet_addr</span>  *<span class="title">vaddr</span>;</span></span><br><span class="line">  __be16        cport;</span><br><span class="line">  __be16        vport;</span><br><span class="line">  __u16       protocol;</span><br><span class="line">  u16       af;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_pe</span>   *<span class="title">pe</span>;</span></span><br><span class="line">  <span class="type">char</span>        *pe_data;</span><br><span class="line">  __u8        pe_data_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ip_vs_conn *<span class="title function_">ip_vs_conn_in_get</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ip_vs_conn_param *p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找表达式</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> ip_vs_conn *</span><br><span class="line">__<span class="title function_">ip_vs_conn_in_get</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ip_vs_conn_param *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hash;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_conn</span> *<span class="title">cp</span>;</span></span><br><span class="line">  <span class="comment">// 获取hash</span></span><br><span class="line">  hash = ip_vs_conn_hashkey_param(p, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  rcu_read_lock();</span><br><span class="line">  <span class="comment">// 根据hash 查找链表桶</span></span><br><span class="line">  hlist_for_each_entry_rcu(cp, &amp;ip_vs_conn_tab[hash], c_list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;cport == cp-&gt;cport &amp;&amp; p-&gt;vport == cp-&gt;vport &amp;&amp;</span><br><span class="line">        cp-&gt;af == p-&gt;af &amp;&amp;</span><br><span class="line">        ip_vs_addr_equal(p-&gt;af, p-&gt;caddr, &amp;cp-&gt;caddr) &amp;&amp;</span><br><span class="line">        ip_vs_addr_equal(p-&gt;af, p-&gt;vaddr, &amp;cp-&gt;vaddr) &amp;&amp;</span><br><span class="line">        ((!p-&gt;cport) ^ (!(cp-&gt;flags &amp; IP_VS_CONN_F_NO_CPORT))) &amp;&amp;</span><br><span class="line">        p-&gt;protocol == cp-&gt;protocol &amp;&amp;</span><br><span class="line">        cp-&gt;ipvs == p-&gt;ipvs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!__ip_vs_conn_get(cp))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">/* HIT */</span></span><br><span class="line">      rcu_read_unlock();</span><br><span class="line">      <span class="keyword">return</span> cp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>通过给定参数获取 hash 值，根据哈希值获取链表数据</li>
<li>遍历 <code>ip_vs_conn_tab[hash]</code> 链表数据，查找除真实的连接</li>
</ol>
<p>关于锁的问题：</p>
<p>我们现在生产环境使用的服务器都是多核处理器，在 lvs 转发处理逻辑中需要频繁的查连接表，由于连接表是全局的一张表结构，<br>绝大部分时间 N 个 cpu 会同时操作（包括查找、新建和删除）连接表，这样会导致连接表不一致的问题。因此，每个 cpu<br>对连接表进行相关操作时需要加上相应的 <strong><code>ReadLock 或 WriteLock</code></strong>，才能保证连接表的原子性操作。</p>
<ul>
<li><p><strong>全局锁操作</strong>。假如我们为连接表定义一个全局锁，每个 cpu 在对连接表做读写操作时，<br>都需要先加锁，获取锁后进行相关操作，操作完毕再释放锁资源。这样在高并发的业务场景下，<br>同一时刻锁只能被一个 cpu 占用，因此各 cpu 之间对锁的竞争会非常严重，导致整体 lvs 性能会随着 cpu 个数增加而逐渐下降。</p>
</li>
<li><p><strong>局部锁优化</strong>。lvs 在设计上没有使用全局的锁，而是根据连接表的哈希结构，为 N 个哈希桶设置一个 Lock，这里的 N 为 256，<br>也就是 256 个桶使用一个锁，总共有 4096 个哈希桶。如果有 16 个 cpu 的话，那么同一时间内平均每个 cpu 都可能占有一个锁，<br>从系统整体上看，cpu 对锁操作的竞争就会大大减弱，提高了系统整体的转发能力。</p>
</li>
<li><p><strong>为每个桶绑定一个锁，进一步优化</strong>。局部优化能够很大程度上提高系统性能，同样思路，系统资源允许的情况下，我们可以为每<br>个哈希桶分配设置一个 “锁”，那么各 cpu 之间锁竞争就会变得更小啦，系统性能肯定会有更好地优化。</p>
</li>
<li><p><strong>无锁化，每个 cpu 一张连接表</strong>。既然每个 cpu 都要访问连接表，且会引起锁的竞争恶化，为何不给每个 cpu 维护一张连接表，<br>每个 cpu 只维护自己相关数据连接组成的连接表，每个 cpu 读写 连接表时互不干扰，这样就实现无锁化，完美的避开了锁。</p>
<ul>
<li>每个 cpu 一张连接表</li>
<li>网卡按照 4 元组哈希，同一个数据流肯定会打到同一个 cpu 上去</li>
<li><em>对于 NAT 模式来说，就比较麻烦不好处理</em><br>  主要原因： NAT 回包还会经过 lvs，回包到达 lvs 网卡时，按照 4 元哈希后，数据包可能到达网卡队列 2 了，<br>  而近来的请求数据包到达网卡队列 1 了，那么同一个连接的数据包不在同个 cpu 上就会出现异常现象了，<br>  因为回包到达的 cpu 无法处理该数据包</li>
</ul>
</li>
</ul>
<p>总结：总体来说 conntrack 状态维护最基础通过五元组来完成。将一个 TCP 内的流量打到同一台机器，不同次的请求也同样会<br>打到同一台，初始感觉不合理，可能和思维定位在 L7 有关系。将每次请求都转发至不同 RS 上，但是相对 L4 层，每个连接就是每次<br>请求，通过两个五元组决定转发方向和转发目标。也不会影响到流量。<br>考虑：优化如果每次报文发送都是连续性的</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>总结下来 LVS 依然是在 netfilter 上展开的，但是相对于 LVS 来说核心概念主要涉及连接表和调度算法。它们是 LVS 的核心内容</p>
<p>netfilter 的 HOOK 点对应于内核中的方法：</p>
<ul>
<li><code>NF_INET_PRE_ROUTING</code> 这是所有入栈数据包的第一个挂载点，挂载点位于 <code>ip_rcv</code> 中，v6 的是 <code>ip6_rcf</code></li>
<li><code>NF_INET_LOCAL_IN</code> 对于所有发送到当前主机的入栈数据包，经过挂载点 <code>NF_INET_PRE_ROUTING</code> 并执行路由选择，挂载点位于方法 <code>ip_local_deliver</code> 中</li>
<li><code>NF_INET_FORWARD</code> 对于所有转发的数据包，经过挂载点 <code>NF_INET_PRE_ROUTING</code> 并执行路由选择子系统查找后。挂载点位于 <code>ip_forward</code> 中</li>
<li><code>NF_INET_POST_ROUTING</code> 所有要转发的数据包和当前主机生成的数据包都经过这个挂载点，挂载点位于 <code>ip_output</code> 中</li>
<li><code>NF_INET_LOCAL_OUT</code> 当前主机生成的所有出战数据包都经过这个挂载点，挂载点位于方法 <code>__ip_local_out</code> 中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">ip_vs_ops4</span>[] =</span> &#123;</span><br><span class="line">  <span class="comment">/* 包过滤后，只更改VS/NAT的 source */</span></span><br><span class="line">  &#123;</span><br><span class="line">    .hook   = ip_vs_reply4,</span><br><span class="line">    .pf   = NFPROTO_IPV4,</span><br><span class="line">    .hooknum  = NF_INET_LOCAL_IN,</span><br><span class="line">    .priority = NF_IP_PRI_NAT_SRC - <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 包过滤后，通过VS/DR、VS/TUN或VS/NAT(change destination)转发包，</span></span><br><span class="line"><span class="comment">   * 这样过滤规则就可以应用于IPVS。 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    .hook   = ip_vs_remote_request4,</span><br><span class="line">    .pf   = NFPROTO_IPV4,</span><br><span class="line">    .hooknum  = NF_INET_LOCAL_IN,</span><br><span class="line">    .priority = NF_IP_PRI_NAT_SRC - <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 在 ip_vs_in 之前，只为 VS/NAT 更改source */</span></span><br><span class="line">  &#123;</span><br><span class="line">    .hook   = ip_vs_local_reply4,</span><br><span class="line">    .pf   = NFPROTO_IPV4,</span><br><span class="line">    .hooknum  = NF_INET_LOCAL_OUT,</span><br><span class="line">    .priority = NF_IP_PRI_NAT_DST + <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 在 mangle 之后，调度和转发本地请求 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    .hook   = ip_vs_local_request4,</span><br><span class="line">    .pf   = NFPROTO_IPV4,</span><br><span class="line">    .hooknum  = NF_INET_LOCAL_OUT,</span><br><span class="line">    .priority = NF_IP_PRI_NAT_DST + <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 在包过滤之后（但在 ip_vs_out_icmp 之前），</span></span><br><span class="line"><span class="comment">  *  捕获发往 0.0.0.0/0 的 icmp，用于传入的 IPVS 连接 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    .hook   = ip_vs_forward_icmp,</span><br><span class="line">    .pf   = NFPROTO_IPV4,</span><br><span class="line">    .hooknum  = NF_INET_FORWARD,</span><br><span class="line">    .priority = <span class="number">99</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 包过滤后，只更改VS/NAT的 source */</span></span><br><span class="line">  &#123;</span><br><span class="line">    .hook   = ip_vs_reply4,</span><br><span class="line">    .pf   = NFPROTO_IPV4,</span><br><span class="line">    .hooknum  = NF_INET_FORWARD,</span><br><span class="line">    .priority = <span class="number">100</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的 hook 函数是 <code>ip_vs_in</code> 是数据包的入口位置。从上边注册代码段中，可以知道它注册的挂载点位置是 <code>NF_INET_LOCAL_IN</code> 已经通过了<br>prerouting 和 filter 路由查找的过程。<br>假设在 DR 模式下，数据包转发将会经过如下过程：</p>
<ol>
<li><code>[pp = ip_vs_proto_get(iph.protocol);](https://elixir.bootlin.com/linux/v5.11.2/source/net/netfilter/xt_ipvs.c#L81)</code> 查找是否是 LVS 所支持的协议<br>lvs 所支持。lvs 能够支持 tcp、udp、ah、esp 协议，如果不是 LVS  所支持的协议，那么将直接返回 NF_ACCEPT 也就没有继续执行下去的意义了</li>
<li>调度并新建连接信息<br>  根据数据包 5 元组相关字段进行查找 <code>conn_in_get</code>，这里假设是一个新连接的请求数据包，那么在连接表中是查不到连接表项，将会调用 <code>conn_schedule</code> 新建表项<br>  新建表现的条件：</li>
</ol>
<ul>
<li>数据包必须携带 SYN 标记</li>
<li>数据包所访问请求必须是我们定义的 service 才行<br>  满足上述条件之后，会调用 <code>ip_vs_schedule</code> 方法，从 svc 指向的 dests 中更具调度算法选出一个合适的后端服务器</li>
</ul>
<ol start="3">
<li>在成功调度 dest 后，调用 <code>ip_vs_conn_new</code> 函数来常见真正的连接条目：</li>
</ol>
<ul>
<li>分配 cp 内存资源</li>
<li>设置定时器</li>
<li>填充相关字段</li>
<li>绑定并设置 dest 相关信息，调用 <code>ip_vs_bind_dest</code> 函数</li>
<li>绑定 conn 所需的 xmit 函数，调用 <code>ip_vs_bind_xmit</code> 函数</li>
<li>将 cp 连接条目 hash 到全局的连接表中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">net/netfilter/ipvs/ip_vs_app.c</span><br><span class="line">net/netfilter/ipvs/ip_vs_conn.c</span><br><span class="line">net/netfilter/ipvs/ip_vs_core.c</span><br><span class="line">net/netfilter/ipvs/ip_vs_ctl.c</span><br><span class="line">net/netfilter/ipvs/ip_vs_dh.c         目的地址哈希调度</span><br><span class="line">net/netfilter/ipvs/ip_vs_est.c        简单的速率估计</span><br><span class="line">net/netfilter/ipvs/ip_vs_fo.c         添加了基于权重的初始功能</span><br><span class="line">net/netfilter/ipvs/ip_vs_ftp.c        ftp应用模块</span><br><span class="line">net/netfilter/ipvs/ip_vs_lblc.c           基于局部性的最少连接</span><br><span class="line">net/netfilter/ipvs/ip_vs_lblcr.c      带复制的基于局部性最少链接</span><br><span class="line">net/netfilter/ipvs/ip_vs_lc.c         最少连接调度</span><br><span class="line">net/netfilter/ipvs/ip_vs_mh.c         磁悬浮哈希调度模块</span><br><span class="line">net/netfilter/ipvs/ip_vs_nfct.c       支持IPVS的Netfilter连接跟踪</span><br><span class="line">net/netfilter/ipvs/ip_vs_nq.c         永不排队调度算法</span><br><span class="line">net/netfilter/ipvs/ip_vs_ovf.c        溢出连接调度模块</span><br><span class="line">net/netfilter/ipvs/ip_vs_pe.c         持久化模块</span><br><span class="line">net/netfilter/ipvs/ip_vs_pe_sip.c</span><br><span class="line">net/netfilter/ipvs/ip_vs_proto.c      transport协议支持ipv4负载均衡</span><br><span class="line">net/netfilter/ipvs/ip_vs_proto_ah_esp.c   针对IPV的AH/ESP IPSec负载平衡支持</span><br><span class="line">net/netfilter/ipvs/ip_vs_proto_tcp.c      IPVS的TCP负载平衡支持</span><br><span class="line">net/netfilter/ipvs/ip_vs_proto_udp.c    IPVS的UDP负载平衡支持</span><br><span class="line">net/netfilter/ipvs/ip_vs_rr.c           轮询调度算法</span><br><span class="line">net/netfilter/ipvs/ip_vs_sched.c</span><br><span class="line">net/netfilter/ipvs/ip_vs_sed.c          最少期望延迟调度算法</span><br><span class="line">net/netfilter/ipvs/ip_vs_sh.c           源地址哈希调度</span><br><span class="line">net/netfilter/ipvs/ip_vs_sync.c       </span><br><span class="line">net/netfilter/ipvs/ip_vs_wlc.c          加权最少连接</span><br><span class="line">net/netfilter/ipvs/ip_vs_wrr.c          加权轮询调度</span><br><span class="line">net/netfilter/ipvs/ip_vs_xmit.c</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.2/C/ident/KMSG_COMPONENT">KMSG_COMPONENT</a></p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="../2021-08-05-lvs1/">上一篇</a>
    

    
    <p>上次更新 2024-08-26</p>
    
    
        <a class="extend next post-next" href="../../../../07/13/ebpf/2021-07-13-bpf-helpers/">下一篇</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:2228598786@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/Benjmmi" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © Benjmmi 2017 - 2025
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>

  <script src='https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
    </div>
</body>
</html>
